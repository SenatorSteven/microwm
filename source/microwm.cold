
/*!
	shrinking windows per 16 pixels still causes trouble when trying to shrink tiny window (moves it when it shouldn't be moved)... but only when using diagonals.
*/

/*!
	add mechanism to attach and detach window on top of virtual root or entire system.
*/

/*!
	opening gedit when it was last maximized causes incorrect placement that's not even in the same monitor.
*/

/*!
	after going fullscreen with window, popup subwindows appear transiently. if you focus out and then in again the problem solves itself.
*/

/*!
	using restackVirtualRootBelow() might cause fullscreen window stacking issues, but only visual issues.
*/

/*!
	moving fullscreen between desktops might cause issues.
*/

/*!
	workarea is not set properly if windows are, say, next to each other yet obscuring the top part of multiple monitors.
*/

/*!
	if state is changed into demands attention, raise it (above, none).
*/

/*!
	what happens to old client positions when screen is updated? write a function for that.
*/

/*!
	future updates:
		properly get the wm selection and leave another wm take over.
		move clients out of view instead of unmapping to allow for compositor tricks.
		continue the session as if a wm just stopped operating. act similarly for existing clients.
		support everything in the icccm and then ewmh.
		support modality when restacking.
		lose all focus on click of the desktop.
*/

/*!
	respect window gravities on configure request.
*/

/*!
	support having more desktop names than the desktop amount.
*/

/*!
	    x draw _NET_WM_VISIBLE_NAME. if none, draw _NET_WM_NAME. if none, draw WM_NAME.
	    x use _NET_WM_VISIBLE_ICON_NAME. if none, use _NET_WM_ICON_NAME. if none, use WM_ICON_NAME.

	v     use normal hint position
	    x use normal hint size
	v     use normal hint min size
	v     use normal hint max size
	    x use normal hint inc size
	    x use normal hint min aspect
	    x use normal hint max aspect
	v     use normal hint base size
	    x use normal hint window gravity

	v     use hint input
	v     use hint initial state
	    x use hint icon pixmap
	    x use hint icon window
	    x use hint icon position
	    x use hint icon mask
	    x use hint window group
	v     use hint urgency

	    x use class

	v     use transient for window

	v     use protocol WM_TAKE_FOCUS
	v     use protocol WM_DELETE_WINDOW
	    x use protocol _NET_WM_PING
	    x use protocol _NET_WM_SYNC_REQUEST

	    x use colormap windows

	    x use client machine

	    x register a window on the session manager
	    x use client id
	    x use client leader
	    x use window role

	v     use state

	v     use desktop

	v     use window type

	v     use window state

	v     use allowed actions

	v     use window strut

	    x use icon geometry

	    x use icon

	v     use pid

	    x use handled icons

	v     use user time

	v     use frame extents
*/



























/*! microwm.cold

MIT License

Copyright (C) 2019 Stefanos "Steven" Tsakiris

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE. */

/*!includes:{*/
	#define _POSIX_C_SOURCE /*-*/ (200112L)
	#define _DEFAULT_SOURCE

	#include <dirent.h>
	#include <errno.h>
	#include <grp.h>
	#include <limits.h>
	#include <locale.h>
	#include <poll.h>
	#include <pthread.h>
	#include <pwd.h>
	#include <signal.h>
	#include <stdarg.h>
	#include <stdio.h>
	#include <stdlib.h>
	#include <unistd.h>
	#include <sys/shm.h>
	#include <sys/stat.h>
	#include <sys/wait.h>
	#include <xcb/randr.h>
	#include <xcb/shape.h>
	#include <xcb/xcb.h>
	#include <xcb/xcbext.h>
	#include <xcb/xfixes.h>
	#include "headers/cold/cold.hold"
/*!}*/

/*!defines:{*/
	#define DEBUG /*-----------------------------------------*/ (false)

	#define PROGRAM_NAME /*----------------------------------*/ "microwm"

	#define ROOT_UID /*--------------------------------------*/ (0)
	#define ROOT_GID /*--------------------------------------*/ (0)

	#define PTHREAD_CREATE_SUCCESS /*------------------------*/ (0)
	#define PTHREAD_SETCANCELSTATE_SUCCESS /*----------------*/ (0)
	#define PTHREAD_SETCANCELTYPE_SUCCESS /*-----------------*/ (0)
	#define PTHREAD_MUTEXATTR_INIT_SUCCESS /*----------------*/ (0)
	#define PTHREAD_MUTEXATTR_SETPSHARED_SUCCESS /*----------*/ (0)
	#define PTHREAD_MUTEXATTR_DESTROY_SUCCESS /*-------------*/ (0)
	#define PTHREAD_MUTEX_INIT_SUCCESS /*--------------------*/ (0)
	#define PTHREAD_MUTEX_LOCK_SUCCESS /*--------------------*/ (0)
	#define PTHREAD_MUTEX_TRYLOCK_SUCCESS /*-----------------*/ (0)
	#define PTHREAD_MUTEX_UNLOCK_SUCCESS /*------------------*/ (0)
	#define PTHREAD_MUTEX_DESTROY_SUCCESS /*-----------------*/ (0)
	#define PTHREAD_CONDATTR_INIT_SUCCESS /*-----------------*/ (0)
	#define PTHREAD_CONDATTR_SETPSHARED_SUCCESS /*-----------*/ (0)
	#define PTHREAD_CONDATTR_DESTROY_SUCCESS /*--------------*/ (0)
	#define PTHREAD_COND_INIT_SUCCESS /*---------------------*/ (0)
	#define PTHREAD_COND_WAIT_SUCCESS /*---------------------*/ (0)
	#define PTHREAD_COND_TIMEDWAIT_SUCCESS /*----------------*/ (0)
	#define PTHREAD_COND_SIGNAL_SUCCESS /*-------------------*/ (0)
	#define PTHREAD_COND_BROADCAST_SUCCESS /*----------------*/ (0)
	#define PTHREAD_COND_DESTROY_SUCCESS /*------------------*/ (0)
	#define PTHREAD_RWLOCKATTR_INIT_SUCCESS /*---------------*/ (0)
	#define PTHREAD_RWLOCKATTR_SETKIND_NP_SUCCESS /*---------*/ (0)
	#define PTHREAD_RWLOCKATTR_DESTROY_SUCCESS /*------------*/ (0)
	#define PTHREAD_RWLOCK_INIT_SUCCESS /*-------------------*/ (0)
	#define PTHREAD_RWLOCK_WRLOCK_SUCCESS /*-----------------*/ (0)
	#define PTHREAD_RWLOCK_RDLOCK_SUCCESS /*-----------------*/ (0)
	#define PTHREAD_RWLOCK_UNLOCK_SUCCESS /*-----------------*/ (0)
	#define PTHREAD_RWLOCK_DESTROY_SUCCESS /*----------------*/ (0)
	#define PTHREAD_CANCEL_SUCCESS /*------------------------*/ (0)
	#define PTHREAD_JOIN_SUCCESS /*--------------------------*/ (0)

	#define GETHOSTNAME_SUCCESS /*---------------------------*/ (0)

	#define DEFAULT_OUTPUT_STREAM /*-------------------------*/ (stdout)
	#define DEFAULT_ERROR_STREAM /*--------------------------*/ (stderr)

	#define MESSAGE_START /*---------------------------------*/ ("\x1b[1m")
	#define MESSAGE_FATAL /*---------------------------------*/ ("\x1b[91m")
	#define MESSAGE_ERROR /*---------------------------------*/ ("\x1b[33m")
	#define MESSAGE_EVENT /*---------------------------------*/ ("\x1b[32m")
	#define MESSAGE_END /*-----------------------------------*/ ("\x1b[m")

	#define NONE_ARGUMENT /*---------------------------------*/ (0)
	#define UNRECOGNIZED_ARGUMENT /*-------------------------*/ (1)
	#define HELP_ARGUMENT /*---------------------------------*/ (2)
	#define STDOUT_ARGUMENT /*-------------------------------*/ (3)
	#define STDERR_ARGUMENT /*-------------------------------*/ (4)
	#define CONFIG_ARGUMENT /*-------------------------------*/ (5)
	#define ERROR_ARGUMENT /*--------------------------------*/ (6)
	#define SERVER_ARGUMENT /*-------------------------------*/ (7)

	#define WHICH_MONITOR_CONTENT(k, v, n, p) /*-------------*/ { \
		  v(none)           k(NONE##p) \
		, v(pointer)        k(POINTER##p) \
		, v(focused-window) k(FOCUSED_WINDOW##p) \
		, v(all)            k(ALL##p) \
		, v(self)           k(SELF##p) \
		, n(NULL)           k(NULL##p) \
	}

	#define NUMBER_TYPE_CONTENT(k, v, n, p) /*---------------*/ { \
		  v(none)       k(NONE##p) \
		, v(integer)    k(INTEGER##p) \
		, v(percentage) k(PERCENTAGE##p) \
		, v(millimeter) k(MILLIMETER##p) \
		, n(NULL)       k(NULL##p) \
	}

	#define POSITION_CONTENT(k, v, n, p) /*------------------*/ { \
		  v(none)   k(NONE##p) \
		, v(top)    k(TOP##p) \
		, v(bottom) k(BOTTOM##p) \
		, v(left)   k(LEFT##p) \
		, v(right)  k(RIGHT##p) \
		, n(NULL)   k(NULL##p) \
	}

	#define HORIZONTAL_ALIGNMENT_CONTENT(k, v, n, p) /*------*/ { \
		  v(none)   k(NONE##p) \
		, v(left)   k(LEFT##p) \
		, v(center) k(CENTER##p) \
		, v(right)  k(RIGHT##p) \
		, n(NULL)   k(NULL##p) \
	}

	#define VERTICAL_ALIGNMENT_CONTENT(k, v, n, p) /*--------*/ { \
		  v(none)   k(NONE##p) \
		, v(top)    k(TOP##p) \
		, v(center) k(CENTER##p) \
		, v(bottom) k(BOTTOM##p) \
		, n(NULL)   k(NULL##p) \
	}

	#define CORNER_CONTENT(k, v, n, p) /*--------------------*/ { \
		  v(none)         k(NONE##p         = (b(0000))) \
		, v(top-left)     k(TOP_LEFT##p     = (b(0001))) \
		, v(top-right)    k(TOP_RIGHT##p    = (b(0010))) \
		, v(bottom-left)  k(BOTTOM_LEFT##p  = (b(0100))) \
		, v(bottom-right) k(BOTTOM_RIGHT##p = (b(1000))) \
		, n(NULL)         k(NULL##p) \
	}

	#define AXIS_CONTENT(k, v, n, p) /*----------------------*/ { \
		  v(none)       k(NONE##p) \
		, v(horizontal) k(HORIZONTAL##p) \
		, v(vertical)   k(VERTICAL##p) \
		, n(NULL)       k(NULL##p) \
	}

	#define NONE_NORMAL_HINT /*------------------------------*/ (b(0000000000))
	#define USER_POSITION_NORMAL_HINT /*---------------------*/ (b(0000000001))
	#define USER_SIZE_NORMAL_HINT /*-------------------------*/ (b(0000000010))
	#define PROGRAM_POSITION_NORMAL_HINT /*------------------*/ (b(0000000100))
	#define PROGRAM_SIZE_NORMAL_HINT /*----------------------*/ (b(0000001000))
	#define PROGRAM_MINIMUM_SIZE_NORMAL_HINT /*--------------*/ (b(0000010000))
	#define PROGRAM_MAXIMUM_SIZE_NORMAL_HINT /*--------------*/ (b(0000100000))
	#define PROGRAM_RESIZE_INCREMENT_NORMAL_HINT /*----------*/ (b(0001000000))
	#define PROGRAM_ASPECT_NORMAL_HINT /*--------------------*/ (b(0010000000))
	#define PROGRAM_BASE_SIZE_NORMAL_HINT /*-----------------*/ (b(0100000000))
	#define PROGRAM_WINDOW_GRAVITY_NORMAL_HINT /*------------*/ (b(1000000000))

	#define NONE_HINT /*-------------------------------------*/ (b(000000000))
	#define INPUT_HINT /*------------------------------------*/ (b(000000001))
	#define STATE_HINT /*------------------------------------*/ (b(000000010))
	#define ICON_PIXMAP_HINT /*------------------------------*/ (b(000000100))
	#define ICON_WINDOW_HINT /*------------------------------*/ (b(000001000))
	#define ICON_POSITION_HINT /*----------------------------*/ (b(000010000))
	#define ICON_MASK_HINT /*--------------------------------*/ (b(000100000))
	#define WINDOW_GROUP_HINT /*-----------------------------*/ (b(001000000))
	#define URGENCY_HINT /*----------------------------------*/ (b(100000000))

	#define _STRING_TREE_NODE_CHILDREN_AMOUNT /*-------------*/ (14)
	#define STRING_TREE_NODE_CHILDREN_AMOUNT /*--------------*/ (_STRING_TREE_NODE_CHILDREN_AMOUNT > 28? 28 : _STRING_TREE_NODE_CHILDREN_AMOUNT)

	#define EMPTY_SHARED_STATUS /*---------------------------*/ (0)
	#define FULL_SHARED_STATUS /*----------------------------*/ (1)

	#define SHORTCUT_CODE_AMOUNT /*--------------------------*/ (256)

	#define SHORTCUT_STATE_CONTENT(k, v, n, p) /*------------*/ { \
		  v(none)    k(NONE##p    = (b(000))) \
		, v(press)   k(PRESS##p   = (b(001))) \
		, v(repeat)  k(REPEAT##p  = (b(010))) \
		, v(release) k(RELEASE##p = (b(100))) \
		, n(NULL)    k(NULL##p) \
	}

	#define NONE_INSTRUCTION_TYPE /*-------------------------*/ (b(000000))
	#define NAME_INSTRUCTION_TYPE /*-------------------------*/ (b(000001))
	#define NAME_LIST_INSTRUCTION_TYPE /*--------------------*/ (b(000010))
	#define NUMBER_INSTRUCTION_TYPE /*-----------------------*/ (b(000100))
	#define STRING_INSTRUCTION_TYPE /*-----------------------*/ (b(001000))
	#define IMAGE_INSTRUCTION_TYPE /*------------------------*/ (b(010000))
	#define END_INSTRUCTION_TYPE /*--------------------------*/ (b(100000))

	#define GLOBAL_SCOPES_INSTRUCTION_CONTENT(k, v, n, p) /*-*/ { \
		  v(scope1) k(SCOPE1##p) \
		, n(NULL)   k(NULL##p) \
	}

	#define GLOBAL_INSTRUCTION_CONTENT(k, v, n, p) /*--------*/ { \
		  v(help)           k(HELP##p) \
		, v(expand)         k(EXPAND##p) \
		, v(contract)       k(CONTRACT##p) \
		, v(read-config)    k(READ_CONFIG##p) \
		, v(use-terminal)   k(USE_TERMINAL##p) \
		, v(use-messenger)  k(USE_MESSENGER##p) \
		, v(set)            k(SET##p) \
		, v(do)             k(DO##p) \
		, v(grab-keycode)   k(GRAB_KEYCODE##p) \
		, v(grab-button)    k(GRAB_BUTTON##p) \
		, v(ungrab-keycode) k(UNGRAB_KEYCODE##p) \
		, v(ungrab-button)  k(UNGRAB_BUTTON##p) \
		, v(stop)           k(STOP##p) \
		, n(NULL)           k(NULL##p) \
	}

	#define SCOPE1_SCOPE_INSTRUCTION_CONTENT(k, v, n, p) /*--*/ { \
		  v(help)     k(HELP##p) \
		, v(expand)   k(EXPAND##p) \
		, v(contract) k(CONTRACT##p) \
		, v(stop)     k(STOP##p) \
		, n(NULL)     k(NULL##p) \
	}

	#define BOOLEAN_CONTENT(k, v, n, p) /*-------------------*/ { \
		  v(none)  k(NONE##p) \
		, v(true)  k(TRUE##p) \
		, v(false) k(FALSE##p) \
		, n(NULL)  k(NULL##p) \
	}

	#define VARIABLE_CONTENT(k, v, n, p) /*------------------*/ { \
		  v(none) k(NONE##p) \
		, n(NULL) k(NULL##p) \
	}

	#define COMMAND_CONTENT(k, v, n, p) /*-------------------*/ { \
		  v(none)                                 k(NONE##p) \
		, v(execute)                              k(EXECUTE##p) \
		, v(focus)                                k(FOCUS##p) \
		, v(motion-move)                          k(MOTION_MOVE##p) \
		, v(motion-resize)                        k(MOTION_RESIZE##p) \
		, v(place-top)                            k(PLACE_TOP##p) \
		, v(place-bottom)                         k(PLACE_BOTTOM##p) \
		, v(place-left)                           k(PLACE_LEFT##p) \
		, v(place-right)                          k(PLACE_RIGHT##p) \
		, v(place-top-left)                       k(PLACE_TOP_LEFT##p) \
		, v(place-top-right)                      k(PLACE_TOP_RIGHT##p) \
		, v(place-bottom-left)                    k(PLACE_BOTTOM_LEFT##p) \
		, v(place-bottom-right)                   k(PLACE_BOTTOM_RIGHT##p) \
		, v(place-center)                         k(PLACE_CENTER##p) \
		, v(place-full)                           k(PLACE_FULL##p) \
		, v(move)                                 k(MOVE##p) \
		, v(resize)                               k(RESIZE##p) \
		, v(enter-maximized)                      k(ENTER_MAXIMIZED##p) \
		, v(leave-maximized)                      k(LEAVE_MAXIMIZED##p) \
		, v(toggle-maximized)                     k(TOGGLE_MAXIMIZED##p) \
		, v(enter-fullscreen)                     k(ENTER_FULLSCREEN##p) \
		, v(leave-fullscreen)                     k(LEAVE_FULLSCREEN##p) \
		, v(toggle-fullscreen)                    k(TOGGLE_FULLSCREEN##p) \
		, v(minimize-all)                         k(MINIMIZE_ALL##p) \
		, v(unminimize-all)                       k(UNMINIMIZE_ALL##p) \
		, v(show-desktop)                         k(SHOW_DESKTOP##p) \
		, v(hide-desktop)                         k(HIDE_DESKTOP##p) \
		, v(toggle-desktop)                       k(TOGGLE_DESKTOP##p) \
		, v(go-to-workspace)                      k(GO_TO_WORKSPACE##p) \
		, v(go-to-next-workspace)                 k(GO_TO_NEXT_WORKSPACE##p) \
		, v(go-to-previous-workspace)             k(GO_TO_PREVIOUS_WORKSPACE##p) \
		, v(move-window-to-workspace)             k(MOVE_WINDOW_TO_WORKSPACE##p) \
		, v(move-window-to-next-workspace)        k(MOVE_WINDOW_TO_NEXT_WORKSPACE##p) \
		, v(move-window-to-previous-workspace)    k(MOVE_WINDOW_TO_PREVIOUS_WORKSPACE##p) \
		, v(go-to-workspace-with-window)          k(GO_TO_WORKSPACE_WITH_WINDOW##p) \
		, v(go-to-next-workspace-with-window)     k(GO_TO_NEXT_WORKSPACE_WITH_WINDOW##p) \
		, v(go-to-previous-workspace-with-window) k(GO_TO_PREVIOUS_WORKSPACE_WITH_WINDOW##p) \
		, v(close)                                k(CLOSE##p) \
		, v(kill)                                 k(KILL##p) \
		, v(restart)                              k(RESTART##p) \
		, v(exit)                                 k(EXIT##p) \
		, n(NULL)                                 k(NULL##p) \
	}

	#define MODIFIER_CONTENT(k, v, n, p) /*------------------*/ { \
		  v(none)     k(NONE##p) \
		, v(shift)    k(SHIFT##p) \
		, v(caps)     k(CAPS##p) \
		, v(control)  k(CONTROL##p) \
		, v(mod-1)    k(MOD_1##p) \
		, v(mod-2)    k(MOD_2##p) \
		, v(mod-3)    k(MOD_3##p) \
		, v(mod-4)    k(MOD_4##p) \
		, v(mod-5)    k(MOD_5##p) \
		, v(button-1) k(BUTTON_1##p) \
		, v(button-2) k(BUTTON_2##p) \
		, v(button-3) k(BUTTON_3##p) \
		, v(button-4) k(BUTTON_4##p) \
		, v(button-5) k(BUTTON_5##p) \
		, n(NULL)     k(NULL##p) \
	}

	#define NONE_NAME_LIST /*--------------------------------*/ (0)
	#define SUCCESS_NAME_LIST /*-----------------------------*/ (1)
	#define INVALID_NAME_NAME_LIST /*------------------------*/ (2)
	#define PREMATURE_END_NAME_LIST /*-----------------------*/ (3)

	#define MACRO_CONTENT(k, v, n, p) /*---------------------*/ { \
		  v(button-1) k(BUTTON_1##p) \
		, v(button-2) k(BUTTON_2##p) \
		, v(button-3) k(BUTTON_3##p) \
		, v(button-4) k(BUTTON_4##p) \
		, v(button-5) k(BUTTON_5##p) \
		, n(NULL)     k(NULL##p) \
	}

	#define NONE_NUMBER /*-----------------------------------*/ (0)
	#define VALID_NUMBER_NUMBER /*---------------------------*/ (1)
	#define NON_NUMBER_NUMBER /*-----------------------------*/ (2)
	#define OVERFLOWN_NUMBER_NUMBER /*-----------------------*/ (3)
	#define DIVIDED_BY_ZERO_NUMBER /*------------------------*/ (4)

	#define NONE_MATCH_IMAGE /*------------------------------*/ (0)
	#define CANNOT_OPEN_MATCH_IMAGE /*-----------------------*/ (1)
	#define CANNOT_READ_MATCH_IMAGE /*-----------------------*/ (2)
	#define UNSUPPORTED_FORMAT_MATCH_IMAGE /*----------------*/ (3)
	#define BAD_HEADER_MATCH_IMAGE /*------------------------*/ (4)
	#define BAD_DEPTH_MATCH_IMAGE /*-------------------------*/ (5)
	#define BAD_COMPRESSION_MATCH_IMAGE /*-------------------*/ (6)
	#define UNSUPPORTED_HEIGHT_MATCH_IMAGE /*----------------*/ (7)
	#define BAD_SIZE_MATCH_IMAGE /*--------------------------*/ (8)
	#define FAILED_MATCH_IMAGE /*----------------------------*/ (9)
	#define BAD_PIXELS_MATCH_IMAGE /*------------------------*/ (10)
	#define BAD_IMAGE_MATCH_IMAGE /*-------------------------*/ (11)
	#define SUCCESS_MATCH_IMAGE /*---------------------------*/ (12)

	#define NONE_MATCH_COMMAND_ORIGIN /*---------------------*/ (0)
	#define PRESS_MATCH_COMMAND_ORIGIN /*--------------------*/ (1)
	#define RELEASE_MATCH_COMMAND_ORIGIN /*------------------*/ (2)
	#define CONFIG_MATCH_COMMAND_ORIGIN /*-------------------*/ (3)
	#define STDIN_MATCH_COMMAND_ORIGIN /*--------------------*/ (4)
	#define TRANSMITTER_MATCH_COMMAND_ORIGIN /*--------------*/ (5)

	#define NONE_MATCH_COMMAND_TYPE /*-----------------------*/ (0)
	#define TYPICAL_MATCH_COMMAND_TYPE /*--------------------*/ (1)
	#define RESTART_MATCH_COMMAND_TYPE /*--------------------*/ (2)
	#define EXIT_MATCH_COMMAND_TYPE /*-----------------------*/ (3)

	#define ROTATION_CONTENT(k, v, n, p) /*------------------*/ { \
		  v(none)        k(NONE##p) \
		, v(degrees-90)  k(DEGREES_90##p)  \
		, v(degrees-180) k(DEGREES_180##p) \
		, v(degrees-270) k(DEGREES_270##p) \
		, n(NULL)        k(NULL##p) \
	}

	#define NONE_GRAB_DEVICE /*------------------------------*/ (0)
	#define KEYBOARD_GRAB_DEVICE /*--------------------------*/ (1)
	#define POINTER_GRAB_DEVICE /*---------------------------*/ (2)

	#define QUIT() /*----------------------------------------*/ local void               quit(int signal)
	#define REAPSPAWNEDPROCESSES() /*------------------------*/ local void               reapSpawnedProcesses(const int signal)

	#define INITMEMORYSYSTEM() /*----------------------------*/ local bool               initMemorySystem(void)
	#define PUSHPOINTER() /*---------------------------------*/ local uint32            _pushPointer(const char *const file, const int line, void *const pointer, const char *const label, int (*const freeFunction)(void *))
	#define POPPOINTER() /*----------------------------------*/ local bool               popPointer(const uint32 token)
	#define UPDATEPOINTER() /*-------------------------------*/ local bool               updatePointer(const uint32 token, void *const pointer)
	#define IFREE() /*---------------------------------------*/ local int                iFree(void *const pointer)
	#define IXCBDISCONNECT() /*------------------------------*/ local int                iXCBDisconnect(void *const pointer)
	#define ISHMCTL() /*-------------------------------------*/ local int                ishmctl(void *const pointer)
	#define FINIMEMORYSYSTEM() /*----------------------------*/ local bool               finiMemorySystem(void)

	#define INITPERMISSIONSYSTEM() /*------------------------*/ local bool               initPermissionSystem(PermissionSystem *const permissionSystem)
	#define SETPERMISSIONS() /*------------------------------*/ local bool               setPermissions(PermissionSystem *const permissionSystem)
	#define LOWERPERMISSIONS() /*----------------------------*/ local bool               lowerPermissions(PermissionSystem *const permissionSystem)
	#define RAISEPERMISSIONS() /*----------------------------*/ local bool               raisePermissions(PermissionSystem *const permissionSystem)
	#define DROPPERMISSIONS() /*-----------------------------*/ local bool               dropPermissions(PermissionSystem *const permissionSystem)
	#define FINIPERMISSIONSYSTEM() /*------------------------*/ local bool               finiPermissionSystem(PermissionSystem *const permissionSystem)

	#define IDENTIFYARGUMENT() /*----------------------------*/ local uint8              identifyArgument(const char *p)
	#define INSENSITIVESTRINGCOMPARE() /*--------------------*/ local bool               insensitiveStringCompare(const char *s0, const char *s1)
	#define SENSITIVESTRINGCOMPARE() /*----------------------*/ local bool               sensitiveStringCompare(const char *s0, const char *s1)

	#define RANDRQUERYVERSIONUNCHECKED() /*------------------*/ local xcb_void_cookie_t  randrQueryVersionUnchecked(xcb_connection_t *const connection, const uint32 majorVersion, const uint32 minorVersion)
	#define SHAPEQUERYVERSIONUNCHECKED() /*------------------*/ local xcb_void_cookie_t  shapeQueryVersionUnchecked(xcb_connection_t *const connection, const uint32 majorVersion, const uint32 minorVersion)
	#define XFIXESQUERYVERSIONUNCHECKED() /*-----------------*/ local xcb_void_cookie_t  xfixesQueryVersionUnchecked(xcb_connection_t *const connection, const uint32 majorVersion, const uint32 minorVersion)

	#define INITMONITORSYSTEM() /*---------------------------*/ local bool               initMonitorSystem(MonitorSystem *const monitorSystem)
	#define CREATEMONITORS() /*------------------------------*/ local bool               createMonitors(MonitorSystem *const monitorSystem)
	#define GETWHICHMONITOR() /*-----------------------------*/ local Monitor *          getWhichMonitor(MonitorSystem *const monitorSystem, const uint8 whichMonitor)
	#define DESTROYMONITORS() /*-----------------------------*/ local bool               destroyMonitors(MonitorSystem *const monitorSystem)
	#define FINDPOINTERMONITOR() /*--------------------------*/ local Monitor *          findPointerMonitor(MonitorSystem *const monitorSystem)
	#define FINDRECTANGLEMONITOR() /*------------------------*/ local Monitor *          findRectangleMonitor(MonitorSystem *const monitorSystem, const int x, const int y, const int width, const int height)
	#define FINDWINDOWMONITOR() /*---------------------------*/ local Monitor *          findWindowMonitor(MonitorSystem *const monitorSystem, const xcb_window_t window)
	#define FINIMONITORSYSTEM() /*---------------------------*/ local bool               finiMonitorSystem(MonitorSystem *const monitorSystem)

	#define INITPOINTERSYSTEM() /*---------------------------*/ local bool               initPointerSystem(PointerSystem *const pointerSystem)
	#define SETPOINTER() /*----------------------------------*/ local bool               setPointer(PointerSystem *const pointerSystem)
	#define FINIPOINTERSYSTEM() /*---------------------------*/ local bool               finiPointerSystem(PointerSystem *const pointerSystem)

	#define INITCURSORSYSTEM() /*----------------------------*/ local bool               initCursorSystem(CursorSystem *const cursorSystem)
	#define SETCURSOR() /*-----------------------------------*/ local bool               setCursor(CursorSystem *const cursorSystem, const uint8 cursorGlyph, const uint32 foreground, const uint32 background)
	#define FINICURSORSYSTEM() /*----------------------------*/ local bool               finiCursorSystem(CursorSystem *const cursorSystem)

	#define INITWALLPAPERSYSTEM() /*-------------------------*/ local bool               initWallpaperSystem(WallpaperSystem *const wallpaperSystem)
	#define SETWALLPAPERCOLOR() /*---------------------------*/ local bool               setWallpaperColor(WallpaperSystem *const wallpaperSystem, MonitorSystem *const monitorSystem, const uint32 color)
	#define SETWALLPAPERPIXMAP() /*--------------------------*/ local bool               setWallpaperPixmap(WallpaperSystem *const wallpaperSystem, MonitorSystem *const monitorSystem, const xcb_atom_t pixmapProperty)
	#define CREATEWALLPAPER() /*-----------------------------*/ local bool               createWallpaper(WallpaperSystem *const wallpaperSystem, MonitorSystem *const monitorSystem, const uint width, const uint height)
	#define FINIWALLPAPERSYSTEM() /*-------------------------*/ local bool               finiWallpaperSystem(WallpaperSystem *const wallpaperSystem)

	#define INITCLIENTSYSTEM() /*----------------------------*/ local bool               initClientSystem(ClientSystem *const clientSystem)
	#define CREATECLIENT() /*--------------------------------*/ local bool               createClient(ClientSystem *const clientSystem, const CursorSystem *const cursorSystem, const xcb_window_t window, const int x, const int y, const uint width, const uint height, const uint border, uint8 class, const bool overrideRedirect)
	#define SETDEFAULTCLIENTWINDOWTYPE() /*------------------*/ local bool               setDefaultClientWindowType(ClientSystem *const clientSystem, Client *const client)
	#define UPDATECLIENTSTATE() /*---------------------------*/ local bool               updateClientState(ClientSystem *const clientSystem, Client *const client, const uint8 action, uint16 state)
	#define CHANGECLIENTSTATE() /*---------------------------*/ local bool               changeClientState(ClientSystem *const clientSystem, Client *const client)
	#define SETCLIENTALLOWEDACTIONS() /*---------------------*/ local bool               setClientAllowedActions(ClientSystem *const clientSystem, Client *const client)
	#define CHANGECLIENTALLOWEDACTIONS() /*------------------*/ local bool               changeClientAllowedActions(ClientSystem *const clientSystem, Client *const client)
	#define SETCLIENTORDERTYPE() /*--------------------------*/ local bool               setClientOrderType(ClientSystem *const clientSystem, Client *const client)
	#define MOVERESIZECLIENT() /*----------------------------*/ local bool               moveResizeClient(ClientSystem *const clientSystem, Client *const client, int x, int y, int width, int height, const bool force, const bool treatAsNormal, const bool useMinimumHints, const bool useMaximumHints, const bool repositionAfterwards, const uint8 windowGravity)
	#define SENDCLIENTCONFIGUREEVENT() /*--------------------*/ local bool               sendClientConfigureEvent(ClientSystem *const clientSystem, Client *const client)
	#define RESTACKCLIENT() /*-------------------------------*/ local bool               restackClient(ClientSystem *const clientSystem, Client *const client, const uint8 stackMode, const xcb_window_t sibling)
	#define CONFIGURECLIENT() /*-----------------------------*/ local bool               configureClient(ClientSystem *const clientSystem, Client *const client)
	#define ASSIGNCLIENTSTRUT() /*---------------------------*/ local bool               assignClientStrut(ClientSystem *const clientSystem, MonitorSystem *const monitorSystem, Client *const client)
	#define GETFOCUSEDCLIENT() /*----------------------------*/ local Client *           getFocusedClient(ClientSystem *const clientSystem)
	#define SETFOCUSEDCLIENT() /*----------------------------*/ local bool               setFocusedClient(ClientSystem *const clientSystem, Client *const client, const uint currentDesktop)
	#define OFFERCLIENTFOCUS() /*----------------------------*/ local bool               offerClientFocus(ClientSystem *const clientSystem, Client *const client)
	#define FOCUSCLIENT() /*---------------------------------*/ local bool               focusClient(ClientSystem *const clientSystem, Client *const client)
	#define CHANGEACTIVEWINDOW() /*--------------------------*/ local bool               changeActiveWindow(ClientSystem *const clientSystem)
	#define SETMOTIONCLIENT() /*-----------------------------*/ local bool               setMotionClient(ClientSystem *const clientSystem, Client *const client, const uint8 motionAction, const uint8 motionGravity, const int x, const int y)
	#define UNSETMOTIONCLIENT() /*---------------------------*/ local bool               unsetMotionClient(ClientSystem *const clientSystem)
	#define CLOSECLIENT() /*---------------------------------*/ local bool               closeClient(ClientSystem *const clientSystem, Client *const client, const uint8 command)
	#define LOSEFOCUS() /*-----------------------------------*/ local bool               loseFocus(ClientSystem *const clientSystem)
	#define UNFOCUSCLIENT() /*-------------------------------*/ local bool               unfocusClient(ClientSystem *const clientSystem)
	#define UNMAPCLIENT() /*---------------------------------*/ local bool               unmapClient(ClientSystem *const clientSystem, Client *const client, const uint8 state)
	#define DESTROYCLIENT() /*-------------------------------*/ local bool               destroyClient(ClientSystem *const clientSystem, Client *const client)
	#define ISVALIDCLIENT() /*-------------------------------*/ local bool               isValidClient(ClientSystem *const clientSystem, const Client *const client)
	#define FINDCLIENTWINDOW() /*----------------------------*/ local Client *           findClientWindow(ClientSystem *const clientSystem, const xcb_window_t window)
	#define FINDCLIENTCONTAINER() /*-------------------------*/ local Client *           findClientContainer(ClientSystem *const clientSystem, const xcb_window_t window)
	#define FINDCONFIGUREDCLIENTWINDOW() /*------------------*/ local Client *           findConfiguredClientWindow(ClientSystem *const clientSystem, const xcb_window_t window)
	#define FINDORDEREDCLIENTOFFSET() /*---------------------*/ local uint *             findOrderedClientOffset(ClientSystem *const clientSystem, const Client *const client)
	#define FINDBELOWCLIENT() /*-----------------------------*/ local Client *           findBelowClient(ClientSystem *const clientSystem, const Client *const client)
	#define FINDABOVEDESKTOPCLIENT() /*----------------------*/ local Client *           findAboveDesktopClient(ClientSystem *const clientSystem, const Client *const client)
	#define FINDBELOWDESKTOPCLIENT() /*----------------------*/ local Client *           findBelowDesktopClient(ClientSystem *const clientSystem, const Client *const client)
	#define FINDMODALTRANSIENTFORCLIENT() /*-----------------*/ local Client *           findModalTransientForClient(ClientSystem *const clientSystem, const Client *const client)
	#define FINDBELOWMANAGEDCLIENT() /*----------------------*/ local Client *           findBelowManagedClient(ClientSystem *const clientSystem, const Client *const client)
	#define FINICLIENTSYSTEM() /*----------------------------*/ local bool               finiClientSystem(ClientSystem *const clientSystem)

	#define INITVIRTUALROOTSYSTEM() /*-----------------------*/ local bool               initVirtualRootSystem(VirtualRootSystem *const virtualRootSystem)
	#define SETVIRTUALROOTAMOUNT() /*------------------------*/ local bool               setVirtualRootAmount(VirtualRootSystem *const virtualRootSystem, MonitorSystem *const monitorSystem, ClientSystem *const clientSystem, CursorSystem *const cursorSystem, const uint size)
	#define SETVIRTUALROOTWORKAREA() /*----------------------*/ local bool               setVirtualRootWorkarea(VirtualRootSystem *const virtualRootSystem, MonitorSystem *const monitorSystem)
	#define CHANGEVIRTUALROOTWORKAREA() /*-------------------*/ local bool               changeVirtualRootWorkarea(VirtualRootSystem *const virtualRootSystem)
	#define SETVIRTUALROOTNAMES() /*-------------------------*/ local bool               setVirtualRootNames(VirtualRootSystem *const virtualRootSystem)
	#define SETVIRTUALROOTNAME() /*--------------------------*/ local bool               setVirtualRootName(VirtualRootSystem *const virtualRootSystem, const uint32 which, const uint8 *const name, const uint length)
	#define SETVIRTUALROOTNUMBERNAME() /*--------------------*/ local bool               setVirtualRootNumberName(VirtualRootSystem *const virtualRootSystem, const uint32 which, uint number)
	#define GOTOVIRTUALROOT() /*-----------------------------*/ local bool               gotoVirtualRoot(VirtualRootSystem *const virtualRootSystem, ClientSystem *const clientSystem, const uint32 which, const bool loseClientFocus)
	#define CONFIGUREFULLSCREENVIRTUALROOTCLIENTS() /*-------*/ local bool               configureFullscreenVirtualRootClients(VirtualRootSystem *const virtualRootSystem, ClientSystem *const clientSystem, const uint32 which)
	#define RESIZEVIRTUALROOT() /*---------------------------*/ local bool               resizeVirtualRoot(VirtualRootSystem *const virtualRootSystem, MonitorSystem *const monitorSystem, WallpaperSystem *const wallpaperSystem, ClientSystem *const clientSystem, const uint width, const uint height)
	#define SETVIRTUALROOTGLOBALEDGEOFFSET() /*--------------*/ local bool               setVirtualRootGlobalEdgeOffset(VirtualRootSystem *const virtualRootSystem, MonitorSystem *const monitorSystem)
	#define SETVIRTUALROOTWALLPAPER() /*---------------------*/ local bool               setVirtualRootWallpaper(VirtualRootSystem *const virtualRootSystem, WallpaperSystem *const wallpaperSystem)
	#define RESTACKVIRTUALROOTBELOW() /*---------------------*/ local bool               restackVirtualRootBelow(VirtualRootSystem *const virtualRootSystem)
	#define MAPVIRTUALROOTS() /*-----------------------------*/ local bool               mapVirtualRoots(VirtualRootSystem *const virtualRootSystem)
	#define SETCLIENTVIRTUALROOT() /*------------------------*/ local bool               setClientVirtualRoot(VirtualRootSystem *const virtualRootSystem, ClientSystem *const clientSystem, Client *const client, const uint32 which)
	#define CHANGEVIRTUALROOTCLIENTDESKTOP() /*--------------*/ local bool               changeVirtualRootClientDesktop(VirtualRootSystem *const virtualRootSystem, ClientSystem *const clientSystem, Client *const client)
	#define MOVECLIENTTOVIRTUALROOT() /*---------------------*/ local bool               moveClientToVirtualRoot(VirtualRootSystem *const virtualRootSystem, MonitorSystem *const monitorSystem, ClientSystem *const clientSystem, Client *const client, const uint32 which, const bool loseClientFocus)
	#define CONFIGUREVIRTUALROOTCLIENT() /*------------------*/ local bool               configureVirtualRootClient(VirtualRootSystem *const virtualRootSystem, ClientSystem *const clientSystem, Client *const client)
	#define RESTACKVIRTUALROOTCLIENT() /*--------------------*/ local bool               restackVirtualRootClient(VirtualRootSystem *const virtualRootSystem, ClientSystem *const clientSystem, Client *const client, const uint8 stackMode, const xcb_window_t sibling)
	#define ADDVIRTUALROOTCLIENTWORKAREA() /*----------------*/ local bool               addVirtualRootClientWorkarea(VirtualRootSystem *const virtualRootSystem, MonitorSystem *const monitorSystem, ClientSystem *const clientSystem, Client *const client)
	#define UPDATEVIRTUALROOTSTRUTEDCLIENTS() /*-------------*/ local bool               updateVirtualRootStrutedClients(VirtualRootSystem *const virtualRootSystem, MonitorSystem *const monitorSystem, ClientSystem *const clientSystem, Client *const client, const uint8 action)
	#define REMOVEVIRTUALROOTCLIENTWORKAREA() /*-------------*/ local bool               removeVirtualRootClientWorkarea(VirtualRootSystem *const virtualRootSystem, MonitorSystem *const monitorSystem, ClientSystem *const clientSystem, Client *const client)
	#define MAXIMIZECLIENT() /*------------------------------*/ local bool               maximizeClient(VirtualRootSystem *const virtualRootSystem, MonitorSystem *const monitorSystem, ClientSystem *const clientSystem, Client *const client, const uint8 whichMonitor)
	#define UNMAXIMIZECLIENT() /*----------------------------*/ local bool               unmaximizeClient(VirtualRootSystem *const virtualRootSystem, MonitorSystem *const monitorSystem, ClientSystem *const clientSystem, Client *const client)
	#define FULLSCREENCLIENT() /*----------------------------*/ local bool               fullscreenClient(VirtualRootSystem *const virtualRootSystem, MonitorSystem *const monitorSystem, ClientSystem *const clientSystem, Client *const client, const uint8 whichMonitor)
	#define UNFULLSCREENCLIENT() /*--------------------------*/ local bool               unfullscreenClient(VirtualRootSystem *const virtualRootSystem, MonitorSystem *const monitorSystem, ClientSystem *const clientSystem, Client *const client)
	#define MOVERESIZEWORKAREACLIENT() /*--------------------*/ local bool               moveResizeWorkareaClient(VirtualRootSystem *const virtualRootSystem, MonitorSystem *const monitorSystem, ClientSystem *const clientSystem, Client *const client, const uint8 whichMonitor, const uint8 workareaPosition)
	#define UPDATEVIRTUALROOTWORKAREACLIENT() /*-------------*/ local bool               updateVirtualRootWorkareaClient(VirtualRootSystem *const virtualRootSystem, MonitorSystem *const monitorSystem, ClientSystem *const clientSystem, Client *const client)
	#define UPDATEVIRTUALROOTWORKAREACLIENTS() /*------------*/ local bool               updateVirtualRootWorkareaClients(VirtualRootSystem *const virtualRootSystem, MonitorSystem *const monitorSystem, ClientSystem *const clientSystem)
	#define SHOWVIRTUALROOTDESKTOP() /*----------------------*/ local bool               showVirtualRootDesktop(VirtualRootSystem *const virtualRootSystem, ClientSystem *const clientSystem, const uint32 which, const bool showDesktop)
	#define DESTROYVIRTUALROOT() /*--------------------------*/ local bool               destroyVirtualRoot(VirtualRootSystem *const virtualRootSystem, VirtualRoot *const virtualRoot)
	#define ISVALIDVIRTUALROOT() /*--------------------------*/ local bool               isValidVirtualRoot(VirtualRootSystem *const virtualRootSystem, const VirtualRoot *const virtualRoot)
	#define FINDVIRTUALROOT() /*-----------------------------*/ local VirtualRoot *      findVirtualRoot(VirtualRootSystem *const virtualRootSystem, const xcb_window_t window)
	#define FINDORDEREDVIRTUALROOTCLIENTOFFSET() /*----------*/ local uint *             findOrderedVirtualRootClientOffset(VirtualRootSystem *const virtualRootSystem, VirtualRoot *const virtualRoot, ClientSystem *const clientSystem, const xcb_window_t window)
	#define FINDPOSITIONEDORDEREDVIRTUALROOTCLIENT() /*------*/ local Client *           findPositionedOrderedVirtualRootClient(VirtualRootSystem *const virtualRootSystem, ClientSystem *const clientSystem, const uint32 which, const int x, const int y)
	#define FINIVIRTUALROOTSYSTEM() /*-----------------------*/ local bool               finiVirtualRootSystem(VirtualRootSystem *const virtualRootSystem)

	#define INITCLIENTLISTSYSTEM() /*------------------------*/ local bool               initClientListSystem(ClientListSystem *const clientListSystem)
	#define SETCLIENTLISTPROPERTY() /*-----------------------*/ local bool               setClientListProperty(ClientListSystem *const clientListSystem, const xcb_atom_t property)
	#define ADDCLIENTLISTWINDOW() /*-------------------------*/ local bool               addClientListWindow(ClientListSystem *const clientListSystem, const xcb_window_t window)
	#define CONFIGURECLIENTLISTCLIENT() /*-------------------*/ local bool               configureClientListClient(ClientListSystem *const clientListSystem, ClientSystem *const clientSystem, Client *const client)
	#define RESTACKCLIENTLISTWINDOW() /*---------------------*/ local bool               restackClientListWindow(ClientListSystem *const clientListSystem, const xcb_window_t window, const uint8 stackMode, const xcb_window_t sibling)
	#define CHANGECLIENTLISTPROPERTY() /*--------------------*/ local bool               changeClientListProperty(ClientListSystem *const clientListSystem)
	#define REMOVECLIENTLISTWINDOW() /*----------------------*/ local bool               removeClientListWindow(ClientListSystem *const clientListSystem, const xcb_window_t window)
	#define FINDCLIENTLISTWINDOW() /*------------------------*/ local xcb_window_t *     findClientListWindow(ClientListSystem *const clientListSystem, const xcb_window_t window)
	#define FINICLIENTLISTSYSTEM() /*------------------------*/ local bool               finiClientListSystem(ClientListSystem *const clientListSystem)

	#define INITWINDOWMANAGERSYSTEM() /*---------------------*/ local bool               initWindowManagerSystem(void)
	#define SETNETSUPPORTED() /*-----------------------------*/ local bool               setNetSupported(void)
	#define STORECLIENTPROPERTIES() /*-----------------------*/ local bool               storeClientProperties(Client *const client)
	#define STORECLIENTPROPERTY() /*-------------------------*/ local bool               storeClientProperty(Client *const client, const xcb_atom_t property, uint length, const void *value)
	#define REALLOCATEPROPERTY() /*--------------------------*/ local bool               reallocateProperty(const uint itemSize, const uint length, const void *const value, const char *const label, uint *const sizeReturn, uint8 **const startReturn, uint32 *const tokenReturn)
	#define UNSTORECLIENTPROPERTY() /*-----------------------*/ local bool               unstoreClientProperty(Client *const client, const xcb_atom_t property)
	#define FINDOWNEDWINDOW() /*-----------------------------*/ local bool               findOwnedWindow(const xcb_window_t window)
	#define FINIWINDOWMANAGERSYSTEM() /*---------------------*/ local bool               finiWindowManagerSystem(void)

	#define SETELEMENTPREFERENCES() /*-----------------------*/ local bool               setElementPreferences(ElementPreferences *const elementPreferences)

	#define INITWINDOWSYSTEM() /*----------------------------*/ local bool               initWindowSystem(WindowSystem *const windowSystem)
	#define CREATEWINDOWCIRCLEPIXMAP() /*--------------------*/ local bool               createWindowCirclePixmap(WindowSystem *const windowSystem, const uint radius, const uint32 foreground, const uint32 background)
	#define CREATEWINDOWS() /*-------------------------------*/ local bool               createWindows(WindowSystem *const windowSystem, const uint amount, const bool overrideRedirect, const uint32 eventMask)
	#define MAPWINDOWS() /*----------------------------------*/ local bool               mapWindows(WindowSystem *const windowSystem, MonitorSystem *const monitorSystem, const ElementPreferences *const windowPreferences, const uint8 whichMonitor)
	#define CONFIGUREWINDOWS() /*----------------------------*/ local bool               configureWindows(WindowSystem *const windowSystem, MonitorSystem *const monitorSystem, const ElementPreferences *const windowPreferences, const uint8 whichMonitor)
	#define DRAWWINDOWS() /*---------------------------------*/ local bool               drawWindows(WindowSystem *const windowSystem, MonitorSystem *const monitorSystem, const ElementPreferences *const windowPreferences)
	#define SETWINDOWPROPERTIES() /*-------------------------*/ local bool               setWindowProperties(WindowInfo *const windowInfo, const ElementPreferences *const windowPreferences, const int x, const int y, const uint width, const uint height)
	#define DRAWWINDOW() /*----------------------------------*/ local bool               drawWindow(WindowSystem *const windowSystem, const WindowInfo *const windowInfo, const ElementPreferences *const windowPreferences, Monitor *const monitor, ElementRectangle *windowRectangle)
	#define UNMAPWINDOWS() /*--------------------------------*/ local bool               unmapWindows(WindowSystem *const windowSystem)
	#define DESTROYWINDOWS() /*------------------------------*/ local bool               destroyWindows(WindowSystem *const windowSystem)
	#define GETRECTANGLE() /*--------------------------------*/ local bool               getRectangle(Monitor *const _monitor, const ElementRectangle *const parentRectangle, const ElementPreferences *const preferences, ElementRectangle *const rectangle)
	#define GETTYPEDNUMBER() /*------------------------------*/ local int                getTypedNumber(const int number, const uint8 type, const uint8 axis, const int size, Monitor *const monitor)
	#define FINDWINDOW() /*----------------------------------*/ local bool               findWindow(WindowSystem *const windowSystem, const xcb_window_t window)
	#define FINIWINDOWSYSTEM() /*----------------------------*/ local bool               finiWindowSystem(WindowSystem *const windowSystem)

	#define INITSLEEPTHREADSYSTEM() /*-----------------------*/ local bool               initSleepThreadSystem(SleepThreadSystem *const sleepThreadSystem)
	#define SETSLEEPTHREADOPERATION() /*---------------------*/ local bool               setSleepThreadOperation(SleepThreadSystem *const sleepThreadSystem, bool (*const risingOperation)(void *const arg), void *const risingOperationArgument, bool (*const fallingOperation)(void *const arg), void *const fallingOperationArgument, const bool loopOperation, const bool restartTimer)
	#define SETSLEEPTHREADSLEEPTIME() /*---------------------*/ local bool               setSleepThreadSleepTime(SleepThreadSystem *const sleepThreadSystem, const uint milliseconds)
	#define BOOTSLEEPTHREAD() /*-----------------------------*/ local bool               bootSleepThread(SleepThreadSystem *const sleepThreadSystem)
	#define SIGNALSLEEPTHREAD() /*---------------------------*/ local bool               signalSleepThread(SleepThreadSystem *const sleepThreadSystem)
	#define SLEEPTHREADMAIN() /*-----------------------------*/ local void *             sleepThreadMain(void *const arg)
	#define QUITSLEEPTHREAD() /*-----------------------------*/ local bool               quitSleepThread(SleepThreadSystem *const sleepThreadSystem)
	#define FINISLEEPTHREADSYSTEM() /*-----------------------*/ local bool               finiSleepThreadSystem(SleepThreadSystem *const sleepThreadSystem)

	#define INITSTRINGTREESYSTEM() /*------------------------*/ local bool               initStringTreeSystem(StringTreeSystem *const stringTreeSystem)
	#define BULKINSERTSTRING() /*----------------------------*/ local bool               bulkInsertString(StringTreeSystem *const stringTreeSystem, const char *const *const stringArray)
	#define INSERTSTRING() /*--------------------------------*/ local bool               insertString(StringTreeSystem *const stringTreeSystem, const char *string)
	#define GETSTRINGTREENODE() /*---------------------------*/ local StringTreeNode *   getStringTreeNode(StringTreeSystem *const stringTreeSystem, const char **const stringReturn)
	#define FINDSTRINGTREESTRING() /*------------------------*/ local bool               findStringTreeString(StringTreeSystem *const stringTreeSystem, char *const *const string)
	#define FINISTRINGTREESYSTEM() /*------------------------*/ local bool               finiStringTreeSystem(StringTreeSystem *const stringTreeSystem)

	#define INITSTDINSYSTEM() /*-----------------------------*/ local bool               initSTDINSystem(STDINSystem *const stdinSystem)
	#define CONNECTSTDIN() /*--------------------------------*/ local bool               connectSTDIN(STDINSystem *const stdinSystem)
	#define STDINMAIN() /*-----------------------------------*/ local void *             stdinMain(void *const arg)
	#define GETNEXTSTDINCHARACTER() /*-----------------------*/ local int                getNextSTDINCharacter(void *const arg)
	#define GETPREVIOUSSTDINCHARACTER() /*-------------------*/ local int                getPreviousSTDINCharacter(void *const arg)
	#define DISCONNECTSTDIN() /*-----------------------------*/ local bool               disconnectSTDIN(STDINSystem *const stdinSystem)
	#define FINISTDINSYSTEM() /*-----------------------------*/ local bool               finiSTDINSystem(STDINSystem *const stdinSystem)

	#define INITSHAREDMEMORYSYSTEM() /*----------------------*/ local bool               initSharedMemorySystem(SharedMemorySystem *const sharedMemorySystem)
	#define CONNECTSHAREDMEMORY() /*-------------------------*/ local bool               connectSharedMemory(SharedMemorySystem *const sharedMemorySystem)
	#define SHAREDMEMORYMAIN() /*----------------------------*/ local void *             sharedMemoryMain(void *const arg)
	#define GETNEXTSHAREDMEMORYCHARACTER() /*----------------*/ local int                getNextSharedMemoryCharacter(void *const arg)
	#define GETPREVIOUSSHAREDMEMORYCHARACTER() /*------------*/ local int                getPreviousSharedMemoryCharacter(void *const arg)
	#define DISCONNECTSHAREDMEMORY() /*----------------------*/ local bool               disconnectSharedMemory(SharedMemorySystem *const sharedMemorySystem)
	#define FINISHAREDMEMORYSYSTEM() /*----------------------*/ local bool               finiSharedMemorySystem(SharedMemorySystem *const sharedMemorySystem)

	#define INITSHORTCUTSYSTEM() /*--------------------------*/ local bool               initShortcutSystem(ShortcutSystem *const shortcutSystem)
	#define INSERTSHORTCUT() /*------------------------------*/ local bool               insertShortcut(ShortcutSystem *const shortcutSystem, const uint8 code, const uint16 modifier, const uint8 onState, const Command command, char *const string, const uint32 stringToken, const int32 field0, const int32 field1, const int32 field2, const int32 field3, const int32 field4)
	#define GETNEXTSHORTCUT() /*-----------------------------*/ local bool               getNextShortcut(ShortcutSystem *const shortcutSystem, const bool isRelease, uint8 code, uint16 modifier, int *const nextOffset)
	#define REMOVESHORTCUT() /*------------------------------*/ local bool               removeShortcut(ShortcutSystem *const shortcutSystem, const uint8 code, const uint16 modifier)
	#define FINISHORTCUTSYSTEM() /*--------------------------*/ local bool               finiShortcutSystem(ShortcutSystem *const shortcutSystem)

	#define SETCONFIGVARIABLES() /*--------------------------*/ local void               setConfigVariables(void)
	#define READCONFIG() /*----------------------------------*/ local void               readConfig(const bool createConfigFile, const char *const configPath, int (*getNextConfigChar)(void *const arg), int (*getPreviousConfigChar)(void *const arg))
	#define IFGETC() /*--------------------------------------*/ local int                ifgetc(void *const system)
	#define MATCHNAMELIST() /*-------------------------------*/ local uint8              matchNameList(StringTreeSystem *const stringTreeSystem, const char *const statementWall, char **statementCurrentReturn, uint8 *const valueReturn)
	#define MATCHINTEGER() /*--------------------------------*/ local uint8              matchInteger(char **statementCurrent, const char *const statementWall, int64 *const returnValue)
	#define MATCHSTRING() /*---------------------------------*/ local bool               matchString(char **statementCurrent, char **stringReturn, uint32 *stringToken)
	#define MATCHIMAGE() /*----------------------------------*/ local uint8              matchImage(const char *const path, const char **errorMessage, Image *const image)
	#define MATCHCOMMAND() /*--------------------------------*/ local uint8              matchCommand(const Command command, const char *const execute, const uint8 origin, const int32 field0, const int32 field1, const int32 field2, const int32 field3, const int32 field4)
	#define UNGRABSHORTCUTS() /*-----------------------------*/ local bool               ungrabShortcuts(void)
	#define FREECONFIGVARIABLES() /*-------------------------*/ local void               freeConfigVariables(void)

	#define SETMEMORY() /*-----------------------------------*/ local void               setMemory(void *const destinationStart, const uint64 value, const uint itemAmount, const uint8 perByteAmount)
	#define COPYMEMORY() /*----------------------------------*/ local void               copyMemory(const void *const sourceStart, void *const destinationStart, uint byteAmount)
	#define SHIFTMEMORY() /*---------------------------------*/ local void               shiftMemory(void *const start, int byteAmount, int byteOffset)
	#define COMPAREMEMORY() /*-------------------------------*/ local bool               compareMemory(const void *memory0, const void *memory1, const uint byteAmount)
	#define FINDSTRINGLENGTH() /*----------------------------*/ local uint               findStringLength(const void *string)
	#define FINDSUBSTRING() /*-------------------------------*/ local char *             findSubstring(const char *const string, const uint stringLength, const char *const substring, const uint substringLength)
	#define UTF8TOUCS2() /*----------------------------------*/ local uint               UTF8ToUCS2(uint8 *const utf8Start, const uint utf8Length, uint16 *const ucs2Start, const uint ucs2Length)
	#define INTERSECTS() /*----------------------------------*/ local bool               intersects(const int x0, const int y0, const int width0, const int height0, const int x1, const int y1, const int width1, const int height1)
	#define GETINTERSECTION() /*-----------------------------*/ local void               getIntersection(const int x0, const int y0, const int width0, const int height0, const int x1, const int y1, const int width1, const int height1, int *const xReturn, int *const yReturn, int *const widthReturn, int *const heightReturn)
	#define LOADFILE() /*------------------------------------*/ local bool               loadFile(const char *const path, LoadedFile *const loadedFileReturn)
	#define SPAWNPROCESS() /*--------------------------------*/ local void               spawnProcess(const void *const string)

	#define CREATECIRCLE() /*--------------------------------*/ local bool               createCircle(const int radius, const uint32 foreground, const uint32 background, Image *image)
	#define COMPOSITEIMAGES() /*-----------------------------*/ local void               compositeImages(void (*operation)(const uint32 *const, uint32 *const), const int sourceX, const int sourceY, Image *const source, int destinationX, int destinationY, Image *const destination)
	#define COMPOSITEIMAGESOVER() /*-------------------------*/ local void               compositeImagesOver(const uint32 *const source, uint32 *const destination)
	#define COMPOSITEIMAGESAND() /*--------------------------*/ local void               compositeImagesAnd(const uint32 *const source, uint32 *const destination)
	#define TWOPASSBOXBLUR() /*------------------------------*/ local void               twoPassBoxBlur(const int width, const int height, const int boxSize, uint32 *destinationData)
	#define ROTATEIMAGE() /*---------------------------------*/ local bool               rotateImage(const uint8 rotation, Image *const image, const bool deletePreviousData)

	#define XCB_SYNC() /*------------------------------------*/ local bool               xcb_sync(void)
	#define GETTIMESTAMP() /*--------------------------------*/ local xcb_timestamp_t    getTimestamp(void)
	#define GETWINDOWCLASS() /*------------------------------*/ local uint8              getWindowClass(xcb_window_t window)
	#define GETFOCUSEDWINDOW() /*----------------------------*/ local xcb_window_t       getFocusedWindow(void)
	#define GRABDEVICE() /*----------------------------------*/ local bool               grabDevice(const uint8 device, const uint attemptAmount)
	#define UNGRABDEVICE() /*--------------------------------*/ local bool               ungrabDevice(const uint8 device)
	#define FILLDRAWABLE() /*--------------------------------*/ local void               fillDrawable(const xcb_drawable_t drawable, const xcb_gcontext_t gc, const int16 x, const int16 y, const uint16 width, const uint16 height, const uint32 color)
	#define SETCLIPPINGRECTANGLE() /*------------------------*/ local bool               setClippingRectangle(const xcb_gcontext_t gc, const int x, const int y, const uint width, const uint height)
	#define TIGHTENCLIPPINGRECTANGLE() /*--------------------*/ local bool               tightenClippingRectangle(const xcb_gcontext_t gc, const int x, const int y, const int width, const int height, int *const clipXReturn, int *const clipYReturn, int *const clipWidthReturn, int *const clipHeightReturn)
	#define UNSETCLIPPINGRECTANGLE() /*----------------------*/ local bool               unsetClippingRectangle(const xcb_gcontext_t gc)

	#define RESTART() /*-------------------------------------*/ local void               restart(const bool isInsideConfig)
	#define CLEANUP() /*-------------------------------------*/ local void               cleanup(void)
	#define CANCELTHREADS() /*-------------------------------*/ local void               cancelThreads(void)

	#define PRINTUNACCOUNTEDFORPOINTERS() /*-----------------*/ local void               printUnaccountedForPointers(const Pointer *current, const Pointer *wall)
	#define PRINTERROR() /*----------------------------------*/ local void               printError(const char *const message, ...)
	#define PRINTTITLEDERROR() /*----------------------------*/ local void               printTitledError(const char *const title, const char *const message)
	#define PRINTTITLEDQUOTEDERROR() /*----------------------*/ local void               printTitledQuotedError(const char *const title, const char *const argument, const char *const message)
	#define PRINTCONNECTIONERROR() /*------------------------*/ local void               printConnectionError(void)
	#define PRINTTITLEDNAMEDERROR() /*-----------------------*/ local void               printTitledNamedError(const char *const title, const char *const message, const char *const name)
	#define PRINTXERROR() /*---------------------------------*/ local void               printXError(const char *const *const name)
	#define PRINTTITLEDVALUEDERROR() /*----------------------*/ local void               printTitledValuedError(const char *const title, const char *const message, const uint value)
	#define PRINTCONFIGERROR() /*----------------------------*/ local void               printConfigError(const char *const type, const char *const message, const char finalStatementCharacter, const bool printLine, const bool printConfig, const bool printPointer, const bool printPattern, const char *const configPath, const uint statementLine, const char *const statementStart, const char *const statementWall, const Instruction *instructionStart, const Instruction *instructionCurrent, StringTreeSystem *const *const instructionDataStart, const char *const *currentScopeInstructionList, const StringTreeSystem *const currentScopeInstructionStringTreeSystem)

	#define OPENERRORSTREAM() /*-----------------------------*/ local bool               openErrorStream(void)
	#define CLOSEERRORSTREAM() /*----------------------------*/ local bool               closeErrorStream(void)

	#define xcb_wait_for_reply(a, b, c) /*-------------------*/ (xcb_wait_for_reply(a, (b).sequence, c))
	#define xcb_discard_reply(a, b) /*-----------------------*/ (xcb_discard_reply(a, (b).sequence))
	#define xcb_send_event(a, b, c, d, e) /*-----------------*/ (xcb_send_event(a, b, c, d, (void *)(e)))
	#define xcb_send_event_checked(a, b, c, d, e) /*---------*/ (xcb_send_event_checked(a, b, c, d, (void *)(e)))

	#define EMPTY(void) /*-----------------------------------*/ EMPTY_MACRO
	#define SELF(self) /*------------------------------------*/ self
	#define STRINGIFY(identifier) /*-------------------------*/ #identifier
	#define ENUM_CONTENT(content) /*-------------------------*/ content##_CONTENT(SELF, EMPTY, EMPTY, _##content) content##_ENUM
	#define STRING_CONTENT(content) /*-----------------------*/ content##_CONTENT(EMPTY, STRINGIFY, SELF, _##content)

	#define ASCII_TO_UCS2(c) /*------------------------------*/ ((c) << 8)

	#define pushPointer(a, b, c) /*--------------------------*/ (_pushPointer(__FILE__, __LINE__, a, b, (int (*const)(void *))(c)))

	#if DEBUG
		#define useEventBase(n0, n1) /*-*/ n0 == n1##EventName? n1##BaseEvent
		#define useEventName(n0, n1) /*-*/ n0 == n1##EventName? "X " #n1 " event"
		#define printXEvent(n) /*-------*/ { \
			uint base = ((*event).response_type & ~b(10000000)) - ( \
			      n == baseEventName? 0 \
				: useEventBase(n, randr) \
				: useEventBase(n, shape) \
				: useEventBase(n, xfixes) \
				: ((*event).response_type & ~b(10000000)) - countof(baseEventName) + 1 \
			); \
			fprintf(DEFAULT_OUTPUT_STREAM, "%s%s: %s%s:%s %s\n", colorStart, programName, colorEvent \
				, n == baseEventName? "X event" \
				: useEventName(n, randr) \
				: useEventName(n, shape) \
				: useEventName(n, xfixes) \
				: "X unrecognized extension event" \
				, colorEnd \
				, n != baseEventName and n != randrEventName and n != shapeEventName and n != xfixesEventName? "unhandled extension event" \
				: *(n + (base >= countof(n)? countof(n) - 1 : base)) \
			); \
		}
		#define printCommand(s, c) /*---*/ (fprintf(DEFAULT_OUTPUT_STREAM, "%s%s: %s" s " command:%s %s\n", colorStart, programName, colorEvent, colorEnd, *(commandList + (c >= countof(commandList)? countof(commandList) - 1 : c))))
	#else
		#define printXEvent(n) /*-------*/ EMPTY_MACRO
		#define printCommand(s, c) /*---*/ EMPTY_MACRO
	#endif
/*!}*/









/*!*/

#define DIRECTION_CONTENT(k, v, n, p) /*------------------*/ { \
	  v(none)  k(NONE##p  = (b(0000))) \
	, v(up)    k(UP##p    = (b(0001))) \
	, v(down)  k(DOWN##p  = (b(0010))) \
	, v(left)  k(LEFT##p  = (b(0100))) \
	, v(right) k(RIGHT##p = (b(1000))) \
	, n(NULL)  k(NULL##p) \
}









/*!defs:{*/
	def enum ENUM_CONTENT(GLOBAL_SCOPES_INSTRUCTION);
	def enum ENUM_CONTENT(GLOBAL_INSTRUCTION);
	def enum ENUM_CONTENT(SCOPE1_SCOPE_INSTRUCTION);
	def enum ENUM_CONTENT(BOOLEAN);
	def enum ENUM_CONTENT(VARIABLE);
	def enum ENUM_CONTENT(COMMAND);
	def enum ENUM_CONTENT(MODIFIER);
	def enum ENUM_CONTENT(SHORTCUT_STATE);
	def enum ENUM_CONTENT(NUMBER_TYPE);
	def enum ENUM_CONTENT(POSITION);
	def enum ENUM_CONTENT(HORIZONTAL_ALIGNMENT);
	def enum ENUM_CONTENT(VERTICAL_ALIGNMENT);
	def enum ENUM_CONTENT(CORNER);
	def enum ENUM_CONTENT(AXIS);
	def enum ENUM_CONTENT(WHICH_MONITOR);
	def enum ENUM_CONTENT(DIRECTION);
	def enum ENUM_CONTENT(ROTATION);
	def enum ENUM_CONTENT(MACRO);

	def uint8 /*-*/ Command;
	def uint8 /*-*/ Instruction;
	def uint8 /*-*/ JmpPoint;

	def struct{
		const char * /*--------*/ label;
		uint64 * /*------------*/ data;
		uint32 /*--------------*/ token;
		uint32 /*--------------*/ line;
		const char * /*--------*/ file;
		int /*-----------------*/ (*free)(void *);
	} Pointer;

	def struct{
		uint32 /*--------------*/ size;
		uint32 /*--------------*/ allocated;
		Pointer * /*-----------*/ data;
		uint8 /*---------------*/ pad0[7];
		bool /*----------------*/ mutexCreated;
		pthread_mutex_t /*-----*/ mutex;
	} MemoryManagerSystem;

	def struct{
		uid_t /*---------------*/ normalUID;
		gid_t /*---------------*/ normalGID;
	} PermissionSystem;

	def struct{
		xcb_atom_t /*----------*/ MICRO_INIT;
		xcb_atom_t /*----------*/ MANAGER;
		xcb_atom_t /*----------*/ WM_NAME;
		xcb_atom_t /*----------*/ WM_ICON_NAME;
		xcb_atom_t /*----------*/ WM_NORMAL_HINTS;
		xcb_atom_t /*----------*/ WM_SIZE_HINTS;
		xcb_atom_t /*----------*/ WM_HINTS;
		xcb_atom_t /*----------*/ WM_CLASS;
		xcb_atom_t /*----------*/ WM_TRANSIENT_FOR;
		xcb_atom_t /*----------*/ WM_PROTOCOLS;
		xcb_atom_t /*----------*/ WM_TAKE_FOCUS;
		xcb_atom_t /*----------*/ WM_DELETE_WINDOW;
		xcb_atom_t /*----------*/ WM_COLORMAP_WINDOWS;
		xcb_atom_t /*----------*/ WM_COLORMAP_NOTIFY;
		xcb_atom_t /*----------*/ WM_CLIENT_MACHINE;
		xcb_atom_t /*----------*/ WM_LOCALE_NAME;
		xcb_atom_t /*----------*/ WM_WINDOW_ROLE;
		xcb_atom_t /*----------*/ WM_COMMAND;
		xcb_atom_t /*----------*/ WM_CLIENT_LEADER;
		xcb_atom_t /*----------*/ WM_STATE;
		xcb_atom_t /*----------*/ WM_CHANGE_STATE;
		xcb_atom_t /*----------*/ WM_ICON_SIZE;
		xcb_atom_t /*----------*/ SM_CLIENT_ID;
		xcb_atom_t /*----------*/ UTF8_STRING;
		xcb_atom_t /*----------*/ _NET_SUPPORTED;
		xcb_atom_t /*----------*/ _NET_CLIENT_LIST;
		xcb_atom_t /*----------*/ _NET_CLIENT_LIST_STACKING;
		xcb_atom_t /*----------*/ _NET_NUMBER_OF_DESKTOPS;
		xcb_atom_t /*----------*/ _NET_DESKTOP_GEOMETRY;
		xcb_atom_t /*----------*/ _NET_DESKTOP_VIEWPORT;
		xcb_atom_t /*----------*/ _NET_CURRENT_DESKTOP;
		xcb_atom_t /*----------*/ _NET_DESKTOP_NAMES;
		xcb_atom_t /*----------*/ _NET_ACTIVE_WINDOW;
		xcb_atom_t /*----------*/ _NET_WORKAREA;
		xcb_atom_t /*----------*/ _NET_SUPPORTING_WM_CHECK;
		xcb_atom_t /*----------*/ _NET_VIRTUAL_ROOTS;
		xcb_atom_t /*----------*/ _NET_DESKTOP_LAYOUT;
		xcb_atom_t /*----------*/ _NET_SHOWING_DESKTOP;
		xcb_atom_t /*----------*/ _NET_CLOSE_WINDOW;
		xcb_atom_t /*----------*/ _NET_MOVERESIZE_WINDOW;
		xcb_atom_t /*----------*/ _NET_WM_MOVERESIZE;
		xcb_atom_t /*----------*/ _NET_RESTACK_WINDOW;
		xcb_atom_t /*----------*/ _NET_REQUEST_FRAME_EXTENTS;
		xcb_atom_t /*----------*/ _NET_WM_NAME;
		xcb_atom_t /*----------*/ _NET_WM_VISIBLE_NAME;
		xcb_atom_t /*----------*/ _NET_WM_ICON_NAME;
		xcb_atom_t /*----------*/ _NET_WM_VISIBLE_ICON_NAME;
		xcb_atom_t /*----------*/ _NET_WM_DESKTOP;
		xcb_atom_t /*----------*/ _NET_WM_WINDOW_TYPE;
		xcb_atom_t /*----------*/ _NET_WM_WINDOW_TYPE_DESKTOP;
		xcb_atom_t /*----------*/ _NET_WM_WINDOW_TYPE_DOCK;
		xcb_atom_t /*----------*/ _NET_WM_WINDOW_TYPE_TOOLBAR;
		xcb_atom_t /*----------*/ _NET_WM_WINDOW_TYPE_MENU;
		xcb_atom_t /*----------*/ _NET_WM_WINDOW_TYPE_UTILITY;
		xcb_atom_t /*----------*/ _NET_WM_WINDOW_TYPE_SPLASH;
		xcb_atom_t /*----------*/ _NET_WM_WINDOW_TYPE_DIALOG;
		xcb_atom_t /*----------*/ _NET_WM_WINDOW_TYPE_NORMAL;
		xcb_atom_t /*----------*/ _NET_WM_STATE;
		xcb_atom_t /*----------*/ _NET_WM_STATE_MODAL;
		xcb_atom_t /*----------*/ _NET_WM_STATE_STICKY;
		xcb_atom_t /*----------*/ _NET_WM_STATE_MAXIMIZED_HORZ;
		xcb_atom_t /*----------*/ _NET_WM_STATE_MAXIMIZED_VERT;
		xcb_atom_t /*----------*/ _NET_WM_STATE_SHADED;
		xcb_atom_t /*----------*/ _NET_WM_STATE_SKIP_TASKBAR;
		xcb_atom_t /*----------*/ _NET_WM_STATE_SKIP_PAGER;
		xcb_atom_t /*----------*/ _NET_WM_STATE_HIDDEN;
		xcb_atom_t /*----------*/ _NET_WM_STATE_FULLSCREEN;
		xcb_atom_t /*----------*/ _NET_WM_STATE_ABOVE;
		xcb_atom_t /*----------*/ _NET_WM_STATE_BELOW;
		xcb_atom_t /*----------*/ _NET_WM_STATE_DEMANDS_ATTENTION;
		xcb_atom_t /*----------*/ _NET_WM_ALLOWED_ACTIONS;
		xcb_atom_t /*----------*/ _NET_WM_ACTION_MOVE;
		xcb_atom_t /*----------*/ _NET_WM_ACTION_RESIZE;
		xcb_atom_t /*----------*/ _NET_WM_ACTION_MINIMIZE;
		xcb_atom_t /*----------*/ _NET_WM_ACTION_SHADE;
		xcb_atom_t /*----------*/ _NET_WM_ACTION_STICK;
		xcb_atom_t /*----------*/ _NET_WM_ACTION_MAXIMIZE_HORZ;
		xcb_atom_t /*----------*/ _NET_WM_ACTION_MAXIMIZE_VERT;
		xcb_atom_t /*----------*/ _NET_WM_ACTION_FULLSCREEN;
		xcb_atom_t /*----------*/ _NET_WM_ACTION_CHANGE_DESKTOP;
		xcb_atom_t /*----------*/ _NET_WM_ACTION_CLOSE;
		xcb_atom_t /*----------*/ _NET_WM_STRUT;
		xcb_atom_t /*----------*/ _NET_WM_STRUT_PARTIAL;
		xcb_atom_t /*----------*/ _NET_WM_ICON_GEOMETRY;
		xcb_atom_t /*----------*/ _NET_WM_ICON;
		xcb_atom_t /*----------*/ _NET_WM_PID;
		xcb_atom_t /*----------*/ _NET_WM_HANDLED_ICONS;
		xcb_atom_t /*----------*/ _NET_WM_USER_TIME;
		xcb_atom_t /*----------*/ _NET_FRAME_EXTENTS;
		xcb_atom_t /*----------*/ _NET_WM_PING;
		xcb_atom_t /*----------*/ _NET_WM_SYNC_REQUEST;
		xcb_atom_t /*----------*/ _NET_WM_SYNC_REQUEST_COUNTER;
		xcb_atom_t /*----------*/ _NET_SYSTEM_TRAY_ORIENTATION;
		xcb_atom_t /*----------*/ _NET_SYSTEM_TRAY_OPCODE;
		xcb_atom_t /*----------*/ _NET_SYSTEM_TRAY_MESSAGE_DATA;
		xcb_atom_t /*----------*/ _XEMBED_INFO;
		xcb_atom_t /*----------*/ _XEMBED;
		xcb_atom_t /*----------*/ _XROOTPMAP_ID;
		xcb_atom_t /*----------*/ WM_Sn;
	} CommonAtoms;

	def struct{
		xcb_atom_t /*----------*/ name;
		int32 /*---------------*/ leftX;
		int32 /*---------------*/ rightX;
		int32 /*---------------*/ topY;
		int32 /*---------------*/ bottomY;
		int32 /*---------------*/ width;
		int32 /*---------------*/ height;
		uint32 /*--------------*/ millimeterWidth;
		uint32 /*--------------*/ millimeterHeight;
	} Monitor;

	def struct{
		Monitor * /*-----------*/ start;
		uint32 /*--------------*/ token;
		uint32 /*--------------*/ size;
	} MonitorSystem;

	def struct{
		uint32 /*--------------*/ timestamp;
		int32 /*---------------*/ x;
		int32 /*---------------*/ y;
	} PointerSystem;

	def struct{
		xcb_font_t /*----------*/ cursorFont;
		xcb_cursor_t /*--------*/ cursor;
	} CursorSystem;

	def struct{
		xcb_pixmap_t /*--------*/ pixmap;
		xcb_gcontext_t /*------*/ gc;
		uint32 /*--------------*/ width;
		uint32 /*--------------*/ height;
		uint32 /*--------------*/ color;
		xcb_pixmap_t /*--------*/ wallpaperPixmap;
		uint32 /*--------------*/ wallpaperWidth;
		uint32 /*--------------*/ wallpaperHeight;
	} WallpaperSystem;

	def struct{
		uint8 /*---------------*/ pad0[3];
		bool /*----------------*/ inUse;
		xcb_window_t /*--------*/ container;
		xcb_window_t /*--------*/ window;
		xcb_pixmap_t /*--------*/ pixmap;
		xcb_gcontext_t /*------*/ gc;
		int32 /*---------------*/ containerX;
		int32 /*---------------*/ containerY;
		uint32 /*--------------*/ containerWidth;
		uint32 /*--------------*/ containerHeight;
		uint32 /*--------------*/ containerBorder;
		int32 /*---------------*/ windowX;
		int32 /*---------------*/ windowY;
		uint32 /*--------------*/ windowWidth;
		uint32 /*--------------*/ windowHeight;
		uint32 /*--------------*/ windowBorder;
		int32 /*---------------*/ strutX;
		int32 /*---------------*/ strutY;
		uint32 /*--------------*/ strutWidth;
		uint32 /*--------------*/ strutHeight;
		int32 /*---------------*/ oldContainerX;
		int32 /*---------------*/ oldContainerY;
		uint32 /*--------------*/ oldContainerWidth;
		uint32 /*--------------*/ oldContainerHeight;
		uint32 /*--------------*/ oldContainerBorder;
		uint8 * /*-------------*/ nameStart;
		uint32 /*--------------*/ nameToken;
		uint32 /*--------------*/ nameSize;
		uint8 * /*-------------*/ iconNameStart;
		uint32 /*--------------*/ iconNameToken;
		uint32 /*--------------*/ iconNameSize;
		uint32 /*--------------*/ normalHintsFlags;
		int32 /*---------------*/ normalHintsX;
		int32 /*---------------*/ normalHintsY;
		int32 /*---------------*/ normalHintsWidth;
		int32 /*---------------*/ normalHintsHeight;
		int32 /*---------------*/ normalHintsMinWidth;
		int32 /*---------------*/ normalHintsMinHeight;
		int32 /*---------------*/ normalHintsMaxWidth;
		int32 /*---------------*/ normalHintsMaxHeight;
		int32 /*---------------*/ normalHintsWidthInc;
		int32 /*---------------*/ normalHintsHeightInc;
		int32 /*---------------*/ normalHintsMinAspectNumerator;
		int32 /*---------------*/ normalHintsMinAspectDenominator;
		int32 /*---------------*/ normalHintsMaxAspectNumerator;
		int32 /*---------------*/ normalHintsMaxAspectDenominator;
		int32 /*---------------*/ normalHintsBaseWidth;
		int32 /*---------------*/ normalHintsBaseHeight;
		int32 /*---------------*/ normalHintsWindowGravity;
		uint32 /*--------------*/ hintsInput;
		uint32 /*--------------*/ hintsInitialState;
		xcb_pixmap_t /*--------*/ hintsIconPixmap;
		xcb_window_t /*--------*/ hintsIconWindow;
		int32 /*---------------*/ hintsIconX;
		int32 /*---------------*/ hintsIconY;
		xcb_pixmap_t /*--------*/ hintsIconMask;
		xcb_window_t /*--------*/ hintsWindowGroup;
		uint32 /*--------------*/ hintsUrgency;
		xcb_window_t /*--------*/ transientFor;
		uint8 * /*-------------*/ classStart;
		uint32 /*--------------*/ classToken;
		uint32 /*--------------*/ classSize;
		xcb_atom_t * /*--------*/ protocolStart;
		uint32 /*--------------*/ protocolToken;
		uint32 /*--------------*/ protocolSize;
		xcb_window_t * /*------*/ colormapWindowStart;
		uint32 /*--------------*/ colormapWindowToken;
		uint32 /*--------------*/ colormapWindowSize;
		uint8 * /*-------------*/ clientMachineStart;
		uint32 /*--------------*/ clientMachineToken;
		uint32 /*--------------*/ clientMachineSize;
		uint8 * /*-------------*/ clientIDStart;
		uint32 /*--------------*/ clientIDToken;
		uint32 /*--------------*/ clientIDSize;
		xcb_window_t /*--------*/ clientLeader;
		uint32 /*--------------*/ desktop;
		uint32 /*--------------*/ stateState;
		xcb_window_t /*--------*/ stateIcon;
		uint8 * /*-------------*/ windowRoleStart;
		uint32 /*--------------*/ windowRoleToken;
		uint32 /*--------------*/ windowRoleSize;
		uint8 * /*-------------*/ visibleNameStart;
		uint32 /*--------------*/ visibleNameToken;
		uint32 /*--------------*/ visibleNameSize;
		uint8 * /*-------------*/ visibleIconNameStart;
		uint32 /*--------------*/ visibleIconNameToken;
		uint32 /*--------------*/ visibleIconNameSize;
		xcb_atom_t * /*--------*/ windowTypeStart;
		uint32 /*--------------*/ windowTypeToken;
		uint32 /*--------------*/ windowTypeSize;
		xcb_atom_t * /*--------*/ stateStart;
		uint32 /*--------------*/ stateToken;
		uint32 /*--------------*/ stateSize;
		xcb_atom_t * /*--------*/ allowedActionStart;
		uint32 /*--------------*/ allowedActionToken;
		uint32 /*--------------*/ allowedActionSize;
		uint32 /*--------------*/ strutLeft;
		uint32 /*--------------*/ strutRight;
		uint32 /*--------------*/ strutTop;
		uint32 /*--------------*/ strutBottom;
		uint32 /*--------------*/ strutLeftStartY;
		uint32 /*--------------*/ strutLeftEndY;
		uint32 /*--------------*/ strutRightStartY;
		uint32 /*--------------*/ strutRightEndY;
		uint32 /*--------------*/ strutTopStartX;
		uint32 /*--------------*/ strutTopEndX;
		uint32 /*--------------*/ strutBottomStartX;
		uint32 /*--------------*/ strutBottomEndX;
		uint32 /*--------------*/ iconGeometryX;
		uint32 /*--------------*/ iconGeometryY;
		uint32 /*--------------*/ iconGeometryWidth;
		uint32 /*--------------*/ iconGeometryHeight;
		uint32 * /*------------*/ iconStart;
		uint32 /*--------------*/ iconToken;
		uint32 /*--------------*/ iconSize;
		uint64 /*--------------*/ userTime;
		uint32 /*--------------*/ pid;
		uint32 /*--------------*/ frameExtentsLeft;
		uint32 /*--------------*/ frameExtentsRight;
		uint32 /*--------------*/ frameExtentsTop;
		uint32 /*--------------*/ frameExtentsBottom;
		uint8 /*---------------*/ protocol;
		uint8 /*---------------*/ windowType;
		uint16 /*--------------*/ state;
		uint16 /*--------------*/ allowedAction;
		bool /*----------------*/ strut;
		bool /*----------------*/ handledIcons;
		uint8 /*---------------*/ propertyPreference;
		uint8 /*---------------*/ orderType;
		uint8 /*---------------*/ option;
		uint8 /*---------------*/ workareaPosition;
	} Client;

	def struct{
		Client * /*------------*/ clientStart;
		uint32 /*--------------*/ clientToken;
		uint32 /*--------------*/ clientSize;
		uint32 /*--------------*/ clientAllocated;
		uint32 /*--------------*/ clientNotInUseOffset;
		uint32 /*--------------*/ orderedClientOffsetSize;
		uint32 /*--------------*/ orderedClientOffsetAllocated;
		uint * /*--------------*/ orderedClientOffsetStart;
		uint32 /*--------------*/ orderedClientOffsetToken;
		uint8 /*---------------*/ pad0[6];
		uint8 /*---------------*/ motionAction;
		uint8 /*---------------*/ motionGravity;
		int32 /*---------------*/ motionStartingX;
		int32 /*---------------*/ motionStartingY;
		int32 /*---------------*/ motionX;
		int32 /*---------------*/ motionY;
		int32 /*---------------*/ motionWidth;
		int32 /*---------------*/ motionHeight;
		uint32 /*--------------*/ recentlyConfiguredClientOffset;
		uint32 /*--------------*/ motionClientOffset;
		uint32 /*--------------*/ focusedClientOffset;
	} ClientSystem;

	def struct{
		int32 /*---------------*/ top;
		int32 /*---------------*/ bottom;
		int32 /*---------------*/ left;
		int32 /*---------------*/ right;
	} EdgeOffset;

	def struct{
		uint32 /*--------------*/ orderedClientOffsetSize;
		uint32 /*--------------*/ orderedClientOffsetAllocated;
		uint * /*--------------*/ orderedClientOffsetStart;
		uint32 /*--------------*/ orderedClientOffsetToken;
		uint32 /*--------------*/ nameSize;
		uint8 * /*-------------*/ nameStart;
		uint32 /*--------------*/ nameToken;
		uint32 /*--------------*/ workareaEdgeOffsetSize;
		EdgeOffset * /*--------*/ workareaEdgeOffsetStart;
		uint32 /*--------------*/ workareaEdgeOffsetToken;
		xcb_window_t /*--------*/ window;
		xcb_pixmap_t /*--------*/ pixmap;
		xcb_gcontext_t /*------*/ gc;
	} VirtualRoot;

	def struct{
		int32 /*---------------*/ x;
		int32 /*---------------*/ y;
	} Viewport;

	def struct{
		int32 /*---------------*/ x;
		int32 /*---------------*/ y;
		uint32 /*--------------*/ width;
		uint32 /*--------------*/ height;
	} Workarea;

	def struct{
		uint32 /*--------------*/ virtualRootSize;
		uint32 /*--------------*/ virtualRootAllocated;
		VirtualRoot * /*-------*/ virtualRootStart;
		uint32 /*--------------*/ virtualRootToken;
		uint32 /*--------------*/ workareaEdgeOffsetSize;
		EdgeOffset * /*--------*/ workareaEdgeOffsetStart;
		uint32 /*--------------*/ workareaEdgeOffsetToken;
		uint32 /*--------------*/ windowSize;
		xcb_window_t * /*------*/ windowStart;
		uint32 /*--------------*/ windowToken;
		uint32 /*--------------*/ viewportSize;
		Viewport * /*----------*/ viewportStart;
		uint32 /*--------------*/ viewportToken;
		uint32 /*--------------*/ desktopNamesSize;
		uint8 * /*-------------*/ desktopNamesStart;
		uint32 /*--------------*/ desktopNamesToken;
		uint32 /*--------------*/ workareaSize;
		Workarea * /*----------*/ workareaStart;
		uint32 /*--------------*/ workareaToken;
		uint32 /*--------------*/ width;
		uint32 /*--------------*/ height;
		uint32 /*--------------*/ currentDesktop;
		uint32 /*--------------*/ showingDesktop;
		uint32 /*--------------*/ desktopLayoutColumns;
		uint32 /*--------------*/ desktopLayoutRows;
		uint8 /*---------------*/ desktopLayoutOrientation;
		uint8 /*---------------*/ desktopLayoutStartingCorner;
		bool /*----------------*/ mapped;
		uint8 /*---------------*/ pad1[1];
	} VirtualRootSystem;

	def struct{
		uint32 /*--------------*/ clientSize;
		uint32 /*--------------*/ clientAllocated;
		xcb_window_t * /*------*/ clientStart;
		uint32 /*--------------*/ clientToken;
		xcb_atom_t /*----------*/ property;
	} ClientListSystem;

	def struct{
		int32 /*---------------*/ x;
		int32 /*---------------*/ y;
		int32 /*---------------*/ xOffset;
		int32 /*---------------*/ yOffset;
		int32 /*---------------*/ width;
		int32 /*---------------*/ height;
		int32 /*---------------*/ padding;
		int32 /*---------------*/ margin;
		uint8 /*---------------*/ xType;
		uint8 /*---------------*/ yType;
		uint8 /*---------------*/ xOffsetType;
		uint8 /*---------------*/ yOffsetType;
		uint8 /*---------------*/ widthType;
		uint8 /*---------------*/ heightType;
		uint8 /*---------------*/ paddingType;
		uint8 /*---------------*/ marginType;
		uint8 /*---------------*/ position;
		uint8 /*---------------*/ horizontalAlignment;
		uint8 /*---------------*/ verticalAlignment;
		uint8 /*---------------*/ pad0[3];
		bool /*----------------*/ clipChildren;
		uint8 /*---------------*/ cornerUsed;
		uint32 /*--------------*/ cornerRadius;
		uint32 /*--------------*/ foreground;
		uint32 /*--------------*/ background;
		uint32 /*--------------*/ selectedForeground;
		uint32 /*--------------*/ selectedBackground;
	} ElementPreferences;

	def struct{
		xcb_window_t /*--------*/ window;
		xcb_pixmap_t /*--------*/ bufferPixmap;
		xcb_pixmap_t /*--------*/ pixmap;
		xcb_gcontext_t /*------*/ gc;
		int32 /*---------------*/ x;
		int32 /*---------------*/ y;
		uint32 /*--------------*/ width;
		uint32 /*--------------*/ height;
		bool /*----------------*/ mapped;
		uint8 /*---------------*/ pad0[3];
	} WindowInfo;

	def struct{
		xcb_pixmap_t /*--------*/ circlePixmap;
		uint32 /*--------------*/ windowInfoSize;
		WindowInfo * /*--------*/ windowInfoStart;
		uint32 /*--------------*/ windowInfoToken;
		bool /*----------------*/ mapped;
		uint8 /*---------------*/ pad0[3];
	} WindowSystem;

	def struct{
		Monitor * /*-----------*/ monitor;
		int32 /*---------------*/ x;
		int32 /*---------------*/ y;
		uint32 /*--------------*/ width;
		uint32 /*--------------*/ height;
		uint32 /*--------------*/ horizontalPadding;
		uint32 /*--------------*/ verticalPadding;
		uint32 /*--------------*/ horizontalMargin;
		uint32 /*--------------*/ verticalMargin;
	} ElementRectangle;

	def struct{
		bool /*----------------*/ (*risingOperation)(void *const arg);
		void * /*--------------*/ risingOperationArgument;
		bool /*----------------*/ (*fallingOperation)(void *const arg);
		void * /*--------------*/ fallingOperationArgument;
		uint32 /*--------------*/ seconds;
		uint32 /*--------------*/ nanoseconds;
		bool /*----------------*/ loopOperation;
		bool /*----------------*/ restartTimer;
		uint8 /*---------------*/ pad0[1];
		bool /*----------------*/ running;
		bool /*----------------*/ quittingThread;
		bool /*----------------*/ mutexCreated;
		bool /*----------------*/ condCreated;
		bool /*----------------*/ threadCreated;
		pthread_mutex_t /*-----*/ mutex;
		pthread_cond_t /*------*/ cond;
		pthread_t /*-----------*/ thread;
	} SleepThreadSystem;

	def struct{
		uint8 /*---------------*/ letter;
		uint8 /*---------------*/ childrenAmount;
		uint16 /*--------------*/ offset[STRING_TREE_NODE_CHILDREN_AMOUNT];
	} StringTreeNode;

	def struct{
		const char *const * /*-*/ stringArray;
		uint32 /*--------------*/ dataSize;
		uint32 /*--------------*/ dataAllocated;
		StringTreeNode * /*----*/ dataStart;
		uint32 /*--------------*/ dataToken;
		uint8 /*---------------*/ counter;
		uint8 /*---------------*/ returnedCounter;
		uint8 /*---------------*/ pad0[2];
	} StringTreeSystem;

	def struct{
		uint32 /*--------------*/ size;
		uint32 /*--------------*/ allocated;
		char * /*--------------*/ start;
		char * /*--------------*/ current;
		uint32 /*--------------*/ token;
		uint8 /*---------------*/ pad0[1];
		bool /*----------------*/ threadCreated;
		bool /*----------------*/ operating;
		bool /*----------------*/ quittingThread;
		pthread_t /*-----------*/ thread;
	} STDINSystem;

	def struct{
		int32 /*---------------*/ shmID;
		uint32 /*--------------*/ shmToken;
		uint8 * /*-------------*/ start;
		uint8 * /*-------------*/ current;
		uint32 /*--------------*/ token;
		uint8 /*---------------*/ pad0[6];
		bool /*----------------*/ mutexCreated;
		bool /*----------------*/ condCreated;
		bool /*----------------*/ threadCreated;
		bool /*----------------*/ operating;
		bool /*----------------*/ quittingFromInside;
		bool /*----------------*/ quittingThread;
		pthread_mutex_t * /*---*/ mutex;
		pthread_cond_t * /*----*/ cond;
		pthread_t /*-----------*/ thread;
	} SharedMemorySystem;

	def struct{
		bool /*----------------*/ inUse;
		Command /*-------------*/ command;
		uint16 /*--------------*/ modifier;
		int32 /*---------------*/ nextOffset;
		char * /*--------------*/ string;
		uint32 /*--------------*/ stringToken;
		int32 /*---------------*/ field0;
		int32 /*---------------*/ field1;
		int32 /*---------------*/ field2;
		int32 /*---------------*/ field3;
		int32 /*---------------*/ field4;
		uint8 /*---------------*/ onState;
		bool /*----------------*/ hasBeenPressed;
		uint8 /*---------------*/ pad0[6];
	} ModifierNode;

	def struct{
		ModifierNode * /*------*/ modifierStart;
		uint32 /*--------------*/ modifierToken;
		uint32 /*--------------*/ modifierSize;
		uint32 /*--------------*/ modifierAllocated;
		uint32 /*--------------*/ modifierNotInUseOffset;
		uint32 /*--------------*/ codeListStart[SHORTCUT_CODE_AMOUNT];
		uint32 /*--------------*/ codeListWall[SHORTCUT_CODE_AMOUNT];
	} ShortcutSystem;

	def struct{
		int32 /*---------------*/ x;
		int32 /*---------------*/ y;
		int32 /*---------------*/ width;
		int32 /*---------------*/ height;
		void * /*--------------*/ dataStart;
		uint32 /*--------------*/ dataToken;
		uint32 /*--------------*/ dataSize;
	} Image;

	def struct{
		char * /*--------------*/ dataStart;
		uint32 /*--------------*/ dataToken;
		uint32 /*--------------*/ dataSize;
	} LoadedFile;
/*!}*/

/*!globals:{*/
	local const char * /*-------------------*/ programName;
	local const char * /*-------------------*/ errorPath;
	local const char * /*-------------------*/ colorStart;
	local const char * /*-------------------*/ colorFatal;
	local const char * /*-------------------*/ colorError;
	local const char * /*-------------------*/ colorEvent;
	local const char * /*-------------------*/ colorEnd;
	local const char * /*-------------------*/ labelExamined;
	local const char * /*-------------------*/ connectionName;
	local const char * /*-------------------*/ configPath;
	local const char * /*-------------------*/ localeName;
	local const ModifierNode * /*-----------*/ eventModifierNode;
	local bool /*---------------------------*/ mustOpenErrorStream;
	local FILE * /*-------------------------*/ errorStream;
	local uint32 /*-------------------------*/ errorStreamToken;
	local volatile bool /*------------------*/ processingSignal;
	local bool /*---------------------------*/ quitting;
	local MemoryManagerSystem /*------------*/ memoryManagerSystem;
	local PermissionSystem /*---------------*/ permissionSystem;
	local bool /*---------------------------*/ globalsLockCreated;
	local pthread_rwlock_t /*---------------*/ globalsLock;
	local int /*----------------------------*/ screenNumber;
	local xcb_connection_t * /*-------------*/ connection;
	local uint32 /*-------------------------*/ connectionToken;
	local xcb_screen_t * /*-----------------*/ screen;
	local uint /*---------------------------*/ screenWidthInPixels;
	local uint /*---------------------------*/ screenHeightInPixels;
	local uint /*---------------------------*/ screenWidthInMillimeters;
	local uint /*---------------------------*/ screenHeightInMillimeters;
	local uint8 /*--------------------------*/ randrMajorOpcode;
	local uint8 /*--------------------------*/ randrBaseEvent;
	local uint8 /*--------------------------*/ randrBaseError;
	local uint8 /*--------------------------*/ shapeMajorOpcode;
	local uint8 /*--------------------------*/ shapeBaseEvent;
	local uint8 /*--------------------------*/ shapeBaseError;
	local uint8 /*--------------------------*/ xfixesMajorOpcode;
	local uint8 /*--------------------------*/ xfixesBaseEvent;
	local uint8 /*--------------------------*/ xfixesBaseError;
	local CommonAtoms /*--------------------*/ atom;
	local xcb_visualid_t /*-----------------*/ visual;
	local uint8 /*--------------------------*/ depth;
	local xcb_colormap_t /*-----------------*/ colormap;
	local MonitorSystem /*------------------*/ monitorSystem;
	local PointerSystem /*------------------*/ pointerSystem;
	local CursorSystem /*-------------------*/ cursorSystem;
	local WallpaperSystem /*----------------*/ wallpaperSystem;
	local ClientSystem /*-------------------*/ clientSystem;
	local VirtualRootSystem /*--------------*/ virtualRootSystem;
	local ClientListSystem /*---------------*/ clientListSystem;
	local ClientListSystem /*---------------*/ clientListStackingSystem;
	local xcb_window_t /*-------------------*/ previousWMSelectionWindow;
	local xcb_window_t /*-------------------*/ wmSelectionWindow;
	local xcb_timestamp_t /*----------------*/ wmSelectionTimestamp;
	local xcb_window_t /*-------------------*/ wmCheckWindow;
	local xcb_window_t /*-------------------*/ defaultFocusWindow;
	local xcb_window_t /*-------------------*/ glassWindow;
	local bool /*---------------------------*/ focusOnClick;
	local bool /*---------------------------*/ focusOnHover;
	local ElementPreferences /*-------------*/ windowPreferences;
	local uint8 /*--------------------------*/ whichMonitor;
	local WindowSystem /*-------------------*/ windowSystem;
	local SleepThreadSystem /*--------------*/ sleepThreadSystem;
	local StringTreeSystem /*---------------*/ globalScopesInstructionStringTreeSystem;
	local StringTreeSystem /*---------------*/ globalInstructionStringTreeSystem;
	local StringTreeSystem /*---------------*/ scope1ScopeInstructionStringTreeSystem;
	local StringTreeSystem /*---------------*/ booleanStringTreeSystem;
	local StringTreeSystem /*---------------*/ variableStringTreeSystem;
	local StringTreeSystem /*---------------*/ commandStringTreeSystem;
	local StringTreeSystem /*---------------*/ modifierStringTreeSystem;
	local StringTreeSystem /*---------------*/ shortcutStateStringTreeSystem;
	local StringTreeSystem /*---------------*/ numberTypeStringTreeSystem;
	local StringTreeSystem /*---------------*/ horizontalAlignmentStringTreeSystem;
	local StringTreeSystem /*---------------*/ verticalAlignmentStringTreeSystem;
	local StringTreeSystem /*---------------*/ cornerStringTreeSystem;
	local StringTreeSystem /*---------------*/ whichMonitorStringTreeSystem;
	local StringTreeSystem /*---------------*/ directionStringTreeSystem;
	local StringTreeSystem /*---------------*/ macroStringTreeSystem;
	local bool /*---------------------------*/ displaySimpleConfigErrors;
	local STDINSystem /*--------------------*/ stdinSystem;
	local SharedMemorySystem /*-------------*/ sharedMemorySystem;
	local ShortcutSystem /*-----------------*/ keycodeShortcutSystem;
	local ShortcutSystem /*-----------------*/ buttonShortcutSystem;
	local xcb_generic_event_t * /*----------*/ event;
	local uint32 /*-------------------------*/ eventToken;
	local int /*----------------------------*/ keyPressNextOffset;
	local int /*----------------------------*/ keyReleaseNextOffset;
	local int /*----------------------------*/ buttonPressNextOffset;
	local int /*----------------------------*/ buttonReleaseNextOffset;
	local uint8 /*--------------------------*/ shortcutCode;
	local uint16 /*-------------------------*/ shortcutModifier;
	local bool /*---------------------------*/ expectingSecondKeyRelease;
	local uint8 /*--------------------------*/ realKeyReleaseModifier;

	local const char *const /*--------------*/ baseEventName[] = {"error", "unrecognized", "key press", "key release", "button press", "button release", "motion notify", "enter notify", "leave notify", "focus in", "focus out", "keymap notify", "expose", "graphics expose", "no expose", "visibility notify", "create notify", "destroy notify", "unmap notify", "map notify", "map request", "reparent notify", "configure notify", "configure request", "gravity notify", "resize request", "circulate notify", "circulate request", "property notify", "selection clear", "selection request", "selection notify", "colormap notify", "client message", "mapping notify", "generic event", "unrecognized"};
	local const char *const /*--------------*/ baseErrorName[] = {"unrecognized", "request", "value", "window", "pixmap", "atom", "cursor", "font", "match", "drawable", "access", "allocation", "colormap", "graphics context", "id choice", "name", "length", "implementation", "unrecognized"};
	local const char *const /*--------------*/ baseOperationName[] = {"unrecognized", "create window", "change window attributes", "get window attributes", "destroy window", "destroy subwindows", "change save set", "reparent window", "map window", "map subwindows", "unmap window", "unmap subwindows", "configure window", "circulate window", "get geometry", "query tree", "intern atom", "get atom name", "change property", "delete property", "get property", "list properties", "set selection owner", "get selection owner", "convert selection", "send event", "grab pointer", "ungrab pointer", "grab button", "ungrab button", "change active pointer grab", "grab keyboard", "ungrab keyboard", "grab key", "ungrab key", "allow events", "grab server", "ungrab server", "query pointer", "get motion events", "translate coordinates", "warp pointer", "set input focus", "get input focus", "query keymap", "open font", "close font", "query font", "query text extents", "list fonts", "list fonts with info", "set font path", "get font path", "create pixmap", "free pixmap", "create graphics context", "change graphics context", "copy graphics context", "set dashes", "set clip rectangles", "free graphics context", "clear area", "copy area", "copy plane", "poly point", "poly line", "poly segment", "poly rectangle", "poly arc", "fill poly", "poly fill rectangle", "poly fill arc", "put image", "get image", "poly text (8)", "poly text (16)", "image text (8)", "image text (16)", "create colormap", "free colormap", "copy colormap and free", "install colormap", "uninstall colormap", "list installed colormaps", "allocate color", "allocate named color", "allocate color cells", "allocate color planes", "free colors", "store colors", "store named color", "query colors", "lookup color", "create cursor", "create glyph cursor", "free cursor", "recolor cursor", "query best size", "query extension", "list extensions", "change keyboard mapping", "get keyboard mapping", "change keyboard control", "get keyboard control", "bell", "change pointer control", "get pointer control", "set screen saver", "get screen saver", "change hosts", "list hosts", "set access control", "set close down mode", "kill client", "rotate properties", "force screen saver", "set pointer mapping", "get pointer mapping", "set modifier mapping", "get modifier mapping", "unrecognized", "unrecognized", "unrecognized", "unrecognized", "unrecognized", "unrecognized", "unrecognized", "no", "unrecognized"};
	local const char *const /*--------------*/ randrEventName[] = {"screen change notify", "notify", "unrecognized"};
	local const char *const /*--------------*/ randrErrorName[] = {"bad output", "bad crtc", "bad mode", "bad provider", "unrecognized"};
	local const char *const /*--------------*/ randrOperationName[] = {"query version", "unrecognized", "set screen config", "unrecognized", "select input", "get screen info", "get screen size range", "set screen size", "get screen resources", "get output info", "list output properties", "query output property", "configure output property", "change output property", "delete output property", "get output property", "create mode", "destroy mode", "add output mode", "delete output mode", "get crtc info", "set crtc config", "get crtc gamma size", "get crtc gamma", "set crtc gamma", "get screen resources current", "set crtc transform", "get crtc transform", "get panning", "set panning", "set output primary", "get output primary", "get providers", "get provider info", "set provider offload sink", "set provider output source", "list provider properties", "query provider property", "configure provider property", "change provider property", "delete provider property", "get provider property", "get monitors", "set monitor", "delete monitor", "create lease", "free lease", "unrecognized"};
	local const char *const /*--------------*/ shapeEventName[] = {"notify", "unrecognized"};
	local const char *const /*--------------*/ shapeErrorName[] = {"unrecognized"};
	local const char *const /*--------------*/ shapeOperationName[] = {"query version", "rectangles", "mask", "combine", "offset", "query extents", "select input", "input selected", "get rectangles", "unrecognized"};
	local const char *const /*--------------*/ xfixesEventName[] = {"selection notify", "cursor notify", "unrecognized"};
	local const char *const /*--------------*/ xfixesErrorName[] = {"bad region", "unrecognized"};
	local const char *const /*--------------*/ xfixesOperationName[] = {"query version", "change save set", "select selection input", "select cursor input", "get cursor image", "create region", "create region from bitmap", "create region from window", "create region from graphics context", "create region from picture", "destroy region", "set region", "copy region", "union region", "intersect region", "subtract region", "invert region", "translate region", "region extents", "fetch region", "set graphics context clip region", "set window shape region", "set picture clip region", "set cursor name", "get cursor name", "get cursor image and name", "change cursor", "change cursor by name", "expand region", "hide cursor", "show cursor", "create pointer barrier", "delete pointer barrier", "set client disconnect mode", "get client disconnect mode", "unrecognized"};

	local const char *const /*--------------*/ globalScopesInstructionList[] = STRING_CONTENT(GLOBAL_SCOPES_INSTRUCTION);
	local const char *const /*--------------*/ globalInstructionList[] = STRING_CONTENT(GLOBAL_INSTRUCTION);
	local const char *const /*--------------*/ scope1ScopeInstructionList[] = STRING_CONTENT(SCOPE1_SCOPE_INSTRUCTION);
	local const char *const /*--------------*/ booleanList[] = STRING_CONTENT(BOOLEAN);
	local const char *const /*--------------*/ variableList[] = STRING_CONTENT(VARIABLE);
	local const char *const /*--------------*/ commandList[] = STRING_CONTENT(COMMAND);
	local const char *const /*--------------*/ modifierList[] = STRING_CONTENT(MODIFIER);
	local const char *const /*--------------*/ shortcutStateList[] = STRING_CONTENT(SHORTCUT_STATE);
	local const char *const /*--------------*/ numberTypeList[] = STRING_CONTENT(NUMBER_TYPE);
	local const char *const /*--------------*/ horizontalAlignmentList[] = STRING_CONTENT(HORIZONTAL_ALIGNMENT);
	local const char *const /*--------------*/ verticalAlignmentList[] = STRING_CONTENT(VERTICAL_ALIGNMENT);
	local const char *const /*--------------*/ cornerList[] = STRING_CONTENT(CORNER);
	local const char *const /*--------------*/ whichMonitorList[] = STRING_CONTENT(WHICH_MONITOR);
	local const char *const /*--------------*/ directionList[] = STRING_CONTENT(DIRECTION);
	local const char *const /*--------------*/ macroList[] = STRING_CONTENT(MACRO);

	local const Instruction /*--------------*/ helpInstruction[] = {END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ expandInstruction[] = {END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ contractInstruction[] = {END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ readConfigInstruction[] = {STRING_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ useTerminalInstruction[] = {NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ useMessengerInstruction[] = {NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ setInstruction[] = {NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ doInstruction[] = {NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ grabKeycodeInstruction[] = {NAME_LIST_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_LIST_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ grabButtonInstruction[] = {NAME_LIST_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_LIST_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ ungrabKeycodeInstruction[] = {NAME_LIST_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ ungrabButtonInstruction[] = {NAME_LIST_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ stopInstruction[] = {END_INSTRUCTION_TYPE};

	local const Instruction /*--------------*/ executeDoSubinstruction[] = {NAME_INSTRUCTION_TYPE, STRING_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ placeTopDoSubinstruction[] = {NAME_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ placeBottomDoSubinstruction[] = {NAME_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ placeLeftDoSubinstruction[] = {NAME_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ placeRightDoSubinstruction[] = {NAME_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ placeTopLeftDoSubinstruction[] = {NAME_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ placeTopRightDoSubinstruction[] = {NAME_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ placeBottomLeftDoSubinstruction[] = {NAME_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ placeBottomRightDoSubinstruction[] = {NAME_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ placeCenterDoSubinstruction[] = {NAME_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ placeFullDoSubinstruction[] = {NAME_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ moveDoSubinstruction[] = {NAME_INSTRUCTION_TYPE, NAME_LIST_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ resizeDoSubinstruction[] = {NAME_INSTRUCTION_TYPE, NAME_LIST_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ enterMaximizedDoSubinstruction[] = {NAME_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ toggleMaximizedDoSubinstruction[] = {NAME_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ enterFullscreenDoSubinstruction[] = {NAME_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ toggleFullscreenDoSubinstruction[] = {NAME_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ goToWorkspaceDoSubinstruction[] = {NAME_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ moveWindowToWorkspaceDoSubinstruction[] = {NAME_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ goToWorkspaceWithWindowDoSubinstruction[] = {NAME_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ executeGrabKeycodeSubinstruction[] = {NAME_LIST_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_LIST_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, STRING_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ placeTopGrabKeycodeSubinstruction[] = {NAME_LIST_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_LIST_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ placeBottomGrabKeycodeSubinstruction[] = {NAME_LIST_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_LIST_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ placeLeftGrabKeycodeSubinstruction[] = {NAME_LIST_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_LIST_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ placeRightGrabKeycodeSubinstruction[] = {NAME_LIST_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_LIST_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ placeTopLeftGrabKeycodeSubinstruction[] = {NAME_LIST_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_LIST_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ placeTopRightGrabKeycodeSubinstruction[] = {NAME_LIST_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_LIST_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ placeBottomLeftGrabKeycodeSubinstruction[] = {NAME_LIST_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_LIST_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ placeBottomRightGrabKeycodeSubinstruction[] = {NAME_LIST_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_LIST_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ placeCenterGrabKeycodeSubinstruction[] = {NAME_LIST_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_LIST_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ placeFullGrabKeycodeSubinstruction[] = {NAME_LIST_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_LIST_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ moveGrabKeycodeSubinstruction[] = {NAME_LIST_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_LIST_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, NAME_LIST_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ resizeGrabKeycodeSubinstruction[] = {NAME_LIST_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_LIST_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, NAME_LIST_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ enterMaximizedGrabKeycodeSubinstruction[] = {NAME_LIST_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_LIST_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ toggleMaximizedGrabKeycodeSubinstruction[] = {NAME_LIST_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_LIST_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ enterFullscreenGrabKeycodeSubinstruction[] = {NAME_LIST_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_LIST_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ toggleFullscreenGrabKeycodeSubinstruction[] = {NAME_LIST_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_LIST_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ goToWorkspaceGrabKeycodeSubinstruction[] = {NAME_LIST_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_LIST_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ moveWindowToWorkspaceGrabKeycodeSubinstruction[] = {NAME_LIST_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_LIST_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ goToWorkspaceWithWindowGrabKeycodeSubinstruction[] = {NAME_LIST_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_LIST_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ executeGrabButtonSubinstruction[] = {NAME_LIST_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_LIST_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, STRING_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ placeTopGrabButtonSubinstruction[] = {NAME_LIST_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_LIST_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ placeBottomGrabButtonSubinstruction[] = {NAME_LIST_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_LIST_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ placeLeftGrabButtonSubinstruction[] = {NAME_LIST_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_LIST_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ placeRightGrabButtonSubinstruction[] = {NAME_LIST_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_LIST_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ placeTopLeftGrabButtonSubinstruction[] = {NAME_LIST_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_LIST_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ placeTopRightGrabButtonSubinstruction[] = {NAME_LIST_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_LIST_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ placeBottomLeftGrabButtonSubinstruction[] = {NAME_LIST_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_LIST_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ placeBottomRightGrabButtonSubinstruction[] = {NAME_LIST_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_LIST_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ placeCenterGrabButtonSubinstruction[] = {NAME_LIST_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_LIST_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ placeFullGrabButtonSubinstruction[] = {NAME_LIST_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_LIST_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ moveGrabButtonSubinstruction[] = {NAME_LIST_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_LIST_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, NAME_LIST_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ resizeGrabButtonSubinstruction[] = {NAME_LIST_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_LIST_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, NAME_LIST_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ enterMaximizedGrabButtonSubinstruction[] = {NAME_LIST_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_LIST_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ toggleMaximizedGrabButtonSubinstruction[] = {NAME_LIST_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_LIST_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ enterFullscreenGrabButtonSubinstruction[] = {NAME_LIST_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_LIST_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ toggleFullscreenGrabButtonSubinstruction[] = {NAME_LIST_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_LIST_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ goToWorkspaceGrabButtonSubinstruction[] = {NAME_LIST_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_LIST_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ moveWindowToWorkspaceGrabButtonSubinstruction[] = {NAME_LIST_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_LIST_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};
	local const Instruction /*--------------*/ goToWorkspaceWithWindowGrabButtonSubinstruction[] = {NAME_LIST_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, NAME_LIST_INSTRUCTION_TYPE, NAME_INSTRUCTION_TYPE, NUMBER_INSTRUCTION_TYPE, END_INSTRUCTION_TYPE};

	local StringTreeSystem *const *const /*-*/ helpInstructionData = NULL;
	local StringTreeSystem *const *const /*-*/ expandInstructionData = NULL;
	local StringTreeSystem *const *const /*-*/ contractInstructionData = NULL;
	local StringTreeSystem *const *const /*-*/ readConfigInstructionData = NULL;
	local StringTreeSystem *const /*--------*/ useTerminalInstructionData[] = {&booleanStringTreeSystem};
	local StringTreeSystem *const /*--------*/ useMessengerInstructionData[] = {&booleanStringTreeSystem};
	local StringTreeSystem *const /*--------*/ setInstructionData[] = {&variableStringTreeSystem};
	local StringTreeSystem *const /*--------*/ doInstructionData[] = {&commandStringTreeSystem};
	local StringTreeSystem *const /*--------*/ grabKeycodeInstructionData[] = {&modifierStringTreeSystem, &shortcutStateStringTreeSystem, &commandStringTreeSystem};
	local StringTreeSystem *const /*--------*/ grabButtonInstructionData[] = {&modifierStringTreeSystem, &shortcutStateStringTreeSystem, &commandStringTreeSystem};
	local StringTreeSystem *const /*--------*/ ungrabKeycodeInstructionData[] = {&modifierStringTreeSystem};
	local StringTreeSystem *const /*--------*/ ungrabButtonInstructionData[] = {&modifierStringTreeSystem};
	local StringTreeSystem *const *const /*-*/ stopInstructionData = NULL;

	local StringTreeSystem *const /*--------*/ executeDoSubinstructionData[] = {&commandStringTreeSystem};
	local StringTreeSystem *const /*--------*/ placeTopDoSubinstructionData[] = {&commandStringTreeSystem, &whichMonitorStringTreeSystem};
	local StringTreeSystem *const /*--------*/ placeBottomDoSubinstructionData[] = {&commandStringTreeSystem, &whichMonitorStringTreeSystem};
	local StringTreeSystem *const /*--------*/ placeLeftDoSubinstructionData[] = {&commandStringTreeSystem, &whichMonitorStringTreeSystem};
	local StringTreeSystem *const /*--------*/ placeRightDoSubinstructionData[] = {&commandStringTreeSystem, &whichMonitorStringTreeSystem};
	local StringTreeSystem *const /*--------*/ placeTopLeftDoSubinstructionData[] = {&commandStringTreeSystem, &whichMonitorStringTreeSystem};
	local StringTreeSystem *const /*--------*/ placeTopRightDoSubinstructionData[] = {&commandStringTreeSystem, &whichMonitorStringTreeSystem};
	local StringTreeSystem *const /*--------*/ placeBottomLeftDoSubinstructionData[] = {&commandStringTreeSystem, &whichMonitorStringTreeSystem};
	local StringTreeSystem *const /*--------*/ placeBottomRightDoSubinstructionData[] = {&commandStringTreeSystem, &whichMonitorStringTreeSystem};
	local StringTreeSystem *const /*--------*/ placeCenterDoSubinstructionData[] = {&commandStringTreeSystem, &whichMonitorStringTreeSystem};
	local StringTreeSystem *const /*--------*/ placeFullDoSubinstructionData[] = {&commandStringTreeSystem, &whichMonitorStringTreeSystem};
	local StringTreeSystem *const /*--------*/ moveDoSubinstructionData[] = {&commandStringTreeSystem, &directionStringTreeSystem};
	local StringTreeSystem *const /*--------*/ resizeDoSubinstructionData[] = {&commandStringTreeSystem, &directionStringTreeSystem};
	local StringTreeSystem *const /*--------*/ enterMaximizedDoSubinstructionData[] = {&commandStringTreeSystem, &whichMonitorStringTreeSystem};
	local StringTreeSystem *const /*--------*/ toggleMaximizedDoSubinstructionData[] = {&commandStringTreeSystem, &whichMonitorStringTreeSystem};
	local StringTreeSystem *const /*--------*/ enterFullscreenDoSubinstructionData[] = {&commandStringTreeSystem, &whichMonitorStringTreeSystem};
	local StringTreeSystem *const /*--------*/ toggleFullscreenDoSubinstructionData[] = {&commandStringTreeSystem, &whichMonitorStringTreeSystem};
	local StringTreeSystem *const /*--------*/ goToWorkspaceDoSubinstructionData[] = {&commandStringTreeSystem};
	local StringTreeSystem *const /*--------*/ moveWindowToWorkspaceDoSubinstructionData[] = {&commandStringTreeSystem};
	local StringTreeSystem *const /*--------*/ goToWorkspaceWithWindowDoSubinstructionData[] = {&commandStringTreeSystem};
	local StringTreeSystem *const /*--------*/ executeGrabKeycodeSubinstructionData[] = {&modifierStringTreeSystem, &shortcutStateStringTreeSystem, &commandStringTreeSystem};
	local StringTreeSystem *const /*--------*/ placeTopGrabKeycodeSubinstructionData[] = {&modifierStringTreeSystem, &shortcutStateStringTreeSystem, &commandStringTreeSystem, &whichMonitorStringTreeSystem};
	local StringTreeSystem *const /*--------*/ placeBottomGrabKeycodeSubinstructionData[] = {&modifierStringTreeSystem, &shortcutStateStringTreeSystem, &commandStringTreeSystem, &whichMonitorStringTreeSystem};
	local StringTreeSystem *const /*--------*/ placeLeftGrabKeycodeSubinstructionData[] = {&modifierStringTreeSystem, &shortcutStateStringTreeSystem, &commandStringTreeSystem, &whichMonitorStringTreeSystem};
	local StringTreeSystem *const /*--------*/ placeRightGrabKeycodeSubinstructionData[] = {&modifierStringTreeSystem, &shortcutStateStringTreeSystem, &commandStringTreeSystem, &whichMonitorStringTreeSystem};
	local StringTreeSystem *const /*--------*/ placeTopLeftGrabKeycodeSubinstructionData[] = {&modifierStringTreeSystem, &shortcutStateStringTreeSystem, &commandStringTreeSystem, &whichMonitorStringTreeSystem};
	local StringTreeSystem *const /*--------*/ placeTopRightGrabKeycodeSubinstructionData[] = {&modifierStringTreeSystem, &shortcutStateStringTreeSystem, &commandStringTreeSystem, &whichMonitorStringTreeSystem};
	local StringTreeSystem *const /*--------*/ placeBottomLeftGrabKeycodeSubinstructionData[] = {&modifierStringTreeSystem, &shortcutStateStringTreeSystem, &commandStringTreeSystem, &whichMonitorStringTreeSystem};
	local StringTreeSystem *const /*--------*/ placeBottomRightGrabKeycodeSubinstructionData[] = {&modifierStringTreeSystem, &shortcutStateStringTreeSystem, &commandStringTreeSystem, &whichMonitorStringTreeSystem};
	local StringTreeSystem *const /*--------*/ placeCenterGrabKeycodeSubinstructionData[] = {&modifierStringTreeSystem, &shortcutStateStringTreeSystem, &commandStringTreeSystem, &whichMonitorStringTreeSystem};
	local StringTreeSystem *const /*--------*/ placeFullGrabKeycodeSubinstructionData[] = {&modifierStringTreeSystem, &shortcutStateStringTreeSystem, &commandStringTreeSystem, &whichMonitorStringTreeSystem};
	local StringTreeSystem *const /*--------*/ moveGrabKeycodeSubinstructionData[] = {&modifierStringTreeSystem, &shortcutStateStringTreeSystem, &commandStringTreeSystem, &directionStringTreeSystem};
	local StringTreeSystem *const /*--------*/ resizeGrabKeycodeSubinstructionData[] = {&modifierStringTreeSystem, &shortcutStateStringTreeSystem, &commandStringTreeSystem, &directionStringTreeSystem};
	local StringTreeSystem *const /*--------*/ enterMaximizedGrabKeycodeSubinstructionData[] = {&modifierStringTreeSystem, &shortcutStateStringTreeSystem, &commandStringTreeSystem, &whichMonitorStringTreeSystem};
	local StringTreeSystem *const /*--------*/ toggleMaximizedGrabKeycodeSubinstructionData[] = {&modifierStringTreeSystem, &shortcutStateStringTreeSystem, &commandStringTreeSystem, &whichMonitorStringTreeSystem};
	local StringTreeSystem *const /*--------*/ enterFullscreenGrabKeycodeSubinstructionData[] = {&modifierStringTreeSystem, &shortcutStateStringTreeSystem, &commandStringTreeSystem, &whichMonitorStringTreeSystem};
	local StringTreeSystem *const /*--------*/ toggleFullscreenGrabKeycodeSubinstructionData[] = {&modifierStringTreeSystem, &shortcutStateStringTreeSystem, &commandStringTreeSystem, &whichMonitorStringTreeSystem};
	local StringTreeSystem *const /*--------*/ goToWorkspaceGrabKeycodeSubinstructionData[] = {&modifierStringTreeSystem, &shortcutStateStringTreeSystem, &commandStringTreeSystem};
	local StringTreeSystem *const /*--------*/ moveWindowToWorkspaceGrabKeycodeSubinstructionData[] = {&modifierStringTreeSystem, &shortcutStateStringTreeSystem, &commandStringTreeSystem};
	local StringTreeSystem *const /*--------*/ goToWorkspaceWithWindowGrabKeycodeSubinstructionData[] = {&modifierStringTreeSystem, &shortcutStateStringTreeSystem, &commandStringTreeSystem};
	local StringTreeSystem *const /*--------*/ executeGrabButtonSubinstructionData[] = {&modifierStringTreeSystem, &shortcutStateStringTreeSystem, &commandStringTreeSystem};
	local StringTreeSystem *const /*--------*/ placeTopGrabButtonSubinstructionData[] = {&modifierStringTreeSystem, &shortcutStateStringTreeSystem, &commandStringTreeSystem, &whichMonitorStringTreeSystem};
	local StringTreeSystem *const /*--------*/ placeBottomGrabButtonSubinstructionData[] = {&modifierStringTreeSystem, &shortcutStateStringTreeSystem, &commandStringTreeSystem, &whichMonitorStringTreeSystem};
	local StringTreeSystem *const /*--------*/ placeLeftGrabButtonSubinstructionData[] = {&modifierStringTreeSystem, &shortcutStateStringTreeSystem, &commandStringTreeSystem, &whichMonitorStringTreeSystem};
	local StringTreeSystem *const /*--------*/ placeRightGrabButtonSubinstructionData[] = {&modifierStringTreeSystem, &shortcutStateStringTreeSystem, &commandStringTreeSystem, &whichMonitorStringTreeSystem};
	local StringTreeSystem *const /*--------*/ placeTopLeftGrabButtonSubinstructionData[] = {&modifierStringTreeSystem, &shortcutStateStringTreeSystem, &commandStringTreeSystem, &whichMonitorStringTreeSystem};
	local StringTreeSystem *const /*--------*/ placeTopRightGrabButtonSubinstructionData[] = {&modifierStringTreeSystem, &shortcutStateStringTreeSystem, &commandStringTreeSystem, &whichMonitorStringTreeSystem};
	local StringTreeSystem *const /*--------*/ placeBottomLeftGrabButtonSubinstructionData[] = {&modifierStringTreeSystem, &shortcutStateStringTreeSystem, &commandStringTreeSystem, &whichMonitorStringTreeSystem};
	local StringTreeSystem *const /*--------*/ placeBottomRightGrabButtonSubinstructionData[] = {&modifierStringTreeSystem, &shortcutStateStringTreeSystem, &commandStringTreeSystem, &whichMonitorStringTreeSystem};
	local StringTreeSystem *const /*--------*/ placeCenterGrabButtonSubinstructionData[] = {&modifierStringTreeSystem, &shortcutStateStringTreeSystem, &commandStringTreeSystem, &whichMonitorStringTreeSystem};
	local StringTreeSystem *const /*--------*/ placeFullGrabButtonSubinstructionData[] = {&modifierStringTreeSystem, &shortcutStateStringTreeSystem, &commandStringTreeSystem, &whichMonitorStringTreeSystem};
	local StringTreeSystem *const /*--------*/ moveGrabButtonSubinstructionData[] = {&modifierStringTreeSystem, &shortcutStateStringTreeSystem, &commandStringTreeSystem, &directionStringTreeSystem};
	local StringTreeSystem *const /*--------*/ resizeGrabButtonSubinstructionData[] = {&modifierStringTreeSystem, &shortcutStateStringTreeSystem, &commandStringTreeSystem, &directionStringTreeSystem};
	local StringTreeSystem *const /*--------*/ enterMaximizedGrabButtonSubinstructionData[] = {&modifierStringTreeSystem, &shortcutStateStringTreeSystem, &commandStringTreeSystem, &whichMonitorStringTreeSystem};
	local StringTreeSystem *const /*--------*/ toggleMaximizedGrabButtonSubinstructionData[] = {&modifierStringTreeSystem, &shortcutStateStringTreeSystem, &commandStringTreeSystem, &whichMonitorStringTreeSystem};
	local StringTreeSystem *const /*--------*/ enterFullscreenGrabButtonSubinstructionData[] = {&modifierStringTreeSystem, &shortcutStateStringTreeSystem, &commandStringTreeSystem, &whichMonitorStringTreeSystem};
	local StringTreeSystem *const /*--------*/ toggleFullscreenGrabButtonSubinstructionData[] = {&modifierStringTreeSystem, &shortcutStateStringTreeSystem, &commandStringTreeSystem, &whichMonitorStringTreeSystem};
	local StringTreeSystem *const /*--------*/ goToWorkspaceGrabButtonSubinstructionData[] = {&modifierStringTreeSystem, &shortcutStateStringTreeSystem, &commandStringTreeSystem};
	local StringTreeSystem *const /*--------*/ moveWindowToWorkspaceGrabButtonSubinstructionData[] = {&modifierStringTreeSystem, &shortcutStateStringTreeSystem, &commandStringTreeSystem};
	local StringTreeSystem *const /*--------*/ goToWorkspaceWithWindowGrabButtonSubinstructionData[] = {&modifierStringTreeSystem, &shortcutStateStringTreeSystem, &commandStringTreeSystem};

	#define getInstruction(i) /*-----*/ (i##Instruction)
	#define getInstructionData(i) /*-*/ (i##InstructionData)
	#define getGlobalScope(i) /*-----*/ { \
		  get##i(help) \
		, get##i(expand) \
		, get##i(contract) \
		, get##i(readConfig) \
		, get##i(useTerminal) \
		, get##i(useMessenger) \
		, get##i(set) \
		, get##i(do) \
		, get##i(grabKeycode) \
		, get##i(grabButton) \
		, get##i(ungrabKeycode) \
		, get##i(ungrabButton) \
		, get##i(stop) \
	}
	#define getScope1Scope(i) /*-----*/ { \
		  get##i(help) \
		, get##i(expand) \
		, get##i(contract) \
		, get##i(stop) \
	}
	local const Instruction *const /*-------*/ globalScopeInstruction[] = getGlobalScope(Instruction);
	local const Instruction *const /*-------*/ scope1ScopeInstruction[] = getScope1Scope(Instruction);

	local StringTreeSystem *const *const /*-*/ globalScopeInstructionData[] = getGlobalScope(InstructionData);
	local StringTreeSystem *const *const /*-*/ scope1ScopeInstructionData[] = getScope1Scope(InstructionData);
	#undef  getScope1Scope
	#undef  getGlobalScope
	#undef  getInstructionData
	#undef  getInstruction
/*!}*/

/*!functions:{*/
	QUIT();
	REAPSPAWNEDPROCESSES();
	INITMEMORYSYSTEM();
	PUSHPOINTER();
	POPPOINTER();
	UPDATEPOINTER();
	IFREE();
	IXCBDISCONNECT();
	ISHMCTL();
	FINIMEMORYSYSTEM();
	INITPERMISSIONSYSTEM();
	SETPERMISSIONS();
	LOWERPERMISSIONS();
	RAISEPERMISSIONS();
	DROPPERMISSIONS();
	FINIPERMISSIONSYSTEM();
	IDENTIFYARGUMENT();
	INSENSITIVESTRINGCOMPARE();
	SENSITIVESTRINGCOMPARE();
	RANDRQUERYVERSIONUNCHECKED();
	SHAPEQUERYVERSIONUNCHECKED();
	XFIXESQUERYVERSIONUNCHECKED();
	INITMONITORSYSTEM();
	CREATEMONITORS();
	GETWHICHMONITOR();
	DESTROYMONITORS();
	FINDPOINTERMONITOR();
	FINDRECTANGLEMONITOR();
	FINDWINDOWMONITOR();
	FINIMONITORSYSTEM();
	INITPOINTERSYSTEM();
	SETPOINTER();
	FINIPOINTERSYSTEM();
	INITCURSORSYSTEM();
	SETCURSOR();
	FINICURSORSYSTEM();
	INITWALLPAPERSYSTEM();
	SETWALLPAPERCOLOR();
	SETWALLPAPERPIXMAP();
	CREATEWALLPAPER();
	FINIWALLPAPERSYSTEM();
	INITCLIENTSYSTEM();
	CREATECLIENT();
	SETDEFAULTCLIENTWINDOWTYPE();
	UPDATECLIENTSTATE();
	CHANGECLIENTSTATE();
	SETCLIENTALLOWEDACTIONS();
	CHANGECLIENTALLOWEDACTIONS();
	SETCLIENTORDERTYPE();
	MOVERESIZECLIENT();
	SENDCLIENTCONFIGUREEVENT();
	RESTACKCLIENT();
	CONFIGURECLIENT();
	ASSIGNCLIENTSTRUT();
	GETFOCUSEDCLIENT();
	SETFOCUSEDCLIENT();
	OFFERCLIENTFOCUS();
	FOCUSCLIENT();
	CHANGEACTIVEWINDOW();
	SETMOTIONCLIENT();
	UNSETMOTIONCLIENT();
	CLOSECLIENT();
	LOSEFOCUS();
	UNFOCUSCLIENT();
	UNMAPCLIENT();
	DESTROYCLIENT();
	ISVALIDCLIENT();
	FINDCLIENTWINDOW();
	FINDCLIENTCONTAINER();
	FINDCONFIGUREDCLIENTWINDOW();
	FINDORDEREDCLIENTOFFSET();
	FINDBELOWCLIENT();
	FINDABOVEDESKTOPCLIENT();
	FINDBELOWDESKTOPCLIENT();
	FINDMODALTRANSIENTFORCLIENT();
	FINDBELOWMANAGEDCLIENT();
	FINICLIENTSYSTEM();
	INITVIRTUALROOTSYSTEM();
	SETVIRTUALROOTAMOUNT();
	SETVIRTUALROOTWORKAREA();
	CHANGEVIRTUALROOTWORKAREA();
	SETVIRTUALROOTNAMES();
	SETVIRTUALROOTNAME();
	SETVIRTUALROOTNUMBERNAME();
	GOTOVIRTUALROOT();
	CONFIGUREFULLSCREENVIRTUALROOTCLIENTS();
	RESIZEVIRTUALROOT();
	SETVIRTUALROOTGLOBALEDGEOFFSET();
	SETVIRTUALROOTWALLPAPER();
	RESTACKVIRTUALROOTBELOW();
	MAPVIRTUALROOTS();
	SETCLIENTVIRTUALROOT();
	CHANGEVIRTUALROOTCLIENTDESKTOP();
	MOVECLIENTTOVIRTUALROOT();
	CONFIGUREVIRTUALROOTCLIENT();
	RESTACKVIRTUALROOTCLIENT();
	ADDVIRTUALROOTCLIENTWORKAREA();
	UPDATEVIRTUALROOTSTRUTEDCLIENTS();
	REMOVEVIRTUALROOTCLIENTWORKAREA();
	MAXIMIZECLIENT();
	UNMAXIMIZECLIENT();
	FULLSCREENCLIENT();
	UNFULLSCREENCLIENT();
	MOVERESIZEWORKAREACLIENT();
	UPDATEVIRTUALROOTWORKAREACLIENT();
	UPDATEVIRTUALROOTWORKAREACLIENTS();
	SHOWVIRTUALROOTDESKTOP();
	DESTROYVIRTUALROOT();
	ISVALIDVIRTUALROOT();
	FINDVIRTUALROOT();
	FINDORDEREDVIRTUALROOTCLIENTOFFSET();
	FINDPOSITIONEDORDEREDVIRTUALROOTCLIENT();
	FINIVIRTUALROOTSYSTEM();
	INITCLIENTLISTSYSTEM();
	SETCLIENTLISTPROPERTY();
	ADDCLIENTLISTWINDOW();
	CONFIGURECLIENTLISTCLIENT();
	RESTACKCLIENTLISTWINDOW();
	CHANGECLIENTLISTPROPERTY();
	REMOVECLIENTLISTWINDOW();
	FINDCLIENTLISTWINDOW();
	FINICLIENTLISTSYSTEM();
	INITWINDOWMANAGERSYSTEM();
	SETNETSUPPORTED();
	STORECLIENTPROPERTIES();
	STORECLIENTPROPERTY();
	REALLOCATEPROPERTY();
	UNSTORECLIENTPROPERTY();
	FINDOWNEDWINDOW();
	FINIWINDOWMANAGERSYSTEM();
	SETELEMENTPREFERENCES();
	INITWINDOWSYSTEM();
	CREATEWINDOWCIRCLEPIXMAP();
	CREATEWINDOWS();
	MAPWINDOWS();
	CONFIGUREWINDOWS();
	DRAWWINDOWS();
	SETWINDOWPROPERTIES();
	DRAWWINDOW();
	UNMAPWINDOWS();
	DESTROYWINDOWS();
	GETRECTANGLE();
	GETTYPEDNUMBER();
	FINDWINDOW();
	FINIWINDOWSYSTEM();
	INITSLEEPTHREADSYSTEM();
	SETSLEEPTHREADOPERATION();
	SETSLEEPTHREADSLEEPTIME();
	BOOTSLEEPTHREAD();
	SIGNALSLEEPTHREAD();
	SLEEPTHREADMAIN();
	QUITSLEEPTHREAD();
	FINISLEEPTHREADSYSTEM();
	INITSTRINGTREESYSTEM();
	BULKINSERTSTRING();
	INSERTSTRING();
	GETSTRINGTREENODE();
	FINDSTRINGTREESTRING();
	FINISTRINGTREESYSTEM();
	INITSTDINSYSTEM();
	CONNECTSTDIN();
	STDINMAIN();
	GETNEXTSTDINCHARACTER();
	GETPREVIOUSSTDINCHARACTER();
	DISCONNECTSTDIN();
	FINISTDINSYSTEM();
	INITSHAREDMEMORYSYSTEM();
	CONNECTSHAREDMEMORY();
	SHAREDMEMORYMAIN();
	GETNEXTSHAREDMEMORYCHARACTER();
	GETPREVIOUSSHAREDMEMORYCHARACTER();
	DISCONNECTSHAREDMEMORY();
	FINISHAREDMEMORYSYSTEM();
	INITSHORTCUTSYSTEM();
	INSERTSHORTCUT();
	GETNEXTSHORTCUT();
	REMOVESHORTCUT();
	FINISHORTCUTSYSTEM();
	SETCONFIGVARIABLES();
	READCONFIG();
	IFGETC();
	MATCHNAMELIST();
	MATCHINTEGER();
	MATCHSTRING();
	MATCHIMAGE();
	MATCHCOMMAND();
	UNGRABSHORTCUTS();
	FREECONFIGVARIABLES();
	SETMEMORY();
	COPYMEMORY();
	SHIFTMEMORY();
	COMPAREMEMORY();
	FINDSTRINGLENGTH();
	FINDSUBSTRING();
	UTF8TOUCS2();
	INTERSECTS();
	GETINTERSECTION();
	LOADFILE();
	SPAWNPROCESS();
	CREATECIRCLE();
	COMPOSITEIMAGES();
	COMPOSITEIMAGESOVER();
	COMPOSITEIMAGESAND();
	TWOPASSBOXBLUR();
	ROTATEIMAGE();
	XCB_SYNC();
	GETTIMESTAMP();
	GETWINDOWCLASS();
	GETFOCUSEDWINDOW();
	GRABDEVICE();
	UNGRABDEVICE();
	FILLDRAWABLE();
	SETCLIPPINGRECTANGLE();
	TIGHTENCLIPPINGRECTANGLE();
	UNSETCLIPPINGRECTANGLE();
	RESTART();
	CLEANUP();
	CANCELTHREADS();
	PRINTUNACCOUNTEDFORPOINTERS();
	PRINTERROR();
	PRINTTITLEDERROR();
	PRINTTITLEDQUOTEDERROR();
	PRINTCONNECTIONERROR();
	PRINTTITLEDNAMEDERROR();
	PRINTXERROR();
	PRINTTITLEDVALUEDERROR();
	PRINTCONFIGERROR();
	OPENERRORSTREAM();
	CLOSEERRORSTREAM();
/*!}*/









#define CONTAINER_EVENT_MASK /*---------------------------*/ (XCB_EVENT_MASK_ENTER_WINDOW | XCB_EVENT_MASK_RESIZE_REDIRECT | XCB_EVENT_MASK_SUBSTRUCTURE_NOTIFY | XCB_EVENT_MASK_SUBSTRUCTURE_REDIRECT | XCB_EVENT_MASK_PROPERTY_CHANGE)
#define WINDOW_EVENT_MASK /*------------------------------*/ (XCB_EVENT_MASK_STRUCTURE_NOTIFY | XCB_EVENT_MASK_FOCUS_CHANGE | XCB_EVENT_MASK_PROPERTY_CHANGE | XCB_EVENT_MASK_COLOR_MAP_CHANGE)

#define NONE_MOTION_ACTION /*-----------------------------*/ (0)
#define MOVE_MOTION_ACTION /*-----------------------------*/ (1)
#define RESIZE_MOTION_ACTION /*---------------------------*/ (2)

#define NONE_NORMAL_HINT /*-------------------------------*/ (b(0000000000))
#define USER_POSITION_NORMAL_HINT /*----------------------*/ (b(0000000001))
#define USER_SIZE_NORMAL_HINT /*--------------------------*/ (b(0000000010))
#define PROGRAM_POSITION_NORMAL_HINT /*-------------------*/ (b(0000000100))
#define PROGRAM_SIZE_NORMAL_HINT /*-----------------------*/ (b(0000001000))
#define PROGRAM_MINIMUM_SIZE_NORMAL_HINT /*---------------*/ (b(0000010000))
#define PROGRAM_MAXIMUM_SIZE_NORMAL_HINT /*---------------*/ (b(0000100000))
#define PROGRAM_RESIZE_INCREMENT_NORMAL_HINT /*-----------*/ (b(0001000000))
#define PROGRAM_ASPECT_NORMAL_HINT /*---------------------*/ (b(0010000000))
#define PROGRAM_BASE_SIZE_NORMAL_HINT /*------------------*/ (b(0100000000))
#define PROGRAM_WINDOW_GRAVITY_NORMAL_HINT /*-------------*/ (b(1000000000))

#define NONE_HINT /*--------------------------------------*/ (b(000000000))
#define INPUT_HINT /*-------------------------------------*/ (b(000000001))
#define STATE_HINT /*-------------------------------------*/ (b(000000010))
#define ICON_PIXMAP_HINT /*-------------------------------*/ (b(000000100))
#define ICON_WINDOW_HINT /*-------------------------------*/ (b(000001000))
#define ICON_POSITION_HINT /*-----------------------------*/ (b(000010000))
#define ICON_MASK_HINT /*---------------------------------*/ (b(000100000))
#define WINDOW_GROUP_HINT /*------------------------------*/ (b(001000000))
#define URGENCY_HINT /*-----------------------------------*/ (b(100000000))

#define WITHDRAWN_STATE /*--------------------------------*/ (0)
#define NORMAL_STATE /*-----------------------------------*/ (1)
#define ICONIC_STATE /*-----------------------------------*/ (3)

#define SIZE_TOPLEFT_MOVERESIZE /*------------------------*/ (0)
#define SIZE_TOP_MOVERESIZE /*----------------------------*/ (1)
#define SIZE_TOPRIGHT_MOVERESIZE /*-----------------------*/ (2)
#define SIZE_RIGHT_MOVERESIZE /*--------------------------*/ (3)
#define SIZE_BOTTOMRIGHT_MOVERESIZE /*--------------------*/ (4)
#define SIZE_BOTTOM_MOVERESIZE /*-------------------------*/ (5)
#define SIZE_BOTTOMLEFT_MOVERESIZE /*---------------------*/ (6)
#define SIZE_LEFT_MOVERESIZE /*---------------------------*/ (7)
#define MOVE_MOVERESIZE /*--------------------------------*/ (8)
#define SIZE_KEYBOARD_MOVERESIZE /*-----------------------*/ (9)
#define MOVE_KEYBOARD_MOVERESIZE /*-----------------------*/ (10)

#define CLIENT_BLOCK_SIZE /*------------------------------*/ (256)

#define NONE_DESKTOP /*-----------------------------------*/ (0xFFFFFFFE)

#define NONE_CLIENT_PROTOCOL /*---------------------------*/ (b(0000))
#define TAKE_FOCUS_CLIENT_PROTOCOL /*---------------------*/ (b(0001))
#define DELETE_WINDOW_CLIENT_PROTOCOL /*------------------*/ (b(0010))
#define PING_CLIENT_PROTOCOL /*---------------------------*/ (b(0100))
#define SYNC_CLIENT_PROTOCOL /*---------------------------*/ (b(1000))

#define NONE_WINDOW_TYPE /*-------------------------------*/ (b(00000000))
#define DESKTOP_WINDOW_TYPE /*----------------------------*/ (b(00000001))
#define DOCK_WINDOW_TYPE /*-------------------------------*/ (b(00000010))
#define TOOLBAR_WINDOW_TYPE /*----------------------------*/ (b(00000100))
#define MENU_WINDOW_TYPE /*-------------------------------*/ (b(00001000))
#define UTILITY_WINDOW_TYPE /*----------------------------*/ (b(00010000))
#define SPLASH_WINDOW_TYPE /*-----------------------------*/ (b(00100000))
#define DIALOG_WINDOW_TYPE /*-----------------------------*/ (b(01000000))
#define NORMAL_WINDOW_TYPE /*-----------------------------*/ (b(10000000))

#define NONE_STATE /*-------------------------------------*/ (b(000000000000))
#define MODAL_STATE /*------------------------------------*/ (b(000000000001))
#define STICKY_STATE /*-----------------------------------*/ (b(000000000010))
#define MAXIMIZED_HORZ_STATE /*---------------------------*/ (b(000000000100))
#define MAXIMIZED_VERT_STATE /*---------------------------*/ (b(000000001000))
#define SHADED_STATE /*-----------------------------------*/ (b(000000010000))
#define SKIP_TASKBAR_STATE /*-----------------------------*/ (b(000000100000))
#define SKIP_PAGER_STATE /*-------------------------------*/ (b(000001000000))
#define HIDDEN_STATE /*-----------------------------------*/ (b(000010000000))
#define FULLSCREEN_STATE /*-------------------------------*/ (b(000100000000))
#define ABOVE_STATE /*------------------------------------*/ (b(001000000000))
#define BELOW_STATE /*------------------------------------*/ (b(010000000000))
#define DEMANDS_ATTENTION_STATE /*------------------------*/ (b(100000000000))

#define NONE_ALLOWED_ACTION /*----------------------------*/ (b(0000000000))
#define MOVE_ALLOWED_ACTION /*----------------------------*/ (b(0000000001))
#define RESIZE_ALLOWED_ACTION /*--------------------------*/ (b(0000000010))
#define MINIMIZE_ALLOWED_ACTION /*------------------------*/ (b(0000000100))
#define SHADE_ALLOWED_ACTION /*---------------------------*/ (b(0000001000))
#define STICK_ALLOWED_ACTION /*---------------------------*/ (b(0000010000))
#define MAXIMIZE_HORZ_ALLOWED_ACTION /*-------------------*/ (b(0000100000))
#define MAXIMIZE_VERT_ALLOWED_ACTION /*-------------------*/ (b(0001000000))
#define FULLSCREEN_ALLOWED_ACTION /*----------------------*/ (b(0010000000))
#define CHANGE_DESKTOP_ALLOWED_ACTION /*------------------*/ (b(0100000000))
#define CLOSE_ALLOWED_ACTION /*---------------------------*/ (b(1000000000))

#define NONE_STRUT /*-------------------------------------*/ (0)
#define TOP_STRUT /*--------------------------------------*/ (1)
#define BOTTOM_STRUT /*-----------------------------------*/ (2)
#define LEFT_STRUT /*-------------------------------------*/ (3)
#define RIGHT_STRUT /*------------------------------------*/ (4)

#define NONE_USER_TIME /*---------------------------------*/ (0x100000000)
#define UNFOCUSED_USER_TIME /*----------------------------*/ (0)

#define NONE_PROPERTY_PREFERENCE /*-----------------------*/ (b(000))
#define NAME_PROPERTY_PREFERENCE /*-----------------------*/ (b(001))
#define ICON_NAME_PROPERTY_PREFERENCE /*------------------*/ (b(010))
#define STRUT_PROPERTY_PREFERENCE /*----------------------*/ (b(100))

#define NONE_ORDER_TYPE /*--------------------------------*/ (0)
#define FULLSCREEN_ORDER_TYPE /*--------------------------*/ (1)
#define ABOVE_ORDER_TYPE /*-------------------------------*/ (2)
#define DOCK_ORDER_TYPE /*--------------------------------*/ (3)
#define NORMAL_ORDER_TYPE /*------------------------------*/ (4)
#define BELOW_ORDER_TYPE /*-------------------------------*/ (5)
#define DESKTOP_ORDER_TYPE /*-----------------------------*/ (6)

#define NONE_CLIENT_OPTION /*-----------------------------*/ (b(0000))
#define OVERRIDE_REDIRECT_CLIENT_OPTION /*----------------*/ (b(0001))
#define TEMPORARILY_UNMAPPED_CLIENT_OPTION /*-------------*/ (b(0010))
#define HORIZONTALLY_MAXIMIZED_CLIENT_OPTION /*-----------*/ (b(0100))
#define VERTICALLY_MAXIMIZED_CLIENT_OPTION /*-------------*/ (b(1000))

#define _NET_WM_STATE_REMOVE /*---------------------------*/ (0)
#define _NET_WM_STATE_ADD /*------------------------------*/ (1)
#define _NET_WM_STATE_TOGGLE /*---------------------------*/ (2)

#define NONE_CLOSE_CLIENT_COMMAND /*----------------------*/ (0)
#define CLOSE_CLOSE_CLIENT_COMMAND /*---------------------*/ (1)
#define KILL_CLOSE_CLIENT_COMMAND /*----------------------*/ (2)

#define _NET_WM_ORIENTATION_HORZ /*-----------------------*/ (0)
#define _NET_WM_ORIENTATION_VERT /*-----------------------*/ (1)

#define _NET_WM_TOPLEFT /*--------------------------------*/ (0)
#define _NET_WM_TOPRIGHT /*-------------------------------*/ (1)
#define _NET_WM_BOTTOMRIGHT /*----------------------------*/ (2)
#define _NET_WM_BOTTOMLEFT /*-----------------------------*/ (3)

#define NONE_WORKAREA_POSITION /*-------------------------*/ (0)
#define TOP_WORKAREA_POSITION /*--------------------------*/ (1)
#define BOTTOM_WORKAREA_POSITION /*-----------------------*/ (2)
#define LEFT_WORKAREA_POSITION /*-------------------------*/ (3)
#define RIGHT_WORKAREA_POSITION /*------------------------*/ (4)
#define TOP_LEFT_WORKAREA_POSITION /*---------------------*/ (5)
#define TOP_RIGHT_WORKAREA_POSITION /*--------------------*/ (6)
#define BOTTOM_LEFT_WORKAREA_POSITION /*------------------*/ (7)
#define BOTTOM_RIGHT_WORKAREA_POSITION /*-----------------*/ (8)
#define CENTER_WORKAREA_POSITION /*-----------------------*/ (9)
#define FULL_WORKAREA_POSITION /*-------------------------*/ (10)

#define NONE_WINDOW_GRAVITY /*----------------------------*/ (0)
#define NORTH_POINT_WINDOW_GRAVITY /*---------------------*/ (1)
#define NORTH_SIDE_WINDOW_GRAVITY /*----------------------*/ (2)
#define SOUTH_POINT_WINDOW_GRAVITY /*---------------------*/ (3)
#define SOUTH_SIDE_WINDOW_GRAVITY /*----------------------*/ (4)
#define WEST_POINT_WINDOW_GRAVITY /*----------------------*/ (5)
#define WEST_SIDE_WINDOW_GRAVITY /*-----------------------*/ (6)
#define EAST_POINT_WINDOW_GRAVITY /*----------------------*/ (7)
#define EAST_SIDE_WINDOW_GRAVITY /*-----------------------*/ (8)
#define NORTH_WEST_POINT_WINDOW_GRAVITY /*----------------*/ (9)
#define NORTH_EAST_POINT_WINDOW_GRAVITY /*----------------*/ (10)
#define SOUTH_WEST_POINT_WINDOW_GRAVITY /*----------------*/ (11)
#define SOUTH_EAST_POINT_WINDOW_GRAVITY /*----------------*/ (12)
#define CENTER_POINT_WINDOW_GRAVITY /*--------------------*/ (13)

#define NONE_UPDATE_WORKAREA_ACTION /*--------------------*/ (0)
#define ADD_UPDATE_WORKAREA_ACTION /*---------------------*/ (1)
#define REMOVE_UPDATE_WORKAREA_ACTION /*------------------*/ (2)

#define CURSOR_GLYPH_CONTENT(k, v, n, p) /*---------------*/ { \
	  v(none)                              k(NONE##p) \
	, v(arrow)                             k(ARROW##p) \
	, v(arrow-down)                        k(ARROW_DOWN##p) \
	, v(arrow-up)                          k(ARROW_UP##p) \
	, v(boat)                              k(BOAT##p) \
	, v(bogosity)                          k(BOGOSITY##p) \
	, v(bottom-left-corner)                k(BOTTOM_LEFT_CORNER##p) \
	, v(bottom-right-corner)               k(BOTTOM_RIGHT_CORNER##p) \
	, v(bottom-side)                       k(BOTTOM_SIDE##p) \
	, v(bottom-tee)                        k(BOTTOM_TEE##p) \
	, v(box-spiral)                        k(BOX_SPIRAL##p) \
	, v(center-pointer)                    k(CENTER_POINTER##p) \
	, v(circle)                            k(CIRCLE##p) \
	, v(clock)                             k(CLOCK##p) \
	, v(coffee-mug)                        k(COFFEE_MUG##p) \
	, v(cross)                             k(CROSS##p) \
	, v(cross-reverse)                     k(CROSS_REVERSE##p) \
	, v(crosshair)                         k(CROSSHAIR##p) \
	, v(diamond-cross)                     k(DIAMOND_CROSS##p) \
	, v(dot)                               k(DOT##p) \
	, v(dot-box)                           k(DOT_BOX##p) \
	, v(double-arrow)                      k(DOUBLE_ARROW##p) \
	, v(draft-large)                       k(DRAFT_LARGE##p) \
	, v(draft-small)                       k(DRAFT_SMALL##p) \
	, v(draped-box)                        k(DRAPED_BOX##p) \
	, v(exchange)                          k(EXCHANGE##p) \
	, v(fleur)                             k(FLEUR##p) \
	, v(gobbler)                           k(GOBBLER##p) \
	, v(gumby)                             k(GUMBY##p) \
	, v(hand-1)                            k(HAND_1##p) \
	, v(hand-2)                            k(HAND_2##p) \
	, v(heart)                             k(HEART##p) \
	, v(icon)                              k(ICON##p) \
	, v(iron-cross)                        k(IRON_CROSS##p) \
	, v(left-pointer)                      k(LEFT_POINTER##p) \
	, v(left-side)                         k(LEFT_SIDE##p) \
	, v(left-tee)                          k(LEFT_TEE##p) \
	, v(left-button)                       k(LEFT_BUTTON##p) \
	, v(lower-left-angle)                  k(LOWER_LEFT_ANGLE##p) \
	, v(lower-right-angle)                 k(LOWER_RIGHT_ANGLE##p) \
	, v(man)                               k(MAN##p) \
	, v(middle-button)                     k(MIDDLE_BUTTON##p) \
	, v(mouse)                             k(MOUSE##p) \
	, v(pencil)                            k(PENCIL##p) \
	, v(pirate)                            k(PIRATE##p) \
	, v(plus)                              k(PLUS##p) \
	, v(question-arrow)                    k(QUESTION_ARROW##p) \
	, v(right-pointer)                     k(RIGHT_POINTER##p) \
	, v(right-side)                        k(RIGHT_SIDE##p) \
	, v(right-tee)                         k(RIGHT_TEE##p) \
	, v(right-button)                      k(RIGHT_BUTTON##p) \
	, v(rtl-logo)                          k(RTL_LOGO##p) \
	, v(sailboat)                          k(SAILBOAT##p) \
	, v(scrollbar-down-arrow)              k(SCROLLBAR_DOWN_ARROW##p) \
	, v(scrollbar-horizontal-double-arrow) k(SCROLLBAR_HORIZONTAL_DOUBLE_ARROW##p) \
	, v(scrollbar-left-arrow)              k(SCROLLBAR_LEFT_ARROW##p) \
	, v(scrollbar-right-arrow)             k(SCROLLBAR_RIGHT_ARROW##p) \
	, v(scrollbar-up-arrow)                k(SCROLLBAR_UP_ARROW##p) \
	, v(scrollbar-vertical-double-arrow)   k(SCROLLBAR_VERTICAL_DOUBLE_ARROW##p) \
	, v(shuttle)                           k(SHUTTLE##p) \
	, v(sizing)                            k(SIZING##p) \
	, v(spider)                            k(SPIDER##p) \
	, v(spray-can)                         k(SPRAY_CAN##p) \
	, v(star)                              k(STAR##p) \
	, v(target)                            k(TARGET##p) \
	, v(target-cross)                      k(TARGET_CROSS##p) \
	, v(top-left-arrow)                    k(TOP_LEFT_ARROW##p) \
	, v(top-left-corner)                   k(TOP_LEFT_CORNER##p) \
	, v(top-right-corner)                  k(TOP_RIGHT_CORNER##p) \
	, v(top-side)                          k(TOP_SIDE##p) \
	, v(top-tee)                           k(TOP_TEE##p) \
	, v(trek)                              k(TREK##p) \
	, v(upper-left-angle)                  k(UPPER_LEFT_ANGLE##p) \
	, v(umbrella)                          k(UMBRELLA##p) \
	, v(upper-right-angle)                 k(UPPER_RIGHT_ANGLE##p) \
	, v(watch)                             k(WATCH##p) \
	, v(xterm)                             k(XTERM##p) \
	, n(NULL)                              k(NULL##p) \
}

#define COPYWINDOWPROPERTIES() /*-------------------------*/ local bool            copyWindowProperties(const xcb_window_t source, const xcb_window_t destination)
#define PROPERTYEXISTS() /*-------------------------------*/ local bool            propertyExists(const xcb_window_t window, const xcb_atom_t property)
#define PROPERTYIS() /*-----------------------------------*/ local bool            propertyIs(const xcb_window_t window, const xcb_atom_t property, const xcb_atom_t type, const uint length, const void *const value)
#define RESETPROPERTY() /*--------------------------------*/ local bool            resetProperty(const xcb_window_t window, const xcb_atom_t property, const xcb_atom_t type, const uint itemSize, const uint itemAmount, const void *const value)

def enum ENUM_CONTENT(CURSOR_GLYPH);

local const char *const /*-*/ cursorGlyphList[] = STRING_CONTENT(CURSOR_GLYPH);

COPYWINDOWPROPERTIES();
PROPERTYEXISTS();
PROPERTYIS();
RESETPROPERTY();

COPYWINDOWPROPERTIES(){
	const xcb_atom_t *current;
	const xcb_atom_t *wall;
	xcb_list_properties_reply_t *reply;
	uint32 token;
	uint length;
	jmp getPropertyList;
	getPropertyList:{
		reply = xcb_wait_for_reply(connection, xcb_list_properties(connection, source), NULL);
		token = pushPointer(reply, "copyWindowProperties() list properties reply", iFree);
		if(!reply){
			jmp emergencyExit;
		}
		jmp assessReply;
	}
	assessReply:{
		if(!(length = xcb_list_properties_atoms_length(reply))){
			jmp emergencyExit;
		}
		current = xcb_list_properties_atoms(reply);
		wall = current + length;
		jmp copyPropertyLoop;
	}
	copyPropertyLoop:{
		xcb_get_property_reply_t *const reply = xcb_wait_for_reply(connection, xcb_get_property(connection, false, source, *current, XCB_GET_PROPERTY_TYPE_ANY, 0, 0xFFFFFFFF), NULL);
		uint32 token = pushPointer(reply, "copyWindowProperties() get property reply", iFree);
		if(reply){
			const uint size = (*reply).format / 8;
			uint length = xcb_get_property_value_length(reply);
			if(size){
				length /= size;
			}
			xcb_discard_reply(connection, xcb_change_property_checked(connection, XCB_PROP_MODE_REPLACE, destination, *current, (*reply).type, (*reply).format, length, xcb_get_property_value(reply)));
			free(reply);
			popPointer(token);
		}
		if(inc current < wall){
			jmp copyPropertyLoop;
		}
		jmp emergencyExit;
	}
	emergencyExit:{
		free(reply);
		popPointer(token);
		ret true;
	}
}
PROPERTYEXISTS(){
	xcb_get_property_reply_t *const reply = xcb_wait_for_reply(connection, xcb_get_property(connection, false, window, property, XCB_GET_PROPERTY_TYPE_ANY, 0, 0xFFFFFFFF), NULL);
	uint32 token = pushPointer(reply, "propertyExists() get property reply", iFree);
	free(reply);
	popPointer(token);
	ret !!reply;
}
PROPERTYIS(){
	xcb_get_property_reply_t *const reply = xcb_wait_for_reply(connection, xcb_get_property(connection, false, window, property, type, 0, 0xFFFFFFFF), NULL);
	uint32 token = pushPointer(reply, "propertyIs() get property reply", iFree);
	bool equal = false;
	if(reply){
		if(xcb_get_property_value_length(reply) != (int)length){
			free(reply);
			popPointer(token);
			ret equal;
		}
		equal = compareMemory(xcb_get_property_value(reply), value, length);
		free(reply);
		popPointer(token);
	}
	ret equal;
}
RESETPROPERTY(){
	if(propertyIs(window, property, type, itemAmount * itemSize, value)){
		ret false;
	}
	xcb_discard_reply(connection, xcb_change_property_checked(connection, XCB_PROP_MODE_REPLACE, window, property, type, itemSize * 8, itemAmount, value));
	ret true;
}



























#define MAPCLIENT() /*-------------------------------*/ local bool            mapClient(ClientSystem *const clientSystem, MonitorSystem *const monitorSystem, Client *const client, const uint8 whichMonitor)

MAPCLIENT();

MAPCLIENT(){
	if(!clientSystem or !monitorSystem or !(*monitorSystem).size or !isValidClient(clientSystem, client) or (*client).stateState == NORMAL_STATE or !whichMonitor or whichMonitor >= ALL_WHICH_MONITOR){
		ret false;
	}
	if((*client).option & OVERRIDE_REDIRECT_CLIENT_OPTION){
		(*client).stateState = NORMAL_STATE;
		ret true;
	}
	if((*client).stateState == WITHDRAWN_STATE){
		Monitor *monitor;
		if(whichMonitor == SELF_WHICH_MONITOR){
			if(!(monitor = findWindowMonitor(monitorSystem, (*client).window))){
				ret false;
			}
		}else{
			if(!(monitor = getWhichMonitor(monitorSystem, whichMonitor))){
				ret false;
			}
		}
		xcb_discard_reply(connection, xcb_reparent_window_checked(connection, (*client).window, (*client).container, (*client).windowX, (*client).windowY));
		setDefaultClientWindowType(clientSystem, client);
		if(setClientAllowedActions(clientSystem, client)){
			changeClientAllowedActions(clientSystem, client);
		}
		setClientOrderType(clientSystem, client);









		if(!(*client).strut){
			int workareaX;
			int workareaY;
			int workareaWidth;
			int workareaHeight;
			int width = 0;
			int height = 0;



			if((*client).desktop != NONE_DESKTOP and (*client).desktop != 0xFFFFFFFF){
				const uint monitorOffset = monitor - (*monitorSystem).start;
				const EdgeOffset *const outerEdgeOffset = virtualRootSystem.workareaEdgeOffsetStart + monitorOffset;
				const EdgeOffset *const innerEdgeOffset = (*(virtualRootSystem.virtualRootStart + (*client).desktop)).workareaEdgeOffsetStart + monitorOffset;
				workareaX = (*monitor).leftX + (*outerEdgeOffset).left + (*innerEdgeOffset).left;
				workareaY = (*monitor).topY + (*outerEdgeOffset).top + (*innerEdgeOffset).top;
				workareaWidth = (*monitor).width - (*outerEdgeOffset).left - (*innerEdgeOffset).left - (*innerEdgeOffset).right - (*outerEdgeOffset).right;
				workareaHeight = (*monitor).height - (*outerEdgeOffset).top - (*innerEdgeOffset).top - (*innerEdgeOffset).bottom - (*outerEdgeOffset).bottom;
			}else{
				workareaX = (*monitor).leftX;
				workareaY = (*monitor).topY;
				workareaWidth = (*monitor).width;
				workareaHeight = (*monitor).height;
			}



			if((*client).normalHintsFlags & PROGRAM_BASE_SIZE_NORMAL_HINT){
				width = (*client).normalHintsBaseWidth;
				height = (*client).normalHintsBaseHeight;
			}elif((*client).normalHintsFlags & PROGRAM_MINIMUM_SIZE_NORMAL_HINT and (*client).normalHintsFlags & PROGRAM_MAXIMUM_SIZE_NORMAL_HINT){
				if((*client).normalHintsMinWidth == (*client).normalHintsMaxWidth){
					width = (*client).normalHintsMinWidth;
				}
				if((*client).normalHintsMinHeight == (*client).normalHintsMaxHeight){
					height = (*client).normalHintsMinHeight;
				}
			}
			if(width){
				width += 2 * (*client).containerBorder;
			}
			if(height){
				height += 2 * (*client).containerBorder;
			}
			if(!width or width > workareaWidth){
				if((*client).windowType & DIALOG_WINDOW_TYPE){
					width = workareaWidth * 2 / 4;
				}else{
					width = workareaWidth * 3 / 4;
				}
			}
			if(!height or height > workareaHeight){
				if((*client).windowType & DIALOG_WINDOW_TYPE){
					height = workareaHeight * 2 / 4;
				}else{
					height = workareaHeight * 3 / 4;
				}
			}
			moveResizeClient(clientSystem, client, workareaX + (workareaWidth - width) / 2, workareaY + (workareaHeight - height) / 2, width, height, true, true, true, true, true, CENTER_POINT_WINDOW_GRAVITY);
		}









		(*client).stateState = (*client).hintsInitialState;
		xcb_discard_reply(connection, xcb_change_property_checked(connection, XCB_PROP_MODE_REPLACE, (*client).window, atom._NET_FRAME_EXTENTS, XCB_ATOM_CARDINAL, bitsof(uint32), 4, &(*client).frameExtentsLeft));
	}
	if((*client).stateState == NORMAL_STATE){
		if(updateClientState(clientSystem, client, _NET_WM_STATE_REMOVE, HIDDEN_STATE)){
			changeClientState(clientSystem, client);
		}









		restackClient(clientSystem, client, XCB_STACK_MODE_ABOVE, XCB_NONE);
		configureClient(clientSystem, client);



		configureVirtualRootClient(&virtualRootSystem, clientSystem, client);

		/*!*/

		if((*client).strut){
			moveResizeClient(clientSystem, client, (*client).strutX, (*client).strutY, (*client).strutWidth, (*client).strutHeight, true, false, false, false, false, NONE_WINDOW_GRAVITY);
		}
		if(!(*client).strut){
			updateVirtualRootWorkareaClient(&virtualRootSystem, monitorSystem, clientSystem, client);
		}

		/*!*/









		/*!*/

		if(addVirtualRootClientWorkarea(&virtualRootSystem, monitorSystem, clientSystem, client)){
			updateVirtualRootStrutedClients(&virtualRootSystem, monitorSystem, clientSystem, client, ADD_UPDATE_WORKAREA_ACTION);
			updateVirtualRootWorkareaClients(&virtualRootSystem, monitorSystem, clientSystem);
			if(setVirtualRootWorkarea(&virtualRootSystem, monitorSystem)){
				changeVirtualRootWorkarea(&virtualRootSystem);
			}
		}









		xcb_discard_reply(connection, xcb_map_window_checked(connection, (*client).window));
		xcb_map_window(connection, (*client).container);
		if((*client).windowType & (TOOLBAR_WINDOW_TYPE | UTILITY_WINDOW_TYPE | DIALOG_WINDOW_TYPE | NORMAL_WINDOW_TYPE) and (*client).userTime != UNFOCUSED_USER_TIME){
			xcb_discard_reply(connection, xcb_set_input_focus_checked(connection, XCB_INPUT_FOCUS_POINTER_ROOT, (*client).window, getTimestamp()));
		}
	}
	xcb_discard_reply(connection, xcb_change_property_checked(connection, XCB_PROP_MODE_REPLACE, (*client).window, atom.WM_STATE, atom.WM_STATE, bitsof(uint32), 2, &(*client).stateState));
	ret true;
}



























int main(int argumentAmount, const char *const *argument){
	(void)windowPreferences;
	(void)whichMonitor;
	(void)baseEventName;
	(void)setVirtualRootName;
	(void)setElementPreferences;
	(void)createWindowCirclePixmap;
	(void)createWindows;
	(void)mapWindows;
	(void)configureWindows;
	(void)drawWindows;
	(void)findWindow;
	(void)setSleepThreadOperation;
	(void)setSleepThreadSleepTime;
	(void)bootSleepThread;
	(void)signalSleepThread;
	(void)findSubstring;
	(void)UTF8ToUCS2;
	(void)compositeImages;
	(void)compositeImagesOver;
	(void)compositeImagesAnd;
	(void)twoPassBoxBlur;
	(void)rotateImage;
	(void)grabDevice;
	(void)ungrabDevice;
	(void)tightenClippingRectangle;
	(void)unsetClippingRectangle;
	jmp setSignalHandler;
	setSignalHandler:{
		def struct sigaction /*-*/ Sigaction;
		Sigaction s;
		processingSignal = true;
		s.sa_handler = quit;
		s.sa_flags = 0;
		sigemptyset(&s.sa_mask);
		sigaction(SIGABRT, &s, NULL);
		sigaction(SIGBUS,  &s, NULL);
		sigaction(SIGFPE,  &s, NULL);
		sigaction(SIGILL,  &s, NULL);
		sigaction(SIGINT,  &s, NULL);
		sigaction(SIGQUIT, &s, NULL);
		sigaction(SIGSEGV, &s, NULL);
		sigaction(SIGTERM, &s, NULL);
		sigaction(SIGTRAP, &s, NULL);
		sigaction(SIGUSR1, &s, NULL);
		sigaction(SIGUSR2, &s, NULL);
		s.sa_handler = reapSpawnedProcesses;
		s.sa_flags = SA_NOCLDSTOP;
		sigaction(SIGCHLD, &s, NULL);
		jmp setGlobals;
	}
	setGlobals:{
		programName /*---------------*/ = *argument;
		errorPath /*-----------------*/ = NULL;
		colorStart /*----------------*/ = MESSAGE_START;
		colorFatal /*----------------*/ = MESSAGE_FATAL;
		colorError /*----------------*/ = MESSAGE_ERROR;
		colorEvent /*----------------*/ = MESSAGE_EVENT;
		colorEnd /*------------------*/ = MESSAGE_END;
		connectionName /*------------*/ = NULL;
		configPath /*----------------*/ = NULL;
		localeName /*----------------*/ = setlocale(LC_ALL, "");
		mustOpenErrorStream /*-------*/ = false;
		errorStream /*---------------*/ = DEFAULT_ERROR_STREAM;
		errorStreamToken /*----------*/ = 0;
		quitting /*------------------*/ = false;
		connection /*----------------*/ = NULL;
		connectionToken /*-----------*/ = 0;
		event /*---------------------*/ = NULL;
		eventToken /*----------------*/ = 0;
		keyPressNextOffset /*--------*/ = 0;
		keyReleaseNextOffset /*------*/ = 0;
		buttonPressNextOffset /*-----*/ = 0;
		buttonReleaseNextOffset /*---*/ = 0;
		shortcutCode /*--------------*/ = 0;
		shortcutModifier /*----------*/ = XCB_NONE;
		expectingSecondKeyRelease /*-*/ = false;
		initMemorySystem();
		initPermissionSystem(&permissionSystem);
		initMonitorSystem(&monitorSystem);
		initPointerSystem(&pointerSystem);
		initCursorSystem(&cursorSystem);
		initWallpaperSystem(&wallpaperSystem);
		initClientSystem(&clientSystem);
		initVirtualRootSystem(&virtualRootSystem);
		initClientListSystem(&clientListSystem);
		initClientListSystem(&clientListStackingSystem);
		initWindowSystem(&windowSystem);
		initSleepThreadSystem(&sleepThreadSystem);
		initStringTreeSystem(&globalScopesInstructionStringTreeSystem);
		initStringTreeSystem(&globalInstructionStringTreeSystem);
		initStringTreeSystem(&scope1ScopeInstructionStringTreeSystem);
		initStringTreeSystem(&booleanStringTreeSystem);
		initStringTreeSystem(&variableStringTreeSystem);
		initStringTreeSystem(&commandStringTreeSystem);
		initStringTreeSystem(&modifierStringTreeSystem);
		initStringTreeSystem(&shortcutStateStringTreeSystem);
		initStringTreeSystem(&numberTypeStringTreeSystem);
		initStringTreeSystem(&horizontalAlignmentStringTreeSystem);
		initStringTreeSystem(&verticalAlignmentStringTreeSystem);
		initStringTreeSystem(&cornerStringTreeSystem);
		initStringTreeSystem(&whichMonitorStringTreeSystem);
		initStringTreeSystem(&directionStringTreeSystem);
		initStringTreeSystem(&macroStringTreeSystem);
		initSTDINSystem(&stdinSystem);
		initSharedMemorySystem(&sharedMemorySystem);
		initShortcutSystem(&keycodeShortcutSystem);
		initShortcutSystem(&buttonShortcutSystem);
		setConfigVariables();
		{
			pthread_rwlockattr_t attributes;
			if(pthread_rwlockattr_init(&attributes) != PTHREAD_RWLOCKATTR_INIT_SUCCESS){
				printTitledError("pthread error", "could not init global lock attributes");
			}
			if(pthread_rwlockattr_setkind_np(&attributes, PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP) != PTHREAD_RWLOCKATTR_SETKIND_NP_SUCCESS){
				printTitledError("pthread error", "could not set global lock attributes lock kind");
			}
			globalsLockCreated = pthread_rwlock_init(&globalsLock, &attributes) == PTHREAD_RWLOCK_INIT_SUCCESS;
			if(!globalsLockCreated){
				printTitledError("pthread error", "could not init globals lock");
			}
			if(pthread_rwlockattr_destroy(&attributes) != PTHREAD_RWLOCKATTR_DESTROY_SUCCESS){
				printTitledError("pthread error", "could not destroy global lock attributes");
			}
		}
		setPermissions(&permissionSystem);
		lowerPermissions(&permissionSystem);
		processingSignal = false;
		jmp getProgramArguments;
	}
	getProgramArguments:{
		if(argumentAmount == 1){
			printError("%s%s: %susage:%s %s [argument] [value] or %s [argument] [--help]\n\t[-h], [--help]  \tdisplay this message\n\t[-c], [--config]\tpath to config file, mandatory\n\t[-e], [--error] \tpath to error file, optional\n\t[-s], [--server]\tX server connection, optional\n", colorStart, programName, colorError, colorEnd, programName, programName);
			jmp mainEmergencyExit;
		}
		dec argumentAmount;
		jmp checkErrorRedirection;
	}
	checkErrorRedirection:{
		if(!isatty(fileno(DEFAULT_ERROR_STREAM))){
			colorStart = "";
			colorFatal = "";
			colorError = "";
			colorEvent = "";
			colorEnd = "";
		}
		jmp matchArgumentsLoop;
	}
	matchArgumentsLoop:{
		switch(identifyArgument(*(inc argument))){
			to HELP_ARGUMENT: /*---*/ jmp helpArgument;
			to CONFIG_ARGUMENT: /*-*/ jmp configArgument;
			to ERROR_ARGUMENT: /*--*/ jmp errorArgument;
			to SERVER_ARGUMENT: /*-*/ jmp serverArgument;
			off: /*----------------*/ jmp notAnArgument;
		}
	}
	helpArgument:{
		fprintf(DEFAULT_OUTPUT_STREAM, "%s: usage: %s [argument] [value] or %s [argument] [--help]\n\t[-h], [--help]  \tdisplay this message\n\t[-c], [--config]\tpath to config file, mandatory\n\t[-e], [--error] \tpath to error file, optional\n\t[-s], [--server]\tX server connection, optional\n", programName, programName, programName);
		jmp mainEmergencyExit;
	}
	configArgument:{
		if(configPath){
			printTitledError("argument error", "the config argument has already been specified");
			jmp mainEmergencyExit;
		}
		if(!dec argumentAmount){
			printTitledError("argument error", "no config value specified");
			jmp mainEmergencyExit;
		}
		configPath = *(inc argument);
		switch(identifyArgument(configPath)){
			to UNRECOGNIZED_ARGUMENT: /*-*/ jmp openConfigFile;
			to HELP_ARGUMENT: /*---------*/ jmp displayConfigUsage;
			off: /*----------------------*/ jmp displayNoConfigValue;
		}
	}
	openConfigFile:{
		DIR *const dir = opendir(configPath);
		FILE *file;
		uint32 token = pushPointer(dir, "config directory argument", closedir);
		if(dir){
			closedir(dir);
			popPointer(token);
			printTitledQuotedError("argument error", *argument, "config value is directory");
			jmp mainEmergencyExit;
		}
		file = fopen(configPath, "r");
		token = pushPointer(file, "config file argument", fclose);
		if(file){
			fclose(file);
			popPointer(token);
			jmp matchArgumentLoopControl;
		}
		file = fopen(configPath, "w");
		token = pushPointer(file, "config file argument", fclose);
		if(file){
			fclose(file);
			popPointer(token);
			remove(configPath);
			jmp matchArgumentLoopControl;
		}
		printTitledError("argument error", "could not read or create config file");
		jmp mainEmergencyExit;
	}
	displayConfigUsage:{
		fprintf(DEFAULT_OUTPUT_STREAM, "%s: usage: %s --config \"/path/to/file\"\n\tif the specified file doesn't exist it will be created\n\tand it will contain the hardcoded default configuration\n", programName, programName);
		jmp mainEmergencyExit;
	}
	displayNoConfigValue:{
		printTitledError("argument error", "no config value specified");
		jmp mainEmergencyExit;
	}
	errorArgument:{
		if(errorPath){
			printTitledError("argument error", "the error argument has already been specified");
			jmp mainEmergencyExit;
		}
		if(!dec argumentAmount){
			printTitledError("argument error", "no error value specified");
			jmp mainEmergencyExit;
		}
		errorPath = *(inc argument);
		switch(identifyArgument(errorPath)){
			to UNRECOGNIZED_ARGUMENT: /*-*/ jmp openErrorFile;
			to HELP_ARGUMENT: /*---------*/ jmp displayErrorUsage;
			to STDOUT_ARGUMENT: /*-------*/ jmp setErrorStreamStdout;
			to STDERR_ARGUMENT: /*-------*/ jmp setErrorStreamStderr;
			off: /*----------------------*/ jmp displayNoErrorValue;
		}
	}
	openErrorFile:{
		DIR *const dir = opendir(configPath);
		FILE *file;
		uint32 token = pushPointer(dir, "error directory argument", closedir);
		if(dir){
			closedir(dir);
			popPointer(token);
			printTitledQuotedError("argument error", *argument, "error value is directory");
			jmp mainEmergencyExit;
		}
		file = fopen(errorPath, "r");
		token = pushPointer(file, "error file argument", fclose);
		if(file){
			fclose(file);
			popPointer(token);
			mustOpenErrorStream = true;
			colorStart = "";
			colorFatal = "";
			colorError = "";
			colorEvent = "";
			colorEnd = "";
			jmp matchArgumentLoopControl;
		}
		file = fopen(errorPath, "w");
		token = pushPointer(file, "error file argument", fclose);
		if(file){
			fclose(file);
			popPointer(token);
			remove(errorPath);
			mustOpenErrorStream = true;
			colorStart = "";
			colorFatal = "";
			colorError = "";
			colorEvent = "";
			colorEnd = "";
			jmp matchArgumentLoopControl;
		}
		printTitledError("argument error", "could not create error file");
		jmp mainEmergencyExit;
	}
	displayErrorUsage:{
		fprintf(DEFAULT_OUTPUT_STREAM, "%s: usage: %s --error \"/path/to/file\"\n\tif the specified file doesn't exist it will be created\n", programName, programName);
		jmp mainEmergencyExit;
	}
	setErrorStreamStdout:{
		errorStream = stdout;
		jmp matchArgumentLoopControl;
	}
	setErrorStreamStderr:{
		errorStream = stderr;
		jmp matchArgumentLoopControl;
	}
	displayNoErrorValue:{
		printTitledError("argument error", "no error value specified");
		jmp mainEmergencyExit;
	}
	serverArgument:{
		if(connectionName){
			printTitledError("argument error", "the server argument has already been specified");
			jmp mainEmergencyExit;
		}
		if(!dec argumentAmount){
			printTitledError("argument error", "no server value specified");
			jmp mainEmergencyExit;
		}
		connectionName = *(inc argument);
		switch(identifyArgument(connectionName)){
			to UNRECOGNIZED_ARGUMENT: /*-*/ jmp matchArgumentLoopControl;
			to HELP_ARGUMENT: /*---------*/ jmp displayServerUsage;
			off: /*----------------------*/ jmp displayNoServerValue;
		}
	}
	displayServerUsage:{
		fprintf(DEFAULT_OUTPUT_STREAM, "%s: usage: %s --server \"name\"\n\tthe name of the server, if running, should be something like \":0\"\n\tit can be checked with the $DISPLAY variable on a running server (no tty)\n", programName, programName);
		jmp mainEmergencyExit;
	}
	displayNoServerValue:{
		printTitledError("argument error", "no server value specified");
		jmp mainEmergencyExit;
	}
	notAnArgument:{
		printTitledQuotedError("argument error", *argument, "is not recognized as program argument, check help? [-h]");
		jmp mainEmergencyExit;
	}
	matchArgumentLoopControl:{
		if(dec argumentAmount){
			jmp matchArgumentsLoop;
		}
		jmp argumentsFinalCheck;
	}
	argumentsFinalCheck:{
		if(!configPath){
			printTitledError("argument error", "no config argument specified");
			jmp mainEmergencyExit;
		}
		if(errorPath and sensitiveStringCompare(errorPath, configPath)){
			mustOpenErrorStream = false;
			printTitledError("argument error", "config and error files are the same");
			jmp mainEmergencyExit;
		}
		jmp establishServerConnection;
	}
	establishServerConnection:{
		screenNumber = 0;
		connection = xcb_connect_to_display_with_auth_info(connectionName, NULL, &screenNumber);
		connectionToken = pushPointer(connection, "X connection", iXCBDisconnect);
		if(xcb_connection_has_error(connection)){
			printConnectionError();
			jmp mainEmergencyExit;
		}
		screen = xcb_setup_roots_iterator(xcb_get_setup(connection)).data + screenNumber;
		if(screen){
			screenWidthInPixels = (*screen).width_in_pixels;
			screenHeightInPixels = (*screen).height_in_pixels;
			screenWidthInMillimeters = (*screen).width_in_millimeters;
			screenHeightInMillimeters = (*screen).height_in_millimeters;
		}else{
			screenWidthInPixels = 0;
			screenHeightInPixels = 0;
			screenWidthInMillimeters = 0;
			screenHeightInMillimeters = 0;
		}
		jmp checkExtensionAvailability;
	}
	checkExtensionAvailability:{
		#define STRING(f) /*--------*/ { \
			  f("RANDR") \
			, f("SHAPE") \
			, f("XFIXES") \
		}
		#define BASE_POINTER /*-----*/ { \
			  &randrMajorOpcode \
			, &randrBaseEvent \
			, &randrBaseError \
			, &shapeMajorOpcode \
			, &shapeBaseEvent \
			, &shapeBaseError \
			, &xfixesMajorOpcode \
			, &xfixesBaseEvent \
			, &xfixesBaseError \
		}
		#define VERSION_FUNCTION /*-*/ { \
			  &randrQueryVersionUnchecked \
			, &shapeQueryVersionUnchecked \
			, &xfixesQueryVersionUnchecked \
		}
		#define MAJOR_VERSION /*----*/ { \
			  XCB_RANDR_MAJOR_VERSION \
			, XCB_SHAPE_MAJOR_VERSION \
			, XCB_XFIXES_MAJOR_VERSION \
		}
		#define MINOR_VERSION /*----*/ { \
			  XCB_RANDR_MINOR_VERSION \
			, XCB_SHAPE_MINOR_VERSION \
			, XCB_XFIXES_MINOR_VERSION \
		}
		char *nameStart[] = STRING(SELF);
		uint lengthStart[] = STRING(lengthof);
		xcb_query_extension_cookie_t cookieStart[countof(nameStart)];
		uint8 *basePointerStart[countof(nameStart) * 3] = BASE_POINTER;
		xcb_void_cookie_t (*versionFunctionStart[countof(nameStart)])(xcb_connection_t *, uint32, uint32) = VERSION_FUNCTION;
		uint32 majorVersionStart[countof(nameStart)] = MAJOR_VERSION;
		uint32 minorVersionStart[countof(nameStart)] = MINOR_VERSION;
		xcb_void_cookie_t versionCookieStart[countof(nameStart)];
		char **nameCurrent = nameStart;
		uint *lengthCurrent = lengthStart;
		xcb_query_extension_cookie_t *cookieCurrent = cookieStart;
		uint8 **basePointerCurrent = basePointerStart;
		xcb_void_cookie_t (**versionFunctionCurrent)(xcb_connection_t *, uint32, uint32) = versionFunctionStart;
		uint32 *majorVersionCurrent = majorVersionStart;
		uint32 *minorVersionCurrent = minorVersionStart;
		xcb_void_cookie_t *versionCookieCurrent = versionCookieStart;
		xcb_query_extension_cookie_t *const cookieWall = cookieCurrent + countof(nameStart);
		xcb_void_cookie_t *const versionCookieWall = versionCookieCurrent + countof(nameStart);
		jmp queryExtensionRequestLoop;
		queryExtensionRequestLoop:{
			*cookieCurrent = xcb_query_extension_unchecked(connection, *lengthCurrent, *nameCurrent);
			if(inc cookieCurrent < cookieWall){
				inc nameCurrent;
				inc lengthCurrent;
				jmp queryExtensionRequestLoop;
			}
			cookieCurrent = cookieStart;
			nameCurrent = nameStart;
			lengthCurrent = lengthStart;
			jmp queryExtensionReplyLoop;
		}
		queryExtensionReplyLoop:{
			xcb_query_extension_reply_t *const reply = xcb_wait_for_reply(connection, *cookieCurrent, NULL);
			uint32 token = pushPointer(reply, "query extension reply", iFree);
			(*versionCookieCurrent).sequence = 0;
			**(basePointerCurrent + 0) = 0;
			**(basePointerCurrent + 1) = 0;
			**(basePointerCurrent + 2) = 0;
			if(!reply){
				printTitledNamedError("reply error", "could not get reply for", *nameCurrent);
			}else{
				if(!(*reply).present){
					printTitledQuotedError("extension error", *nameCurrent, "extension is not available");
				}else{
					*versionCookieCurrent = (*versionFunctionCurrent)(connection, *majorVersionCurrent, *minorVersionCurrent);
					**(basePointerCurrent + 0) = (*reply).major_opcode;
					**(basePointerCurrent + 1) = (*reply).first_event;
					**(basePointerCurrent + 2) = (*reply).first_error;
				}
				free(reply);
				popPointer(token);
			}
			if(inc cookieCurrent < cookieWall){
				inc nameCurrent;
				basePointerCurrent += 3;
				inc versionFunctionCurrent;
				inc majorVersionCurrent;
				inc minorVersionCurrent;
				inc versionCookieCurrent;
				jmp queryExtensionReplyLoop;
			}
			versionCookieCurrent = versionCookieStart;
			jmp queryExtensionVersionReplyLoop;
		}
		queryExtensionVersionReplyLoop:{
			if((*versionCookieCurrent).sequence){
				void *const reply = xcb_wait_for_reply(connection, *versionCookieCurrent, NULL);
				uint32 token = pushPointer(reply, "query extension version reply", iFree);
				free(reply);
				popPointer(token);
			}
			if(inc versionCookieCurrent < versionCookieWall){
				jmp queryExtensionVersionReplyLoop;
			}
			jmp setAtoms;
		}
		#undef  MINOR_VERSION
		#undef  MAJOR_VERSION
		#undef  VERSION_FUNCTION
		#undef  BASE_POINTER
		#undef  STRING
	}
	setAtoms:{
		#define STRING(f) /*-*/ { \
			  f("MICRO_INIT") \
			, f("MANAGER") \
			, f("WM_NAME") \
			, f("WM_ICON_NAME") \
			, f("WM_NORMAL_HINTS") \
			, f("WM_SIZE_HINTS") \
			, f("WM_HINTS") \
			, f("WM_CLASS") \
			, f("WM_TRANSIENT_FOR") \
			, f("WM_PROTOCOLS") \
			, f("WM_TAKE_FOCUS") \
			, f("WM_DELETE_WINDOW") \
			, f("WM_COLORMAP_WINDOWS") \
			, f("WM_COLORMAP_NOTIFY") \
			, f("WM_CLIENT_MACHINE") \
			, f("WM_LOCALE_NAME") \
			, f("WM_WINDOW_ROLE") \
			, f("WM_COMMAND") \
			, f("WM_CLIENT_LEADER") \
			, f("WM_STATE") \
			, f("WM_CHANGE_STATE") \
			, f("WM_ICON_SIZE") \
			, f("SM_CLIENT_ID") \
			, f("UTF8_STRING") \
			, f("_NET_SUPPORTED") \
			, f("_NET_CLIENT_LIST") \
			, f("_NET_CLIENT_LIST_STACKING") \
			, f("_NET_NUMBER_OF_DESKTOPS") \
			, f("_NET_DESKTOP_GEOMETRY") \
			, f("_NET_DESKTOP_VIEWPORT") \
			, f("_NET_CURRENT_DESKTOP") \
			, f("_NET_DESKTOP_NAMES") \
			, f("_NET_ACTIVE_WINDOW") \
			, f("_NET_WORKAREA") \
			, f("_NET_SUPPORTING_WM_CHECK") \
			, f("_NET_VIRTUAL_ROOTS") \
			, f("_NET_DESKTOP_LAYOUT") \
			, f("_NET_SHOWING_DESKTOP") \
			, f("_NET_CLOSE_WINDOW") \
			, f("_NET_MOVERESIZE_WINDOW") \
			, f("_NET_WM_MOVERESIZE") \
			, f("_NET_RESTACK_WINDOW") \
			, f("_NET_REQUEST_FRAME_EXTENTS") \
			, f("_NET_WM_NAME") \
			, f("_NET_WM_VISIBLE_NAME") \
			, f("_NET_WM_ICON_NAME") \
			, f("_NET_WM_VISIBLE_ICON_NAME") \
			, f("_NET_WM_DESKTOP") \
			, f("_NET_WM_WINDOW_TYPE") \
			, f("_NET_WM_WINDOW_TYPE_DESKTOP") \
			, f("_NET_WM_WINDOW_TYPE_DOCK") \
			, f("_NET_WM_WINDOW_TYPE_TOOLBAR") \
			, f("_NET_WM_WINDOW_TYPE_MENU") \
			, f("_NET_WM_WINDOW_TYPE_UTILITY") \
			, f("_NET_WM_WINDOW_TYPE_SPLASH") \
			, f("_NET_WM_WINDOW_TYPE_DIALOG") \
			, f("_NET_WM_WINDOW_TYPE_NORMAL") \
			, f("_NET_WM_STATE") \
			, f("_NET_WM_STATE_MODAL") \
			, f("_NET_WM_STATE_STICKY") \
			, f("_NET_WM_STATE_MAXIMIZED_HORZ") \
			, f("_NET_WM_STATE_MAXIMIZED_VERT") \
			, f("_NET_WM_STATE_SHADED") \
			, f("_NET_WM_STATE_SKIP_TASKBAR") \
			, f("_NET_WM_STATE_SKIP_PAGER") \
			, f("_NET_WM_STATE_HIDDEN") \
			, f("_NET_WM_STATE_FULLSCREEN") \
			, f("_NET_WM_STATE_ABOVE") \
			, f("_NET_WM_STATE_BELOW") \
			, f("_NET_WM_STATE_DEMANDS_ATTENTION") \
			, f("_NET_WM_ALLOWED_ACTIONS") \
			, f("_NET_WM_ACTION_MOVE") \
			, f("_NET_WM_ACTION_RESIZE") \
			, f("_NET_WM_ACTION_MINIMIZE") \
			, f("_NET_WM_ACTION_SHADE") \
			, f("_NET_WM_ACTION_STICK") \
			, f("_NET_WM_ACTION_MAXIMIZE_HORZ") \
			, f("_NET_WM_ACTION_MAXIMIZE_VERT") \
			, f("_NET_WM_ACTION_FULLSCREEN") \
			, f("_NET_WM_ACTION_CHANGE_DESKTOP") \
			, f("_NET_WM_ACTION_CLOSE") \
			, f("_NET_WM_STRUT") \
			, f("_NET_WM_STRUT_PARTIAL") \
			, f("_NET_WM_ICON_GEOMETRY") \
			, f("_NET_WM_ICON") \
			, f("_NET_WM_PID") \
			, f("_NET_WM_HANDLED_ICONS") \
			, f("_NET_WM_USER_TIME") \
			, f("_NET_FRAME_EXTENTS") \
			, f("_NET_WM_PING") \
			, f("_NET_WM_SYNC_REQUEST") \
			, f("_NET_WM_SYNC_REQUEST_COUNTER") \
			, f("_NET_SYSTEM_TRAY_ORIENTATION") \
			, f("_NET_SYSTEM_TRAY_OPCODE") \
			, f("_NET_SYSTEM_TRAY_MESSAGE_DATA") \
			, f("_XEMBED_INFO") \
			, f("_XEMBED") \
			, f("_XROOTPMAP_ID") \
		}
		const char *const atomNameStart[] = STRING(SELF);
		const uint atomNameSizeStart[] = STRING(lengthof);
		xcb_intern_atom_cookie_t cookieStart[countof(atomNameStart)];
		const char *const *atomNameCurrent = atomNameStart;
		const uint *atomNameSizeCurrent = atomNameSizeStart;
		xcb_intern_atom_cookie_t *cookieCurrent = cookieStart;
		xcb_intern_atom_cookie_t *const cookieWall = cookieStart + countof(cookieStart);
		xcb_atom_t *atomCurrent = (void *)&atom;
		jmp atomRequestLoop;
		atomRequestLoop:{
			*cookieCurrent = xcb_intern_atom_unchecked(connection, false, *atomNameSizeCurrent, *atomNameCurrent);
			if(inc cookieCurrent < cookieWall){
				inc atomNameSizeCurrent;
				inc atomNameCurrent;
				jmp atomRequestLoop;
			}
			cookieCurrent = cookieStart;
			jmp atomReplyLoop;
		}
		atomReplyLoop:{
			xcb_intern_atom_reply_t *const reply = xcb_wait_for_reply(connection, *cookieCurrent, NULL);
			uint32 token = pushPointer(reply, "atom reply", iFree);
			if(!reply){
				printError("%s%s: %s%s:%s %s %s %s\n", colorStart, programName, colorError, "atom error", colorEnd, "could not get the", *(atomNameStart + (cookieCurrent - cookieStart)), "atom");
			}else{
				*atomCurrent = (*reply).atom;
				free(reply);
				popPointer(token);
			}
			if(inc cookieCurrent < cookieWall){
				inc atomCurrent;
				jmp atomReplyLoop;
			}
			jmp setOtherAtoms;
		}
		#undef  STRING
	}
	setOtherAtoms:{
		char string[lengthof("WM_Sxyz") + 1] = "WM_S";
		uint length = snprintf(string + lengthof("WM_S"), 3, "%u", screenNumber) + lengthof("WM_S");
		xcb_intern_atom_reply_t *const reply = xcb_wait_for_reply(connection, xcb_intern_atom_unchecked(connection, false, length, string), NULL);
		uint32 token = pushPointer(reply, "atom reply", iFree);
		if(!reply){
			printError("%s%s: %s%s:%s %s %s %s\n", colorStart, programName, colorError, "atom error", colorEnd, "could not get the", string, "atom");
		}else{
			atom.WM_Sn = (*reply).atom;
			free(reply);
			popPointer(token);
		}
		jmp selectInput;
	}
	selectInput:{
		xcb_void_cookie_t cookie;
		xcb_generic_error_t *error;
		uint32 token;
		struct{
			uint32 /*-*/ eventMask;
		} valueList;
		valueList.eventMask = XCB_EVENT_MASK_NO_EVENT;
		cookie = xcb_change_window_attributes_checked(connection, (*screen).root, XCB_CW_EVENT_MASK, &valueList);
		error = xcb_request_check(connection, cookie);
		token = pushPointer(error, "select input event mask error", iFree);
		if(error){
			printTitledError("select input error", "could not apply to receive root window events");
			free(error);
			popPointer(token);
		}
		cookie = xcb_randr_select_input_checked(connection, (*screen).root, XCB_RANDR_NOTIFY_MASK_SCREEN_CHANGE);
		error = xcb_request_check(connection, cookie);
		token = pushPointer(error, "randr select input event mask error", iFree);
		if(error){
			printTitledError("randr select input error", "could not apply to receive monitor events");
			free(error);
			popPointer(token);
		}
		xcb_flush(connection);
		jmp setupScreenProfile;
	}
	setupScreenProfile:{
		xcb_depth_iterator_t depthIterator = xcb_screen_allowed_depths_iterator(screen);
		xcb_visualtype_iterator_t visualIterator;
		visual = (*screen).root_visual;
		depth = (*screen).root_depth;
		jmp findDepth;
		findDepth:{
			if((*depthIterator.data).depth == 32){
				visualIterator = xcb_depth_visuals_iterator(depthIterator.data);
				jmp findVisual;
			}
			if(!depthIterator.rem){
				printTitledError("screen error", "could not find a 32-bit depth visual, using default screen visual instead");
				jmp createColormap;
			}
			xcb_depth_next(&depthIterator);
			jmp findDepth;
		}
		findVisual:{
			if((*visualIterator.data)._class == XCB_VISUAL_CLASS_TRUE_COLOR){
				visual = (*visualIterator.data).visual_id;
				depth = (*depthIterator.data).depth;
				jmp createColormap;
			}
			if(!visualIterator.rem){
				printTitledError("screen error", "could not match 32-bit depth with a true color visual, using default screen visual instead");
				jmp createColormap;
			}
			dec visualIterator.rem;
			inc visualIterator.data;
			jmp findVisual;
		}
		createColormap:{
			colormap = xcb_generate_id(connection);
			xcb_create_colormap(connection, XCB_COLORMAP_ALLOC_NONE, colormap, (*screen).root, visual);
			jmp initSystems;
		}
	}
	initSystems:{
		xcb_get_selection_owner_reply_t *const reply = xcb_wait_for_reply(connection, xcb_get_selection_owner_unchecked(connection, atom.WM_Sn), NULL);
		uint32 token = pushPointer(reply, "initSystems: get selection owner reply", iFree);
		struct{
			uint32 /*-*/ eventMask;
		} valueList;
		previousWMSelectionWindow = XCB_NONE;
		if(reply){
			if((*reply).owner){
				xcb_generic_error_t *error;
				uint32 token;
				previousWMSelectionWindow = (*reply).owner;
				valueList.eventMask = XCB_EVENT_MASK_STRUCTURE_NOTIFY;
				error = xcb_request_check(connection, xcb_change_window_attributes_checked(connection, previousWMSelectionWindow, XCB_CW_EVENT_MASK, &valueList));
				token = pushPointer(error, "initSystems: change window attributes error", iFree);
				if(error){
					previousWMSelectionWindow = XCB_NONE;
					free(error);
					popPointer(token);
				}
			}
			free(reply);
			popPointer(token);
		}
		wmSelectionWindow = xcb_generate_id(connection);
		wmSelectionTimestamp = XCB_NONE;
		valueList.eventMask = XCB_EVENT_MASK_PROPERTY_CHANGE;
		xcb_create_window(connection, XCB_COPY_FROM_PARENT, wmSelectionWindow, (*screen).root, -1, -1, 1, 1, 0, XCB_WINDOW_CLASS_INPUT_ONLY, (*screen).root_visual, XCB_CW_EVENT_MASK, &valueList);
		xcb_change_property(connection, XCB_PROP_MODE_REPLACE, wmSelectionWindow, atom.MICRO_INIT, XCB_ATOM_ATOM, bitsof(xcb_atom_t), 0, NULL);
		createMonitors(&monitorSystem);
		bulkInsertString(&globalScopesInstructionStringTreeSystem, globalScopesInstructionList);
		bulkInsertString(&globalInstructionStringTreeSystem, globalInstructionList);
		bulkInsertString(&scope1ScopeInstructionStringTreeSystem, scope1ScopeInstructionList);
		bulkInsertString(&booleanStringTreeSystem, booleanList);
		bulkInsertString(&variableStringTreeSystem, variableList);
		bulkInsertString(&commandStringTreeSystem, commandList);
		bulkInsertString(&modifierStringTreeSystem, modifierList);
		bulkInsertString(&shortcutStateStringTreeSystem, shortcutStateList);
		bulkInsertString(&numberTypeStringTreeSystem, numberTypeList);
		bulkInsertString(&horizontalAlignmentStringTreeSystem, horizontalAlignmentList);
		bulkInsertString(&verticalAlignmentStringTreeSystem, verticalAlignmentList);
		bulkInsertString(&cornerStringTreeSystem, cornerList);
		bulkInsertString(&whichMonitorStringTreeSystem, whichMonitorList);
		bulkInsertString(&directionStringTreeSystem, directionList);
		bulkInsertString(&macroStringTreeSystem, macroList);
		jmp readConfig;
	}
	readConfig:{
		if(globalsLockCreated and pthread_rwlock_wrlock(&globalsLock) != PTHREAD_RWLOCK_WRLOCK_SUCCESS){
			printTitledError("pthread error", "could not lock globals write lock");
		}
		displaySimpleConfigErrors = true;
		restart(false);
		readConfig(true, configPath, &ifgetc, NULL);
		if(globalsLockCreated and pthread_rwlock_unlock(&globalsLock) != PTHREAD_RWLOCK_UNLOCK_SUCCESS){
			printTitledError("pthread error", "could not unlock globals write lock");
		}
		if(globalsLockCreated and pthread_rwlock_rdlock(&globalsLock) != PTHREAD_RWLOCK_RDLOCK_SUCCESS){
			printTitledError("pthread error", "could not lock globals read lock");
		}
		jmp eventLoopCheckShortcuts;
	}
	eventLoopCheckShortcuts:{
		if(keyPressNextOffset) /*------*/ jmp keyPressEvent;
		if(keyReleaseNextOffset) /*----*/ jmp keyReleaseEvent;
		if(buttonPressNextOffset) /*---*/ jmp buttonPressEvent;
		if(buttonReleaseNextOffset) /*-*/ jmp buttonReleaseEvent;
		jmp eventLoop;
	}
	eventLoop:{
		xcb_flush(connection);
		free(event);
		popPointer(eventToken);
		event = NULL;
		eventToken = 0;
		if(globalsLockCreated and pthread_rwlock_unlock(&globalsLock) != PTHREAD_RWLOCK_UNLOCK_SUCCESS){
			printTitledError("pthread error", "could not unlock globals read lock");
		}
		jmp waitForEvent;
	}
	waitForEvent:{
		event = xcb_wait_for_event(connection);
		eventToken = pushPointer(event, "event pointer", iFree);
		if(event){
			if(globalsLockCreated and pthread_rwlock_rdlock(&globalsLock) != PTHREAD_RWLOCK_RDLOCK_SUCCESS){
				printTitledError("pthread error", "could not lock globals read lock");
			}
			jmp switchEvent;
		}
		if(xcb_connection_has_error(connection)){
			printConnectionError();
			jmp mainEmergencyExit;
		}
		jmp waitForEvent;
	}
	switchEvent:{
		#define XCB_ONE /*-*/ (1)
		if(((*event).response_type & ~b(10000000)) > XCB_NONE and ((*event).response_type & ~b(10000000)) < XCB_GE_GENERIC){
			printXEvent(baseEventName);
		}
		switch((*event).response_type & ~b(10000000)){
			to XCB_NONE: /*--------------*/ jmp errorEvent;
			to XCB_ONE: /*---------------*/ jmp unrecognizedEvent;
			to XCB_KEY_PRESS: /*---------*/ jmp keyPressEvent;
			to XCB_KEY_RELEASE: /*-------*/ jmp keyReleaseEvent;
			to XCB_BUTTON_PRESS: /*------*/ jmp buttonPressEvent;
			to XCB_BUTTON_RELEASE: /*----*/ jmp buttonReleaseEvent;
			to XCB_MOTION_NOTIFY: /*-----*/ jmp motionNotifyEvent;
			to XCB_ENTER_NOTIFY: /*------*/ jmp enterNotifyEvent;
			to XCB_LEAVE_NOTIFY: /*------*/ jmp unexpectedEvent;
			to XCB_FOCUS_IN: /*----------*/ jmp focusInEvent;
			to XCB_FOCUS_OUT: /*---------*/ jmp eventLoop;
			to XCB_KEYMAP_NOTIFY: /*-----*/ jmp unexpectedEvent;
			to XCB_EXPOSE: /*------------*/ jmp unexpectedEvent;
			to XCB_GRAPHICS_EXPOSURE: /*-*/ jmp unexpectedEvent;
			to XCB_NO_EXPOSURE: /*-------*/ jmp unexpectedEvent;
			to XCB_VISIBILITY_NOTIFY: /*-*/ jmp unexpectedEvent;
			to XCB_CREATE_NOTIFY: /*-----*/ jmp createNotifyEvent;
			to XCB_DESTROY_NOTIFY: /*----*/ jmp destroyNotifyEvent;
			to XCB_UNMAP_NOTIFY: /*------*/ jmp unmapNotifyEvent;
			to XCB_MAP_NOTIFY: /*--------*/ jmp mapNotifyEvent;
			to XCB_MAP_REQUEST: /*-------*/ jmp mapRequestEvent;
			to XCB_REPARENT_NOTIFY: /*---*/ jmp reparentNotifyEvent;
			to XCB_CONFIGURE_NOTIFY: /*--*/ jmp configureNotifyEvent;
			to XCB_CONFIGURE_REQUEST: /*-*/ jmp configureRequestEvent;
			to XCB_GRAVITY_NOTIFY: /*----*/ jmp unexpectedEvent;
			to XCB_RESIZE_REQUEST: /*----*/ jmp resizeRequestEvent;
			to XCB_CIRCULATE_NOTIFY: /*--*/ jmp circulateNotifyEvent;
			to XCB_CIRCULATE_REQUEST: /*-*/ jmp circulateRequestEvent;
			to XCB_PROPERTY_NOTIFY: /*---*/ jmp propertyNotifyEvent;
			to XCB_SELECTION_CLEAR: /*---*/ jmp selectionClearEvent;
			to XCB_SELECTION_REQUEST: /*-*/ jmp eventLoop;
			to XCB_SELECTION_NOTIFY: /*--*/ jmp eventLoop;
			to XCB_COLORMAP_NOTIFY: /*---*/ jmp colormapNotifyEvent;
			to XCB_CLIENT_MESSAGE: /*----*/ jmp clientMessageEvent;
			to XCB_MAPPING_NOTIFY: /*----*/ jmp eventLoop;
			to XCB_GE_GENERIC: /*--------*/ jmp genericEvent;
			off: /*----------------------*/ jmp extensionEvent;
		}
		#undef  XCB_ONE
	}
	errorEvent:{
		#define e /*----------------------*/ ((xcb_generic_error_t *)event)
		#define printExtensionError(n) /*-*/ if((*e).major_code == n##MajorOpcode){ printXError(n##ErrorName); jmp eventLoop; }
		printExtensionError(randr);
		printExtensionError(shape);
		printExtensionError(xfixes);
		printXError(baseErrorName);
		jmp eventLoop;
		#undef  printExtensionError
		#undef  e
	}
	keyPressEvent:{
		#define e /*-*/ ((xcb_key_press_event_t *)event)
		if(getNextShortcut(&keycodeShortcutSystem, false, (*e).detail, (*e).state & b(11111111), &keyPressNextOffset)){
			jmp matchCommandPress;
		}
		shortcutCode = 0;
		shortcutModifier = XCB_NONE;
		expectingSecondKeyRelease = false;
		jmp eventLoop;
		#undef  e
	}
	keyReleaseEvent:{
		#define e /*-*/ ((xcb_key_release_event_t *)event)
		uint8 keycode = (*e).detail;
		uint16 modifier = (*e).state & b(11111111);
		if(clientSystem.motionAction){
			jmp motionRelease;
		}
		if(getNextShortcut(&keycodeShortcutSystem, true, (*e).detail, (*e).state & b(11111111), &keyReleaseNextOffset)){
			xcb_query_keymap_reply_t *const reply = xcb_wait_for_reply(connection, xcb_query_keymap_unchecked(connection), NULL);
			uint32 token = pushPointer(reply, "query keymap reply", iFree);
			if(reply){
				const bool keyIsPressed = !!(*((*reply).keys + (*e).detail / 8) & (1 << (*e).detail % 8));
				free(reply);
				popPointer(token);
				if(keyIsPressed){
					keyReleaseNextOffset = 0;
					jmp eventLoop;
				}
			}
			jmp matchCommandRelease;
		}
		if(keycode != shortcutCode and modifier == shortcutModifier){
			expectingSecondKeyRelease = true;
			realKeyReleaseModifier = shortcutModifier;
			jmp eventLoop;
		}
		if(keycode == shortcutCode and modifier != shortcutModifier){
			if(!expectingSecondKeyRelease){
				jmp eventLoop;
			}
			keycode = shortcutCode;
			modifier = realKeyReleaseModifier;
			expectingSecondKeyRelease = false;
			keyReleaseNextOffset = 0;
			if(getNextShortcut(&keycodeShortcutSystem, true, keycode, modifier, &keyReleaseNextOffset)){
				jmp matchCommandRelease;
			}
		}
		jmp eventLoop;
		#undef  e
	}
	buttonPressEvent:{
		#define e /*-*/ ((xcb_button_press_event_t *)event)
		if(focusOnClick){
			Client *client;
			if((client = findClientWindow(&clientSystem, (*e).event)) or (client = findClientContainer(&clientSystem, (*e).event))){
				xcb_discard_reply(connection, xcb_set_input_focus_checked(connection, XCB_INPUT_FOCUS_POINTER_ROOT, (*client).window, getTimestamp()));
			}
		}
		if(getNextShortcut(&buttonShortcutSystem, false, (*e).detail, (*e).state & b(11111111), &buttonPressNextOffset)){
			jmp matchCommandPress;
		}
		jmp eventLoop;
		#undef  e
	}
	buttonReleaseEvent:{
		#define e /*-*/ ((xcb_button_release_event_t *)event)
		if(clientSystem.motionAction){
			jmp motionRelease;
		}
		if(getNextShortcut(&buttonShortcutSystem, true, (*e).detail, (*e).state & b(11111111), &buttonReleaseNextOffset)){
			jmp matchCommandRelease;
		}
		jmp eventLoop;
		#undef  e
	}
	{
		uint8 commandOrigin;
		matchCommandPress:{
			commandOrigin = PRESS_MATCH_COMMAND_ORIGIN;
			jmp matchCommand;
		}
		matchCommandRelease:{
			commandOrigin = RELEASE_MATCH_COMMAND_ORIGIN;
			jmp matchCommand;
		}
		matchCommand: switch(matchCommand((*eventModifierNode).command, (*eventModifierNode).string, commandOrigin, (*eventModifierNode).field0, (*eventModifierNode).field1, (*eventModifierNode).field2, (*eventModifierNode).field3, (*eventModifierNode).field4)){
			to TYPICAL_MATCH_COMMAND_TYPE:{
				jmp eventLoopCheckShortcuts;
			}
			to RESTART_MATCH_COMMAND_TYPE:{
				if(globalsLockCreated and pthread_rwlock_unlock(&globalsLock) != PTHREAD_RWLOCK_UNLOCK_SUCCESS){
					printTitledError("pthread error", "could not unlock globals read lock");
				}
				jmp readConfig;
			}
			to EXIT_MATCH_COMMAND_TYPE:{
				if(globalsLockCreated and pthread_rwlock_unlock(&globalsLock) != PTHREAD_RWLOCK_UNLOCK_SUCCESS){
					printTitledError("pthread error", "could not unlock globals read lock");
				}
				jmp mainEmergencyExit;
			}
			off:{
				jmp eventLoopCheckShortcuts;
			}
		}
	}
	motionRelease:{
		#define e /*-*/ ((xcb_key_release_event_t *)event)
		unsetMotionClient(&clientSystem);
		jmp eventLoop;
		#undef  e
	}
	motionNotifyEvent:{
		#define e /*-*/ ((xcb_motion_notify_event_t *)event)
		switch(clientSystem.motionAction){
			to NONE_MOTION_ACTION: /*---*/ jmp eventLoop;
			to MOVE_MOTION_ACTION: /*---*/ jmp moveMotion;
			to RESIZE_MOTION_ACTION: /*-*/ jmp resizeMotion;
			off: /*---------------------*/ jmp eventLoop;
		}
	}
	moveMotion:{
		Client *const client = clientSystem.clientStart + clientSystem.motionClientOffset;
		int deltaX;
		int deltaY;
		if(!isValidClient(&clientSystem, client)){
			jmp eventLoop;
		}
		deltaX = (*e).root_x - clientSystem.motionStartingX;
		deltaY = (*e).root_y - clientSystem.motionStartingY;
		clientSystem.motionStartingX = (*e).root_x;
		clientSystem.motionStartingY = (*e).root_y;
		moveResizeClient(&clientSystem, client, (*client).containerX + deltaX, (*client).containerY + deltaY, (*client).containerWidth + 2 * (*client).containerBorder, (*client).containerHeight + 2 * (*client).containerBorder, false, true, false, false, false, clientSystem.motionGravity);
		jmp eventLoop;
	}
	resizeMotion:{
		Client *const client = clientSystem.clientStart + clientSystem.motionClientOffset;
		int deltaX;
		int deltaY;
		if(!isValidClient(&clientSystem, client)){
			jmp eventLoop;
		}
		deltaX = (*e).root_x - clientSystem.motionStartingX;
		deltaY = (*e).root_y - clientSystem.motionStartingY;
		switch(clientSystem.motionGravity){
			to NONE_WINDOW_GRAVITY: /*-------------*/ /*---------*/ /*---------*/ jmp eventLoop;
			to NORTH_SIDE_WINDOW_GRAVITY: /*-------*/ deltaX *=  0; deltaY *=  1; brk;
			to SOUTH_SIDE_WINDOW_GRAVITY: /*-------*/ deltaX *=  0; deltaY *= -1; brk;
			to WEST_SIDE_WINDOW_GRAVITY: /*--------*/ deltaX *=  1; deltaY *=  0; brk;
			to EAST_SIDE_WINDOW_GRAVITY: /*--------*/ deltaX *= -1; deltaY *=  0; brk;
			to NORTH_WEST_POINT_WINDOW_GRAVITY: /*-*/ deltaX *=  1; deltaY *=  1; brk;
			to NORTH_EAST_POINT_WINDOW_GRAVITY: /*-*/ deltaX *= -1; deltaY *=  1; brk;
			to SOUTH_WEST_POINT_WINDOW_GRAVITY: /*-*/ deltaX *=  1; deltaY *= -1; brk;
			to SOUTH_EAST_POINT_WINDOW_GRAVITY: /*-*/ deltaX *= -1; deltaY *= -1; brk;
			off: /*--------------------------------*/ /*---------*/ /*---------*/ jmp eventLoop;
		}
		moveResizeClient(&clientSystem, client, clientSystem.motionX, clientSystem.motionY, clientSystem.motionWidth + deltaX, clientSystem.motionHeight + deltaY, false, true, true, false, false, clientSystem.motionGravity);
		clientSystem.motionX = (*client).containerX;
		clientSystem.motionY = (*client).containerY;
		jmp eventLoop;
		#undef  e
	}
	enterNotifyEvent:{
		#define e /*-*/ ((xcb_enter_notify_event_t *)event)
		Client *client;
		if(!focusOnHover){
			jmp eventLoop;
		}
		if((client = findClientContainer(&clientSystem, (*e).event)) or (client = findClientWindow(&clientSystem, (*e).event))){
			setFocusedClient(&clientSystem, client, virtualRootSystem.currentDesktop);
		}
		jmp eventLoop;
		#undef  e
	}
	focusInEvent:{
		#define e /*-*/ ((xcb_focus_in_event_t *)event)
		const xcb_window_t eventWindow = (*e).event;
		Client *client;
		if((*e).mode != XCB_NOTIFY_MODE_NORMAL and (*e).mode != XCB_NOTIFY_MODE_WHILE_GRABBED){
			jmp eventLoop;
		}
		if((client = findClientWindow(&clientSystem, eventWindow))){
			if(focusClient(&clientSystem, client)){
				if(restackClient(&clientSystem, client, XCB_STACK_MODE_ABOVE, XCB_NONE)){
					configureClient(&clientSystem, client);
					configureVirtualRootClient(&virtualRootSystem, &clientSystem, client);
					if(configureClientListClient(&clientListStackingSystem, &clientSystem, client)){
						changeClientListProperty(&clientListStackingSystem);
					}
				}
				gotoVirtualRoot(&virtualRootSystem, &clientSystem, (*client).desktop, false);
				changeActiveWindow(&clientSystem);
			}
			jmp eventLoop;
		}
		if((client = findClientContainer(&clientSystem, eventWindow))){
			xcb_discard_reply(connection, xcb_set_input_focus_checked(connection, XCB_INPUT_FOCUS_POINTER_ROOT, (*client).window, getTimestamp()));
			jmp eventLoop;
		}
		if(eventWindow == (*screen).root){
			xcb_set_input_focus(connection, XCB_INPUT_FOCUS_POINTER_ROOT, defaultFocusWindow, getTimestamp());
		}
		unfocusClient(&clientSystem);
		changeActiveWindow(&clientSystem);
		jmp eventLoop;
		#undef  e
	}
	createNotifyEvent:{
		#define e /*-*/ ((xcb_create_notify_event_t *)event)
		const xcb_window_t eventWindow = (*e).window;
		if(findVirtualRoot(&virtualRootSystem, eventWindow)){
			copyWindowProperties((*screen).root, eventWindow);
			jmp eventLoop;
		}
		if(findOwnedWindow(eventWindow) or findClientContainer(&clientSystem, eventWindow) or findClientWindow(&clientSystem, eventWindow)){
			jmp eventLoop;
		}
		if((*e).parent == (*screen).root){
			if(createClient(&clientSystem, &cursorSystem, eventWindow, (*e).x, (*e).y, (*e).width, (*e).height, (*e).border_width, XCB_WINDOW_CLASS_COPY_FROM_PARENT, (*e).override_redirect)){
				storeClientProperties(findClientWindow(&clientSystem, eventWindow));
			}
			jmp eventLoop;
		}
		xcb_discard_reply(connection, xcb_kill_client_checked(connection, eventWindow));
		jmp eventLoop;
		#undef  e
	}
	destroyNotifyEvent:{
		#define e /*-*/ ((xcb_destroy_notify_event_t *)event)
		const xcb_window_t eventWindow = (*e).window;
		Client *client;
		if((client = findClientWindow(&clientSystem, eventWindow))){
			uint8 state = (*client).stateState;
			if(destroyClient(&clientSystem, client)){
				if(state == NORMAL_STATE){
					state = (*client).stateState;
					(*client).stateState = NORMAL_STATE;
					if(removeVirtualRootClientWorkarea(&virtualRootSystem, &monitorSystem, &clientSystem, client)){
						updateVirtualRootStrutedClients(&virtualRootSystem, &monitorSystem, &clientSystem, client, REMOVE_UPDATE_WORKAREA_ACTION);
						updateVirtualRootWorkareaClients(&virtualRootSystem, &monitorSystem, &clientSystem);
						if(setVirtualRootWorkarea(&virtualRootSystem, &monitorSystem)){
							changeVirtualRootWorkarea(&virtualRootSystem);
						}
					}
					(*client).stateState = state;
				}
				if(removeClientListWindow(&clientListSystem, eventWindow)){
					changeClientListProperty(&clientListSystem);
				}
				if(removeClientListWindow(&clientListStackingSystem, eventWindow)){
					changeClientListProperty(&clientListStackingSystem);
				}
			}
			jmp eventLoop;
		}
		if(!wmSelectionTimestamp and eventWindow == previousWMSelectionWindow){
			if(!initWindowManagerSystem()){
				jmp mainEmergencyExit;
			}
			jmp eventLoop;
		}
		jmp eventLoop;
		#undef  e
	}
	unmapNotifyEvent:{
		#define e /*-*/ ((xcb_unmap_notify_event_t *)event)
		const xcb_window_t eventWindow = (*e).window;
		Client *client;
		if((client = findClientWindow(&clientSystem, eventWindow))){
			uint8 state = (*client).stateState;
			if(unmapClient(&clientSystem, client, !!(*e).from_configure * ICONIC_STATE)){
				if(state == NORMAL_STATE){
					state = (*client).stateState;
					(*client).stateState = NORMAL_STATE;
					if(removeVirtualRootClientWorkarea(&virtualRootSystem, &monitorSystem, &clientSystem, client)){
						updateVirtualRootStrutedClients(&virtualRootSystem, &monitorSystem, &clientSystem, client, REMOVE_UPDATE_WORKAREA_ACTION);
						updateVirtualRootWorkareaClients(&virtualRootSystem, &monitorSystem, &clientSystem);
						if(setVirtualRootWorkarea(&virtualRootSystem, &monitorSystem)){
							changeVirtualRootWorkarea(&virtualRootSystem);
						}
					}
					(*client).stateState = state;
				}
				if((*client).stateState == ICONIC_STATE){
					if(restackClientListWindow(&clientListSystem, eventWindow, XCB_STACK_MODE_BELOW, XCB_NONE)){
						changeClientListProperty(&clientListSystem);
					}
					if(restackClientListWindow(&clientListStackingSystem, eventWindow, XCB_STACK_MODE_BELOW, XCB_NONE)){
						changeClientListProperty(&clientListStackingSystem);
					}
				}else{
					if((*client).desktop != 0xFFFFFFFF){
						moveClientToVirtualRoot(&virtualRootSystem, &monitorSystem, &clientSystem, client, NONE_DESKTOP, true);
					}
					if(removeClientListWindow(&clientListSystem, eventWindow)){
						changeClientListProperty(&clientListSystem);
					}
					if(removeClientListWindow(&clientListStackingSystem, eventWindow)){
						changeClientListProperty(&clientListStackingSystem);
					}
				}
			}
			jmp eventLoop;
		}
		jmp eventLoop;
		#undef  e
	}
	mapNotifyEvent:{
		#define e /*-*/ ((xcb_map_notify_event_t *)event)
		const xcb_window_t eventWindow = (*e).window;
		Client *client;
		if((client = findClientWindow(&clientSystem, eventWindow))){
			if(!((*client).option & OVERRIDE_REDIRECT_CLIENT_OPTION)){
				jmp eventLoop;
			}
			if(!((*client).option & OVERRIDE_REDIRECT_CLIENT_OPTION)){
				if((*client).desktop == NONE_DESKTOP){
					if(setClientVirtualRoot(&virtualRootSystem, &clientSystem, client, virtualRootSystem.currentDesktop)){
						changeVirtualRootClientDesktop(&virtualRootSystem, &clientSystem, client);
					}
				}
			}
			if(mapClient(&clientSystem, &monitorSystem, client, POINTER_WHICH_MONITOR)){
/*!
				if((*client).stateState == NORMAL_STATE){
					configureVirtualRootClient(&virtualRootSystem, &clientSystem, client);
					if(!(*client).strut){
						updateVirtualRootWorkareaClient(&virtualRootSystem, &monitorSystem, &clientSystem, client);
					}
					if(addVirtualRootClientWorkarea(&virtualRootSystem, &monitorSystem, &clientSystem, client)){
						updateVirtualRootStrutedClients(&virtualRootSystem, &monitorSystem, &clientSystem, client, ADD_UPDATE_WORKAREA_ACTION);
						updateVirtualRootWorkareaClients(&virtualRootSystem, &monitorSystem, &clientSystem);
						if(setVirtualRootWorkarea(&virtualRootSystem, &monitorSystem)){
							changeVirtualRootWorkarea(&virtualRootSystem);
						}
					}
				}
*/
				if(!((*client).option & OVERRIDE_REDIRECT_CLIENT_OPTION) and !(*client).strut){
					if(!findClientListWindow(&clientListSystem, eventWindow)){
						if(addClientListWindow(&clientListSystem, eventWindow)){
							if((*client).stateState == ICONIC_STATE){
								restackClientListWindow(&clientListSystem, eventWindow, XCB_STACK_MODE_BELOW, XCB_NONE);
							}
							changeClientListProperty(&clientListSystem);
						}
					}else{
						if((*client).stateState == NORMAL_STATE){
							if(restackClientListWindow(&clientListSystem, eventWindow, XCB_STACK_MODE_ABOVE, XCB_NONE)){
								changeClientListProperty(&clientListSystem);
							}
						}
					}
					if(!findClientListWindow(&clientListStackingSystem, eventWindow)){
						if(addClientListWindow(&clientListStackingSystem, eventWindow)){
							if((*client).stateState == ICONIC_STATE){
								restackClientListWindow(&clientListStackingSystem, eventWindow, XCB_STACK_MODE_BELOW, XCB_NONE);
							}
							changeClientListProperty(&clientListStackingSystem);
						}
					}else{
						if((*client).stateState == NORMAL_STATE){
							if(restackClientListWindow(&clientListStackingSystem, eventWindow, XCB_STACK_MODE_ABOVE, XCB_NONE)){
								changeClientListProperty(&clientListStackingSystem);
							}
						}
					}
				}
			}
		}
		jmp eventLoop;
		#undef  e
	}
	mapRequestEvent:{
		#define e /*-*/ ((xcb_map_request_event_t *)event)
		const xcb_window_t eventWindow = (*e).window;
		Client *client;
		if((client = findClientWindow(&clientSystem, eventWindow))){
			if((*client).option & OVERRIDE_REDIRECT_CLIENT_OPTION){
				jmp eventLoop;
			}
			if(!((*client).option & OVERRIDE_REDIRECT_CLIENT_OPTION)){
				if((*client).desktop == NONE_DESKTOP){
					if(setClientVirtualRoot(&virtualRootSystem, &clientSystem, client, virtualRootSystem.currentDesktop)){
						changeVirtualRootClientDesktop(&virtualRootSystem, &clientSystem, client);
					}
				}
			}
			if(mapClient(&clientSystem, &monitorSystem, client, POINTER_WHICH_MONITOR)){
/*!
				if((*client).stateState == NORMAL_STATE){
					configureVirtualRootClient(&virtualRootSystem, &clientSystem, client);
					if(!(*client).strut){
						updateVirtualRootWorkareaClient(&virtualRootSystem, &monitorSystem, &clientSystem, client);
					}
					if(addVirtualRootClientWorkarea(&virtualRootSystem, &monitorSystem, &clientSystem, client)){
						updateVirtualRootStrutedClients(&virtualRootSystem, &monitorSystem, &clientSystem, client, ADD_UPDATE_WORKAREA_ACTION);
						updateVirtualRootWorkareaClients(&virtualRootSystem, &monitorSystem, &clientSystem);
						if(setVirtualRootWorkarea(&virtualRootSystem, &monitorSystem)){
							changeVirtualRootWorkarea(&virtualRootSystem);
						}
					}
				}
*/
				if(!((*client).option & OVERRIDE_REDIRECT_CLIENT_OPTION) and !(*client).strut){
					if(!findClientListWindow(&clientListSystem, eventWindow)){
						if(addClientListWindow(&clientListSystem, eventWindow)){
							if((*client).stateState == ICONIC_STATE){
								restackClientListWindow(&clientListSystem, eventWindow, XCB_STACK_MODE_BELOW, XCB_NONE);
							}
							changeClientListProperty(&clientListSystem);
						}
					}else{
						if((*client).stateState == NORMAL_STATE){
							if(restackClientListWindow(&clientListSystem, eventWindow, XCB_STACK_MODE_ABOVE, XCB_NONE)){
								changeClientListProperty(&clientListSystem);
							}
						}
					}
					if(!findClientListWindow(&clientListStackingSystem, eventWindow)){
						if(addClientListWindow(&clientListStackingSystem, eventWindow)){
							if((*client).stateState == ICONIC_STATE){
								restackClientListWindow(&clientListStackingSystem, eventWindow, XCB_STACK_MODE_BELOW, XCB_NONE);
							}
							changeClientListProperty(&clientListStackingSystem);
						}
					}else{
						if((*client).stateState == NORMAL_STATE){
							if(restackClientListWindow(&clientListStackingSystem, eventWindow, XCB_STACK_MODE_ABOVE, XCB_NONE)){
								changeClientListProperty(&clientListStackingSystem);
							}
						}
					}
				}
			}
		}
		jmp eventLoop;
		#undef  e
	}
	reparentNotifyEvent:{
		#define e /*-*/ ((xcb_reparent_notify_event_t *)event)
		const xcb_window_t eventWindow = (*e).window;
		const xcb_window_t parentWindow = (*e).parent;
		if(parentWindow == (*screen).root){
			xcb_get_geometry_cookie_t geometryCookie;
			xcb_get_window_attributes_cookie_t attributesCookie;
			xcb_get_geometry_reply_t *geometryReply;
			uint32 geometryToken;
			xcb_get_window_attributes_reply_t *attributesReply;
			uint32 attributesToken;
			int x;
			int y;
			uint width;
			uint height;
			uint border;
			uint8 class;
			bool overrideRedirect;
			bool mapped;
			if(findOwnedWindow(eventWindow) or findClientContainer(&clientSystem, eventWindow) or findClientWindow(&clientSystem, eventWindow)){
				jmp eventLoop;
			}
			geometryCookie = xcb_get_geometry(connection, eventWindow);
			attributesCookie = xcb_get_window_attributes(connection, eventWindow);
			geometryReply = xcb_get_geometry_reply(connection, geometryCookie, NULL);
			geometryToken = pushPointer(geometryReply, "get geometry reply", iFree);
			attributesReply = xcb_get_window_attributes_reply(connection, attributesCookie, NULL);
			attributesToken = pushPointer(attributesReply, "get window attributes reply", iFree);
			x = 0;
			y = 0;
			width = 1;
			height = 1;
			border = 0;
			class = XCB_WINDOW_CLASS_COPY_FROM_PARENT;
			overrideRedirect = false;
			mapped = false;
			if(geometryReply){
				x = (*geometryReply).x;
				y = (*geometryReply).y;
				width = (*geometryReply).width;
				height = (*geometryReply).height;
				border = (*geometryReply).border_width;
				free(geometryReply);
				popPointer(geometryToken);
			}
			if(attributesReply){
				class = (*attributesReply)._class;
				overrideRedirect = (*attributesReply).override_redirect;
				mapped = (*attributesReply).map_state != XCB_MAP_STATE_UNMAPPED;
				free(attributesReply);
				popPointer(attributesToken);
			}
/*!
			if(createClient(&clientSystem, &cursorSystem, eventWindow, x, y, width, height, border, class, overrideRedirect)){
				Client *const client = findClientWindow(&clientSystem, eventWindow);
				storeClientProperties(client);
				if(client and mapped){
					if((*client).option & OVERRIDE_REDIRECT_CLIENT_OPTION){
						jmp eventLoop;
					}
					if(!((*client).option & OVERRIDE_REDIRECT_CLIENT_OPTION)){
						if((*client).desktop == NONE_DESKTOP){
							if(setClientVirtualRoot(&virtualRootSystem, &clientSystem, client, virtualRootSystem.currentDesktop)){
								changeVirtualRootClientDesktop(&virtualRootSystem, &clientSystem, client);
							}
						}
					}
					if(mapClient(&clientSystem, &monitorSystem, client, POINTER_WHICH_MONITOR)){
						if(!((*client).option & OVERRIDE_REDIRECT_CLIENT_OPTION) and !(*client).strut){
							if(!findClientListWindow(&clientListSystem, eventWindow)){
								if(addClientListWindow(&clientListSystem, eventWindow)){
									if((*client).stateState == ICONIC_STATE){
										restackClientListWindow(&clientListSystem, eventWindow, XCB_STACK_MODE_BELOW, XCB_NONE);
									}
									changeClientListProperty(&clientListSystem);
								}
							}else{
								if((*client).stateState == NORMAL_STATE){
									if(restackClientListWindow(&clientListSystem, eventWindow, XCB_STACK_MODE_ABOVE, XCB_NONE)){
										changeClientListProperty(&clientListSystem);
									}
								}
							}
							if(!findClientListWindow(&clientListStackingSystem, eventWindow)){
								if(addClientListWindow(&clientListStackingSystem, eventWindow)){
									if((*client).stateState == ICONIC_STATE){
										restackClientListWindow(&clientListStackingSystem, eventWindow, XCB_STACK_MODE_BELOW, XCB_NONE);
									}
									changeClientListProperty(&clientListStackingSystem);
								}
							}else{
								if((*client).stateState == NORMAL_STATE){
									if(restackClientListWindow(&clientListStackingSystem, eventWindow, XCB_STACK_MODE_ABOVE, XCB_NONE)){
										changeClientListProperty(&clientListStackingSystem);
									}
								}
							}
						}
					}
				}
			}
*/
			jmp eventLoop;
		}else{
			Client *client;
			if((client = findClientWindow(&clientSystem, eventWindow))){
/*!
				uint8 state = (*client).stateState;
				if(destroyClient(&clientSystem, client)){
					if(state == NORMAL_STATE){
						state = (*client).stateState;
						(*client).stateState = NORMAL_STATE;
						if(removeVirtualRootClientWorkarea(&virtualRootSystem, &monitorSystem, &clientSystem, client)){
							updateVirtualRootStrutedClients(&virtualRootSystem, &monitorSystem, &clientSystem, client, REMOVE_UPDATE_WORKAREA_ACTION);
							updateVirtualRootWorkareaClients(&virtualRootSystem, &monitorSystem, &clientSystem);
							if(setVirtualRootWorkarea(&virtualRootSystem, &monitorSystem)){
								changeVirtualRootWorkarea(&virtualRootSystem);
							}
						}
						(*client).stateState = state;
					}
					if(removeClientListWindow(&clientListSystem, eventWindow)){
						changeClientListProperty(&clientListSystem);
					}
					if(removeClientListWindow(&clientListStackingSystem, eventWindow)){
						changeClientListProperty(&clientListStackingSystem);
					}
				}
*/
			}
			jmp eventLoop;
		}
		jmp eventLoop;
		#undef  e
	}
	configureNotifyEvent:{
		#define e /*-*/ ((xcb_configure_notify_event_t *)event)
		Client *client;
		if((client = findConfiguredClientWindow(&clientSystem, (*e).window))){
			xcb_window_t sibling;
			uint8 stackMode;
			if(!((*client).option & OVERRIDE_REDIRECT_CLIENT_OPTION)){
				xcb_configure_window(connection, (*client).container, XCB_CONFIG_WINDOW_X | XCB_CONFIG_WINDOW_Y | XCB_CONFIG_WINDOW_WIDTH | XCB_CONFIG_WINDOW_HEIGHT, &(*client).containerX);
				jmp eventLoop;
			}
			(*client).windowX = (*e).x;
			(*client).windowY = (*e).y;
			(*client).windowWidth = (*e).width;
			(*client).windowHeight = (*e).height;
			(*client).windowBorder = (*e).border_width;
			sibling = (*e).above_sibling;
			stackMode = XCB_STACK_MODE_BELOW;
			if(sibling){
				stackMode = XCB_STACK_MODE_ABOVE;
			}
			restackClient(&clientSystem, client, stackMode, sibling);
		}
		jmp eventLoop;
		#undef  e
	}
	configureRequestEvent:{
		#define e /*-*/ ((xcb_configure_request_event_t *)event)
		uint8 valueMask = (*e).value_mask;
		Client *client;
		if((client = findConfiguredClientWindow(&clientSystem, (*e).window))){
			if((*client).option & OVERRIDE_REDIRECT_CLIENT_OPTION or client == clientSystem.clientStart + clientSystem.motionClientOffset or (*client).stateState == ICONIC_STATE){
				jmp eventLoop;
			}
			if(!((*client).allowedAction & MOVE_ALLOWED_ACTION)){
				valueMask &= ~(XCB_CONFIG_WINDOW_X | XCB_CONFIG_WINDOW_Y);
			}
			if(!((*client).allowedAction & RESIZE_ALLOWED_ACTION)){
				valueMask &= ~(XCB_CONFIG_WINDOW_X | XCB_CONFIG_WINDOW_Y | XCB_CONFIG_WINDOW_WIDTH | XCB_CONFIG_WINDOW_HEIGHT | XCB_CONFIG_WINDOW_BORDER_WIDTH);
			}
			if(false){
				valueMask &= ~(XCB_CONFIG_WINDOW_SIBLING | XCB_CONFIG_WINDOW_STACK_MODE);
			}
			if(valueMask & (XCB_CONFIG_WINDOW_WIDTH | XCB_CONFIG_WINDOW_HEIGHT | XCB_CONFIG_WINDOW_BORDER_WIDTH)){
				uint32 windowValueList[3];
				uint32 containerValueList[5];
				void *windowCurrent = windowValueList;
				void *containerCurrent = containerValueList;
				if(valueMask & XCB_CONFIG_WINDOW_X){
					(*client).containerX = (*e).x;
					*(int32 *)containerCurrent = (*client).containerX;
					containerCurrent = (int32 *)containerCurrent + 1;
				}
				if(valueMask & XCB_CONFIG_WINDOW_Y){
					(*client).containerY = (*e).y;
					*(int32 *)containerCurrent = (*client).containerY;
					containerCurrent = (int32 *)containerCurrent + 1;
				}
				if(valueMask & XCB_CONFIG_WINDOW_BORDER_WIDTH){
					(*client).windowBorder = (*e).border_width;
					*(int32 *)windowCurrent = (*client).windowBorder;
					windowCurrent = (int32 *)windowCurrent + 1;
				}
				if(valueMask & XCB_CONFIG_WINDOW_WIDTH){
					(*client).windowWidth = (*e).width;
					*(int32 *)windowCurrent = (*client).windowWidth;
					windowCurrent = (int32 *)windowCurrent + 1;
					(*client).containerWidth = (*client).windowWidth + 2 * (*client).windowBorder + (*client).frameExtentsLeft + (*client).frameExtentsRight;
					*(int32 *)containerCurrent = (*client).containerWidth;
					containerCurrent = (int32 *)containerCurrent + 1;
				}
				if(valueMask & XCB_CONFIG_WINDOW_HEIGHT){
					(*client).windowHeight = (*e).height;
					*(int32 *)windowCurrent = (*client).windowHeight;
					windowCurrent = (int32 *)windowCurrent + 1;
					(*client).containerHeight = (*client).windowHeight + 2 * (*client).windowBorder + (*client).frameExtentsTop + (*client).frameExtentsBottom;
					*(int32 *)containerCurrent = (*client).containerHeight;
					containerCurrent = (int32 *)containerCurrent + 1;
				}
				if(valueMask & XCB_CONFIG_WINDOW_STACK_MODE){
					if(restackClient(&clientSystem, client, (*e).stack_mode, !!(valueMask & XCB_CONFIG_WINDOW_SIBLING) * (*e).sibling)){
						configureClient(&clientSystem, client);
						configureVirtualRootClient(&virtualRootSystem, &clientSystem, client);
						if(configureClientListClient(&clientListStackingSystem, &clientSystem, client)){
							changeClientListProperty(&clientListStackingSystem);
						}
					}
				}
				xcb_discard_reply(connection, xcb_configure_window_checked(connection, (*client).window, valueMask & (XCB_CONFIG_WINDOW_WIDTH | XCB_CONFIG_WINDOW_HEIGHT | XCB_CONFIG_WINDOW_BORDER_WIDTH), windowValueList));
				(*client).option &= ~(HORIZONTALLY_MAXIMIZED_CLIENT_OPTION | VERTICALLY_MAXIMIZED_CLIENT_OPTION);
				(*client).workareaPosition = NONE_WORKAREA_POSITION;
			}else{
				if(valueMask & (XCB_CONFIG_WINDOW_X | XCB_CONFIG_WINDOW_Y | XCB_CONFIG_WINDOW_STACK_MODE)){
					uint32 valueList[2];
					void *current = valueList;
					if(valueMask & XCB_CONFIG_WINDOW_X){
						(*client).containerX = (*e).x;
						*(int32 *)current = (*client).containerX;
						current = (int32 *)current + 1;
					}
					if(valueMask & XCB_CONFIG_WINDOW_Y){
						(*client).containerY = (*e).y;
						*(int32 *)current = (*client).containerY;
						current = (int32 *)current + 1;
					}
					if(valueMask & XCB_CONFIG_WINDOW_STACK_MODE){
						if(restackClient(&clientSystem, client, (*e).stack_mode, !!(valueMask & XCB_CONFIG_WINDOW_SIBLING) * (*e).sibling)){
							configureClient(&clientSystem, client);
							configureVirtualRootClient(&virtualRootSystem, &clientSystem, client);
							if(configureClientListClient(&clientListStackingSystem, &clientSystem, client)){
								changeClientListProperty(&clientListStackingSystem);
							}
						}
					}
					(*client).option &= ~(HORIZONTALLY_MAXIMIZED_CLIENT_OPTION | VERTICALLY_MAXIMIZED_CLIENT_OPTION);
					(*client).workareaPosition = NONE_WORKAREA_POSITION;
				}
				sendClientConfigureEvent(&clientSystem, client);
			}
		}
		jmp eventLoop;
		#undef  e
	}
	resizeRequestEvent:{
		#define e /*-*/ ((xcb_resize_request_event_t *)event)
		/*!*/
		jmp eventLoop;
		#undef  e
	}
	circulateNotifyEvent:{
		#define e /*-*/ ((xcb_circulate_notify_event_t *)event)
		Client *client;
		if((client = findClientWindow(&clientSystem, (*e).event))){
			uint8 stackMode;
			if(!((*client).option & OVERRIDE_REDIRECT_CLIENT_OPTION)){
				jmp eventLoop;
			}
			stackMode = XCB_STACK_MODE_BELOW;
			if((*e).place == XCB_PLACE_ON_TOP){
				stackMode = XCB_STACK_MODE_ABOVE;
			}
			restackClient(&clientSystem, client, stackMode, XCB_NONE);
			if(stackMode == XCB_STACK_MODE_BELOW){
				restackVirtualRootBelow(&virtualRootSystem);
			}
		}
		jmp eventLoop;
		#undef  e
	}
	circulateRequestEvent:{
		#define e /*-*/ ((xcb_circulate_request_event_t *)event)
		Client *client;
		if((client = findClientWindow(&clientSystem, (*e).event))){
			uint8 stackMode;
			if((*client).option & OVERRIDE_REDIRECT_CLIENT_OPTION){
				jmp eventLoop;
			}
			stackMode = XCB_STACK_MODE_BELOW;
			if((*e).place == XCB_PLACE_ON_TOP){
				stackMode = XCB_STACK_MODE_ABOVE;
			}
			if(restackClient(&clientSystem, client, stackMode, XCB_NONE)){
				configureClient(&clientSystem, client);
				configureVirtualRootClient(&virtualRootSystem, &clientSystem, client);
				if(configureClientListClient(&clientListStackingSystem, &clientSystem, client)){
					changeClientListProperty(&clientListStackingSystem);
				}
			}
		}
		jmp eventLoop;
		#undef  e
	}
	propertyNotifyEvent:{
		#define e /*-*/ ((xcb_property_notify_event_t *)event)
		const xcb_atom_t eventWindow = (*e).window;
		const xcb_atom_t property = (*e).atom;
		Client *client;
		VirtualRoot *virtualRoot;
		if(!eventWindow or !property){
			jmp eventLoop;
		}
		if(eventWindow == (*screen).root){
			xcb_get_property_reply_t *reply;
			uint32 token;
			uint32 desktopLayoutOrientation = _NET_WM_ORIENTATION_HORZ;
			uint32 desktopLayoutColumns = 0;
			uint32 desktopLayoutRows = 0;
			uint32 desktopLayoutStartingCorner = _NET_WM_TOPLEFT;
			reply = xcb_wait_for_reply(connection, xcb_get_property_unchecked(connection, false, eventWindow, property, XCB_GET_PROPERTY_TYPE_ANY, 0, 0xFFFFFFFF), NULL);
			token = pushPointer(reply, "propertyNotifyEvent: get property reply", iFree);
			if(reply){
				const uint size = (*reply).format / 8;
				const void *const value = xcb_get_property_value(reply);
				uint length = xcb_get_property_value_length(reply);
				VirtualRoot *current = virtualRootSystem.virtualRootStart;
				VirtualRoot *const wall = current + virtualRootSystem.virtualRootAllocated;
				if(property == atom._NET_DESKTOP_LAYOUT and (*e).state == XCB_PROPERTY_NEW_VALUE and length == 4 * sizeof(uint32)){
					desktopLayoutColumns = *((uint32 *)value + 1);
					desktopLayoutRows = *((uint32 *)value + 2);
					desktopLayoutOrientation = *((uint32 *)value + 0);
					desktopLayoutStartingCorner = *((uint32 *)value + 3);
				}
				if(size){
					length /= size;
				}
				jmp updateVirtualRootPropertyLoop;
				updateVirtualRootPropertyLoop:{
					if(current < wall){
						if((*e).state == XCB_PROPERTY_DELETE){
							xcb_discard_reply(connection, xcb_delete_property_checked(connection, (*current).window, property));
						}else{
							xcb_discard_reply(connection, xcb_change_property_checked(connection, XCB_PROP_MODE_REPLACE, (*current).window, property, (*reply).type, (*reply).format, length, value));
						}
						inc current;
						jmp updateVirtualRootPropertyLoop;
					}
					free(reply);
					popPointer(token);
				}
			}
			if(property == atom.WM_ICON_SIZE){
				struct{
					uint32 /*-*/ minWidth;
					uint32 /*-*/ minHeight;
					uint32 /*-*/ maxWidth;
					uint32 /*-*/ maxHeight;
					uint32 /*-*/ widthInc;
					uint32 /*-*/ heightInc;
				} iconSize;
				iconSize.minWidth = 16;
				iconSize.minHeight = 16;
				iconSize.maxWidth = 16;
				iconSize.maxHeight = 16;
				iconSize.widthInc = 0;
				iconSize.heightInc = 0;
				resetProperty(eventWindow, property, XCB_ATOM_CARDINAL, sizeof(uint32), sizeof(iconSize) / sizeof(uint32), &iconSize);
				jmp eventLoop;
			}
			if(property == atom._NET_SUPPORTED){
				setNetSupported();
				jmp eventLoop;
			}
			if(property == atom._NET_CLIENT_LIST){
				resetProperty(eventWindow, property, XCB_ATOM_WINDOW, sizeof(xcb_window_t), clientListSystem.clientAllocated, clientListSystem.clientStart);
				jmp eventLoop;
			}
			if(property == atom._NET_CLIENT_LIST_STACKING){
				resetProperty(eventWindow, property, XCB_ATOM_WINDOW, sizeof(xcb_window_t), clientListStackingSystem.clientAllocated, clientListStackingSystem.clientStart);
				jmp eventLoop;
			}
			if(property == atom._NET_NUMBER_OF_DESKTOPS){
				resetProperty(eventWindow, property, XCB_ATOM_CARDINAL, sizeof(uint32), 1, &virtualRootSystem.virtualRootAllocated);
				jmp eventLoop;
			}
			if(property == atom._NET_DESKTOP_GEOMETRY){
				resetProperty((*screen).root, property, XCB_ATOM_CARDINAL, sizeof(uint32), 2, &virtualRootSystem.width);
				jmp eventLoop;
			}
			if(property == atom._NET_DESKTOP_VIEWPORT){
				resetProperty(eventWindow, property, XCB_ATOM_CARDINAL, sizeof(int32), 2 * virtualRootSystem.virtualRootAllocated, virtualRootSystem.viewportStart);
				jmp eventLoop;
			}
			if(property == atom._NET_CURRENT_DESKTOP){
				resetProperty(eventWindow, property, XCB_ATOM_CARDINAL, sizeof(uint32), 1, &virtualRootSystem.currentDesktop);
				jmp eventLoop;
			}
			if(property == atom._NET_DESKTOP_NAMES){
				resetProperty(eventWindow, property, atom.UTF8_STRING, sizeof(uint8), virtualRootSystem.desktopNamesSize, virtualRootSystem.desktopNamesStart);
				jmp eventLoop;
			}
			if(property == atom._NET_ACTIVE_WINDOW){
				Client *const client = getFocusedClient(&clientSystem);
				xcb_window_t activeWindow = XCB_NONE;
				if(client){
					activeWindow = (*client).window;
				}
				resetProperty(eventWindow, property, XCB_ATOM_WINDOW, sizeof(xcb_window_t), 1, &activeWindow);
				jmp eventLoop;
			}
			if(property == atom._NET_WORKAREA){
				resetProperty(eventWindow, property, XCB_ATOM_CARDINAL, sizeof(uint32), virtualRootSystem.virtualRootAllocated * 4, virtualRootSystem.workareaStart);
				jmp eventLoop;
			}
			if(property == atom._NET_SUPPORTING_WM_CHECK){
				resetProperty(eventWindow, property, XCB_ATOM_WINDOW, sizeof(xcb_window_t), 1, &wmCheckWindow);
				jmp eventLoop;
			}
			if(property == atom._NET_VIRTUAL_ROOTS){
				resetProperty(eventWindow, property, XCB_ATOM_WINDOW, sizeof(xcb_window_t), virtualRootSystem.virtualRootAllocated, virtualRootSystem.windowStart);
				jmp eventLoop;
			}
			if(property == atom._NET_DESKTOP_LAYOUT){
				virtualRootSystem.desktopLayoutColumns = desktopLayoutColumns;
				virtualRootSystem.desktopLayoutRows = desktopLayoutRows;
				virtualRootSystem.desktopLayoutOrientation = desktopLayoutOrientation;
				virtualRootSystem.desktopLayoutStartingCorner = desktopLayoutStartingCorner;
				jmp eventLoop;
			}
			if(property == atom._NET_SHOWING_DESKTOP){
				resetProperty(eventWindow, property, XCB_ATOM_CARDINAL, sizeof(uint32), 1, &virtualRootSystem.showingDesktop);
				jmp eventLoop;
			}
			if(property == atom._NET_WM_NAME){
				resetProperty(eventWindow, property, atom.UTF8_STRING, sizeof(uint8), lengthof(PROGRAM_NAME), PROGRAM_NAME);
				jmp eventLoop;
			}
			if(property == atom._XROOTPMAP_ID){
				if(setWallpaperPixmap(&wallpaperSystem, &monitorSystem, atom._XROOTPMAP_ID)){
					setVirtualRootWallpaper(&virtualRootSystem, &wallpaperSystem);
				}
				jmp eventLoop;
			}
		}
		if((virtualRoot = findVirtualRoot(&virtualRootSystem, eventWindow))){
			xcb_get_property_reply_t *reply;
			uint32 token;
			if(!propertyExists((*screen).root, property)){
				if((*e).state == XCB_PROPERTY_NEW_VALUE){
					xcb_delete_property(connection, eventWindow, property);
				}
				jmp eventLoop;
			}
			reply = xcb_wait_for_reply(connection, xcb_get_property_unchecked(connection, false, (*screen).root, property, XCB_GET_PROPERTY_TYPE_ANY, 0, 0xFFFFFFFF), NULL);
			token = pushPointer(reply, "propertyNotifyEvent: get property reply", iFree);
			if(reply){
				const uint size = (*reply).format / 8;
				uint length = xcb_get_property_value_length(reply);
				if(size){
					length /= size;
				}
				resetProperty(eventWindow, property, (*reply).type, size, length, xcb_get_property_value(reply));
				free(reply);
				popPointer(token);
			}
			jmp eventLoop;
		}
		if((client = findClientWindow(&clientSystem, eventWindow))){
			if((*e).state == XCB_PROPERTY_DELETE){
				if((*client).container){
					xcb_delete_property(connection, (*client).container, property);
				}
				unstoreClientProperty(client, property);
			}else{
				xcb_get_property_reply_t *const reply = xcb_wait_for_reply(connection, xcb_get_property(connection, false, (*client).window, property, XCB_GET_PROPERTY_TYPE_ANY, 0, 0xFFFFFFFF), NULL);
				uint32 token = pushPointer(reply, "propertyNotifyEvent: get property reply", iFree);
				if(reply){
					const void *const value = xcb_get_property_value(reply);
					if((*client).container){
						const uint size = (*reply).format / 8;
						uint length = xcb_get_property_value_length(reply);
						if(size){
							length /= size;
						}
						xcb_change_property(connection, XCB_PROP_MODE_REPLACE, (*client).container, property, (*reply).type, (*reply).format, length, value);
					}
					storeClientProperty(client, property, xcb_get_property_value_length(reply), value);
					free(reply);
					popPointer(token);
				}
			}
			jmp eventLoop;
		}
		if((client = findClientContainer(&clientSystem, eventWindow))){
			xcb_get_property_reply_t *reply;
			uint32 token;
			if(!propertyExists((*client).window, property)){
				if((*e).state == XCB_PROPERTY_NEW_VALUE){
					xcb_delete_property(connection, (*client).container, property);
				}
				jmp eventLoop;
			}
			reply = xcb_wait_for_reply(connection, xcb_get_property(connection, false, (*client).window, property, XCB_GET_PROPERTY_TYPE_ANY, 0, 0xFFFFFFFF), NULL);
			token = pushPointer(reply, "propertyNotifyEvent: get property reply", iFree);
			if(reply){
				const uint size = (*reply).format / 8;
				uint length = xcb_get_property_value_length(reply);
				if(size){
					length /= size;
				}
				resetProperty((*client).container, property, (*reply).type, size, length, xcb_get_property_value(reply));
				free(reply);
				popPointer(token);
			}
			jmp eventLoop;
		}
		if(eventWindow == wmCheckWindow){
			if(property == atom._NET_WM_NAME){
				resetProperty(eventWindow, property, atom.UTF8_STRING, sizeof(uint8), lengthof(PROGRAM_NAME), PROGRAM_NAME);
				jmp eventLoop;
			}
			if(property == atom._NET_SUPPORTING_WM_CHECK){
				resetProperty(eventWindow, property, XCB_ATOM_WINDOW, sizeof(xcb_window_t), 1, &wmCheckWindow);
				jmp eventLoop;
			}
			if(propertyExists(eventWindow, property)){
				xcb_delete_property(connection, eventWindow, property);
				jmp eventLoop;
			}
			jmp eventLoop;
		}
		if(eventWindow == wmSelectionWindow){
			if(property == atom.MICRO_INIT){
				if((*e).state == XCB_PROPERTY_NEW_VALUE and !wmSelectionTimestamp){
					xcb_get_selection_owner_reply_t *reply;
					uint32 token;
					xcb_window_t owner = XCB_NONE;
					xcb_set_selection_owner(connection, wmSelectionWindow, atom.WM_Sn, getTimestamp());
					xcb_delete_property(connection, eventWindow, atom.MICRO_INIT);
					xcb_sync();
					reply = xcb_wait_for_reply(connection, xcb_get_selection_owner_unchecked(connection, atom.WM_Sn), NULL);
					token = pushPointer(reply, "propertyNotifyEvent: get selection owner reply", iFree);
					if(reply){
						owner = (*reply).owner;
						free(reply);
						popPointer(token);
					}
					if(!previousWMSelectionWindow){
						if(owner != wmSelectionWindow){
							printTitledError("selection error", "could not get ownership of WM_Sn selection");
							jmp mainEmergencyExit;
						}
						if(!initWindowManagerSystem()){
							jmp mainEmergencyExit;
						}
					}
				}
				jmp eventLoop;
			}
			jmp eventLoop;
		}
		jmp eventLoop;
		#undef  e
	}
	selectionClearEvent:{
		#define e /*-*/ ((xcb_selection_clear_event_t *)event)
		if((*e).selection == atom.WM_Sn and (*e).owner == wmSelectionWindow){
			jmp mainEmergencyExit;
		}
		jmp eventLoop;
		#undef  e
	}
	colormapNotifyEvent:{
		#define e /*-*/ ((xcb_colormap_notify_event_t *)event)
		jmp eventLoop;
		#undef  e
	}
	clientMessageEvent:{
		#define e /*------------------------*/ ((xcb_client_message_event_t *)event)
		#define NONE_SOURCE_INDICATION /*---*/ (0)
		#define NORMAL_SOURCE_INDICATION /*-*/ (1)
		#define PAGER_SOURCE_INDICATION /*--*/ (2)
		const xcb_window_t eventWindow = (*e).window;
		const xcb_atom_t property = (*e).type;
		const uint32 *const dataStart = (*e).data.data32;
		Client *client;
		if((*e).format != 32){
			jmp eventLoop;
		}
		if(!eventWindow){
			if(property == atom._NET_ACTIVE_WINDOW){
				switch(*dataStart){
					to NONE_SOURCE_INDICATION: /*---*/ brk;
					to NORMAL_SOURCE_INDICATION: /*-*/ brk;
					to PAGER_SOURCE_INDICATION: /*--*/ brk;
					off: /*-------------------------*/ brk;
				}
				loseFocus(&clientSystem);
				jmp eventLoop;
			}
			jmp eventLoop;
		}
		if(eventWindow == (*screen).root){
			if(property == atom._NET_NUMBER_OF_DESKTOPS){
				setVirtualRootAmount(&virtualRootSystem, &monitorSystem, &clientSystem, &cursorSystem, *dataStart);
				setVirtualRootWallpaper(&virtualRootSystem, &wallpaperSystem);
				jmp eventLoop;
			}
			if(property == atom._NET_DESKTOP_GEOMETRY){
				jmp eventLoop;
			}
			if(property == atom._NET_DESKTOP_VIEWPORT){
				jmp eventLoop;
			}
			if(property == atom._NET_CURRENT_DESKTOP){
				gotoVirtualRoot(&virtualRootSystem, &clientSystem, *dataStart, true);
				jmp eventLoop;
			}
			if(property == atom._NET_ACTIVE_WINDOW){
				switch(*dataStart){
					to NONE_SOURCE_INDICATION: /*---*/ brk;
					to NORMAL_SOURCE_INDICATION: /*-*/ brk;
					to PAGER_SOURCE_INDICATION: /*--*/ brk;
					off: /*-------------------------*/ brk;
				}
				loseFocus(&clientSystem);
				jmp eventLoop;
			}
			if(property == atom._NET_SHOWING_DESKTOP){
				showVirtualRootDesktop(&virtualRootSystem, &clientSystem, virtualRootSystem.currentDesktop, *dataStart);
				jmp eventLoop;
			}
			jmp eventLoop;
		}
		if((client = findClientWindow(&clientSystem, eventWindow))){
			if(property == atom.WM_CHANGE_STATE){
				uint8 state = (*client).stateState;
				if(state != NORMAL_STATE or *dataStart != ICONIC_STATE){
					jmp eventLoop;
				}
				if(unmapClient(&clientSystem, client, ICONIC_STATE)){
					if(state == NORMAL_STATE){
						state = (*client).stateState;
						(*client).stateState = NORMAL_STATE;
						if(removeVirtualRootClientWorkarea(&virtualRootSystem, &monitorSystem, &clientSystem, client)){
							updateVirtualRootStrutedClients(&virtualRootSystem, &monitorSystem, &clientSystem, client, REMOVE_UPDATE_WORKAREA_ACTION);
							updateVirtualRootWorkareaClients(&virtualRootSystem, &monitorSystem, &clientSystem);
							if(setVirtualRootWorkarea(&virtualRootSystem, &monitorSystem)){
								changeVirtualRootWorkarea(&virtualRootSystem);
							}
						}
						(*client).stateState = state;
					}



					/*!*/



					if((*client).stateState == WITHDRAWN_STATE){
						if(removeClientListWindow(&clientListSystem, eventWindow)){
							changeClientListProperty(&clientListSystem);
						}
						if(removeClientListWindow(&clientListStackingSystem, eventWindow)){
							changeClientListProperty(&clientListStackingSystem);
						}
						if((*client).desktop != 0xFFFFFFFF){
							moveClientToVirtualRoot(&virtualRootSystem, &monitorSystem, &clientSystem, client, NONE_DESKTOP, true);
						}
					}
				}
				jmp eventLoop;
			}
			if(property == atom.WM_COLORMAP_NOTIFY){
				jmp eventLoop;
			}
			if(property == atom._NET_ACTIVE_WINDOW){
				switch(*dataStart){
					to NONE_SOURCE_INDICATION: /*---*/ brk;
					to NORMAL_SOURCE_INDICATION: /*-*/ brk;
					to PAGER_SOURCE_INDICATION: /*--*/ brk;
					off: /*-------------------------*/ brk;
				}
				setFocusedClient(&clientSystem, client, virtualRootSystem.currentDesktop);
				jmp eventLoop;
			}
			if(property == atom._NET_CLOSE_WINDOW){
				switch(*(dataStart + 1)){
					to NONE_SOURCE_INDICATION: /*---*/ brk;
					to NORMAL_SOURCE_INDICATION: /*-*/ brk;
					to PAGER_SOURCE_INDICATION: /*--*/ brk;
					off: /*-------------------------*/ brk;
				}
				if(!closeClient(&clientSystem, client, CLOSE_CLOSE_CLIENT_COMMAND)){
					closeClient(&clientSystem, client, KILL_CLOSE_CLIENT_COMMAND);
				}
				jmp eventLoop;
			}
			if(property == atom._NET_MOVERESIZE_WINDOW){
				jmp eventLoop;
			}
			if(property == atom._NET_WM_MOVERESIZE){
				jmp eventLoop;
			}
			if(property == atom._NET_RESTACK_WINDOW){
				switch(*dataStart){
					to NONE_SOURCE_INDICATION: /*---*/ brk;
					to NORMAL_SOURCE_INDICATION: /*-*/ brk;
					to PAGER_SOURCE_INDICATION: /*--*/ brk;
					off: /*-------------------------*/ brk;
				}
				if(restackClient(&clientSystem, client, *(dataStart + 2), *(dataStart + 1))){
					configureClient(&clientSystem, client);
					configureVirtualRootClient(&virtualRootSystem, &clientSystem, client);
					if(configureClientListClient(&clientListStackingSystem, &clientSystem, client)){
						changeClientListProperty(&clientListStackingSystem);
					}
				}
				jmp eventLoop;
			}
			if(property == atom._NET_REQUEST_FRAME_EXTENTS){
				if((*client).stateState == WITHDRAWN_STATE){
					xcb_discard_reply(connection, xcb_change_property_checked(connection, XCB_PROP_MODE_REPLACE, eventWindow, atom._NET_FRAME_EXTENTS, XCB_ATOM_CARDINAL, bitsof(uint32), 4, &(*client).frameExtentsLeft));
				}
				jmp eventLoop;
			}
			if(property == atom._NET_WM_DESKTOP){
				switch(*(dataStart + 1)){
					to NONE_SOURCE_INDICATION: /*---*/ brk;
					to NORMAL_SOURCE_INDICATION: /*-*/ brk;
					to PAGER_SOURCE_INDICATION: /*--*/ brk;
					off: /*-------------------------*/ brk;
				}
				moveClientToVirtualRoot(&virtualRootSystem, &monitorSystem, &clientSystem, client, *dataStart, true);
				jmp eventLoop;
			}
			if(property == atom._NET_WM_STATE){
				uint8 action;
				xcb_atom_t property0;
				xcb_atom_t property1;
				uint16 state;
				switch(*(dataStart + 3)){
					to NONE_SOURCE_INDICATION: /*---*/ brk;
					to NORMAL_SOURCE_INDICATION: /*-*/ brk;
					to PAGER_SOURCE_INDICATION: /*--*/ brk;
					off: /*-------------------------*/ brk;
				}
				action = *(dataStart + 0);
				switch(action){
					to _NET_WM_STATE_ADD: /*----*/ brk;
					to _NET_WM_STATE_REMOVE: /*-*/ brk;
					to _NET_WM_STATE_TOGGLE: /*-*/ brk;
					off: /*---------------------*/ jmp eventLoop;
				}
				property0 = *(dataStart + 1);
				property1 = *(dataStart + 2);
				state = NONE_STATE;
				if(property0){
					if(property0 == atom._NET_WM_STATE_MODAL){
						state |= MODAL_STATE;
					}elif(property0 == atom._NET_WM_STATE_STICKY){
						state |= STICKY_STATE;
					}elif(property0 == atom._NET_WM_STATE_MAXIMIZED_HORZ){
						state |= MAXIMIZED_HORZ_STATE;
					}elif(property0 == atom._NET_WM_STATE_MAXIMIZED_VERT){
						state |= MAXIMIZED_VERT_STATE;
					}elif(property0 == atom._NET_WM_STATE_SHADED){
						state |= SHADED_STATE;
					}elif(property0 == atom._NET_WM_STATE_SKIP_TASKBAR){
						state |= SKIP_TASKBAR_STATE;
					}elif(property0 == atom._NET_WM_STATE_SKIP_PAGER){
						state |= SKIP_PAGER_STATE;
					}elif(property0 == atom._NET_WM_STATE_HIDDEN){
						state |= HIDDEN_STATE;
					}elif(property0 == atom._NET_WM_STATE_FULLSCREEN){
						state |= FULLSCREEN_STATE;
					}elif(property0 == atom._NET_WM_STATE_ABOVE){
						state |= ABOVE_STATE;
					}elif(property0 == atom._NET_WM_STATE_BELOW){
						state |= BELOW_STATE;
					}elif(property0 == atom._NET_WM_STATE_DEMANDS_ATTENTION){
						state |= DEMANDS_ATTENTION_STATE;
					}
				}
				if(property1){
					if(property1 == atom._NET_WM_STATE_MODAL){
						state |= MODAL_STATE;
					}elif(property1 == atom._NET_WM_STATE_STICKY){
						state |= STICKY_STATE;
					}elif(property1 == atom._NET_WM_STATE_MAXIMIZED_HORZ){
						state |= MAXIMIZED_HORZ_STATE;
					}elif(property1 == atom._NET_WM_STATE_MAXIMIZED_VERT){
						state |= MAXIMIZED_VERT_STATE;
					}elif(property1 == atom._NET_WM_STATE_SHADED){
						state |= SHADED_STATE;
					}elif(property1 == atom._NET_WM_STATE_SKIP_TASKBAR){
						state |= SKIP_TASKBAR_STATE;
					}elif(property1 == atom._NET_WM_STATE_SKIP_PAGER){
						state |= SKIP_PAGER_STATE;
					}elif(property1 == atom._NET_WM_STATE_HIDDEN){
						state |= HIDDEN_STATE;
					}elif(property1 == atom._NET_WM_STATE_FULLSCREEN){
						state |= FULLSCREEN_STATE;
					}elif(property1 == atom._NET_WM_STATE_ABOVE){
						state |= ABOVE_STATE;
					}elif(property1 == atom._NET_WM_STATE_BELOW){
						state |= BELOW_STATE;
					}elif(property1 == atom._NET_WM_STATE_DEMANDS_ATTENTION){
						state |= DEMANDS_ATTENTION_STATE;
					}
				}
				state &= ~(MODAL_STATE | STICKY_STATE | SHADED_STATE | HIDDEN_STATE | ABOVE_STATE | BELOW_STATE | DEMANDS_ATTENTION_STATE);
				if(!state){
					jmp eventLoop;
				}
				if(state & MODAL_STATE){
					state &= ~(MODAL_STATE);
					if(!state){
						jmp eventLoop;
					}
				}
				if(state & STICKY_STATE){
					state &= ~(STICKY_STATE);
					if(!state){
						jmp eventLoop;
					}
				}
				if(state & (MAXIMIZED_HORZ_STATE | MAXIMIZED_VERT_STATE)){
					if((state & (MAXIMIZED_HORZ_STATE | MAXIMIZED_VERT_STATE)) == (MAXIMIZED_HORZ_STATE | MAXIMIZED_VERT_STATE)){
						if(((*client).state & (MAXIMIZED_HORZ_STATE | MAXIMIZED_VERT_STATE)) != (MAXIMIZED_HORZ_STATE | MAXIMIZED_VERT_STATE)){
							if(action == _NET_WM_STATE_ADD or action == _NET_WM_STATE_TOGGLE){
								maximizeClient(&virtualRootSystem, &monitorSystem, &clientSystem, client, POINTER_WHICH_MONITOR);
							}
						}else{
							if(action == _NET_WM_STATE_REMOVE or action == _NET_WM_STATE_TOGGLE){
								unmaximizeClient(&virtualRootSystem, &monitorSystem, &clientSystem, client);
							}
						}
					}
					state &= ~(MAXIMIZED_HORZ_STATE | MAXIMIZED_VERT_STATE);
					if(!state){
						jmp eventLoop;
					}
				}
				if(state & SHADED_STATE){
					state &= ~(SHADED_STATE);
					if(!state){
						jmp eventLoop;
					}
				}
				if(state & SKIP_TASKBAR_STATE){
					state &= ~(SKIP_TASKBAR_STATE);
					if(!state){
						jmp eventLoop;
					}
				}
				if(state & SKIP_PAGER_STATE){
					state &= ~(SKIP_PAGER_STATE);
					if(!state){
						jmp eventLoop;
					}
				}
				if(state & HIDDEN_STATE){
					state &= ~(HIDDEN_STATE);
					if(!state){
						jmp eventLoop;
					}
				}
				if(state & FULLSCREEN_STATE){
					if(!((*client).state & FULLSCREEN_STATE)){
						if(action == _NET_WM_STATE_ADD or action == _NET_WM_STATE_TOGGLE){
							if(fullscreenClient(&virtualRootSystem, &monitorSystem, &clientSystem, client, POINTER_WHICH_MONITOR)){
								if(setClientOrderType(&clientSystem, client)){
									if(restackClient(&clientSystem, client, XCB_STACK_MODE_ABOVE, XCB_NONE)){
										configureClient(&clientSystem, client);
										configureVirtualRootClient(&virtualRootSystem, &clientSystem, client);
										if(configureClientListClient(&clientListStackingSystem, &clientSystem, client)){
											changeClientListProperty(&clientListStackingSystem);
										}
									}
								}
							}
						}
					}else{
						if(action == _NET_WM_STATE_REMOVE or action == _NET_WM_STATE_TOGGLE){
							if(unfullscreenClient(&virtualRootSystem, &monitorSystem, &clientSystem, client)){
								if(setClientOrderType(&clientSystem, client)){
									if(restackClient(&clientSystem, client, XCB_STACK_MODE_ABOVE, XCB_NONE)){
										configureClient(&clientSystem, client);
										configureVirtualRootClient(&virtualRootSystem, &clientSystem, client);
										if(configureClientListClient(&clientListStackingSystem, &clientSystem, client)){
											changeClientListProperty(&clientListStackingSystem);
										}
									}
								}
							}
						}
					}
					state &= ~(FULLSCREEN_STATE);
					if(!state){
						jmp eventLoop;
					}
				}
				if(state & ABOVE_STATE){
					/*!*/
					state &= ~(ABOVE_STATE);
					if(!state){
						jmp eventLoop;
					}
				}
				if(state & BELOW_STATE){
					/*!*/
					state &= ~(BELOW_STATE);
					if(!state){
						jmp eventLoop;
					}
				}
				if(state & DEMANDS_ATTENTION_STATE){
					/*!*/
					state &= ~(DEMANDS_ATTENTION_STATE);
				}
				jmp eventLoop;
			}
			jmp eventLoop;
		}
		jmp eventLoop;
		#undef  PAGER_SOURCE_INDICATION
		#undef  NORMAL_SOURCE_INDICATION
		#undef  NONE_SOURCE_INDICATION
		#undef  e
	}
	genericEvent:{
		#define e /*-*/ ((xcb_ge_generic_event_t *)event)
		printXEvent(baseEventName);
		jmp unhandledEvent;
		#undef  e
	}
	extensionEvent:{
		#define isExtensionEvent(e) /*-*/ (eventType >= e##BaseEvent and eventType < e##BaseEvent + countof(e##EventName) - 1)
		const uint8 eventType = (*event).response_type & ~b(10000000);
		if(isExtensionEvent(randr)) /*--*/ jmp switchRandrEvent;
		if(isExtensionEvent(shape)) /*--*/ jmp switchShapeEvent;
		if(isExtensionEvent(xfixes)) /*-*/ jmp switchXfixesEvent;
		printXEvent(baseEventName);
		jmp unhandledEvent;
		#undef  isExtensionEvent
	}
	switchRandrEvent:{
		printXEvent(randrEventName);
		switch(((*event).response_type & ~b(10000000)) - randrBaseEvent){
			to XCB_RANDR_SCREEN_CHANGE_NOTIFY:
			to XCB_RANDR_NOTIFY:{
				struct{
					int32 /*--*/ x;
					int32 /*--*/ y;
					uint32 /*-*/ width;
					uint32 /*-*/ height;
				} valueList;
				if(globalsLockCreated and pthread_rwlock_unlock(&globalsLock) != PTHREAD_RWLOCK_UNLOCK_SUCCESS){
					printTitledError("pthread error", "could not unlock globals read lock");
				}
				if(globalsLockCreated and pthread_rwlock_wrlock(&globalsLock) != PTHREAD_RWLOCK_WRLOCK_SUCCESS){
					printTitledError("pthread error", "could not lock globals write lock");
				}
				{
					int screenNumber;
					xcb_connection_t *const connection = xcb_connect_to_display_with_auth_info(connectionName, NULL, &screenNumber);
					uint32 token = pushPointer(connection, "X connection", iXCBDisconnect);
					if(connection){
						xcb_screen_t *const screen = xcb_setup_roots_iterator(xcb_get_setup(connection)).data + screenNumber;
						if(screen){
							screenWidthInPixels = (*screen).width_in_pixels;
							screenHeightInPixels = (*screen).height_in_pixels;
							screenWidthInMillimeters = (*screen).width_in_millimeters;
							screenHeightInMillimeters = (*screen).height_in_millimeters;
						}else{
							screenWidthInPixels = 0;
							screenHeightInPixels = 0;
							screenWidthInMillimeters = 0;
							screenHeightInMillimeters = 0;
						}
						xcb_disconnect(connection);
						popPointer(token);
					}
				}
				valueList.x = 0;
				valueList.y = 0;
				valueList.width = screenWidthInPixels;
				valueList.height = screenHeightInPixels;
				xcb_configure_window(connection, glassWindow, XCB_CONFIG_WINDOW_X | XCB_CONFIG_WINDOW_Y | XCB_CONFIG_WINDOW_WIDTH | XCB_CONFIG_WINDOW_HEIGHT, &valueList);
				createMonitors(&monitorSystem);
				createWallpaper(&wallpaperSystem, &monitorSystem, screenWidthInPixels, screenHeightInPixels);
				resizeVirtualRoot(&virtualRootSystem, &monitorSystem, &wallpaperSystem, &clientSystem, screenWidthInPixels, screenHeightInPixels);
				setVirtualRootWallpaper(&virtualRootSystem, &wallpaperSystem);
				/*! change root properties... maybe? do we change them already or no? */
				jmp eventLoop;
			}
			off:{
				jmp unrecognizedEvent;
			}
		}
	}
	switchShapeEvent:{
		printXEvent(shapeEventName);
		switch(((*event).response_type & ~b(10000000)) - shapeBaseEvent){
			to XCB_SHAPE_NOTIFY:{
				#define e /*-*/ ((xcb_shape_notify_event_t *)event)
				/*!*/
				jmp eventLoop;
				#undef  e
			}
			off:{
				jmp unrecognizedEvent;
			}
		}
	}
	switchXfixesEvent:{
		printXEvent(xfixesEventName);
		switch(((*event).response_type & ~b(10000000)) - xfixesBaseEvent){
			to XCB_XFIXES_SELECTION_NOTIFY: /*-*/ jmp eventLoop;
			to XCB_XFIXES_CURSOR_NOTIFY: /*----*/ jmp eventLoop;
			off: /*----------------------------*/ jmp unrecognizedEvent;
		}
	}
	unrecognizedEvent:{
		printTitledValuedError("X event error", "unrecognized event with type", (*event).response_type & ~b(10000000));
		jmp eventLoop;
	}
	unexpectedEvent:{
		printTitledValuedError("unexpected X event", "unexpected event with type", (*event).response_type & ~b(10000000));
		jmp eventLoop;
	}
	unhandledEvent:{
		printTitledValuedError("X event error", "unhandled event with type", (*event).response_type & ~b(10000000));
		jmp eventLoop;
	}
	mainEmergencyExit:{
		cleanup();
		ret 0;
	}
}
QUIT(){
	const char *message;
	const Pointer *start;
	const Pointer *current;
	const Pointer *wall;
	jmp evaluateHandlerAvailability;
	evaluateHandlerAvailability:{
		if(quitting){
			switch(signal){
				to SIGABRT: /*-*/ brk;
				to SIGBUS: /*--*/ brk;
				to SIGFPE: /*--*/ brk;
				to SIGILL: /*--*/ brk;
				to SIGSEGV: /*-*/ brk;
				to SIGTRAP: /*-*/ brk;
				off: /*--------*/ ret;
			}
			printTitledNamedError("quitting error", "could not free", labelExamined);
			jmp exit;
		}
		if(processingSignal and signal != SIGINT){
			ret;
		}
		processingSignal = true;
		jmp findSignal;
	}
	findSignal: switch(signal){
		to SIGABRT: /*-*/ message = "aborted"; /*--------------*/ jmp exitWithError;
		to SIGBUS: /*--*/ message = "hardware faulted"; /*-----*/ jmp exitWithError;
		to SIGFPE: /*--*/ message = "programmer math'd up"; /*-*/ jmp exitWithError;
		to SIGILL: /*--*/ message = "executable corrupted"; /*-*/ jmp exitWithError;
		to SIGINT: /*--*/ message = "interrupted"; /*----------*/ jmp exitWithError;
		to SIGQUIT: /*-*/ message = "voluntarily quitted"; /*--*/ jmp exitWithError;
		to SIGSEGV: /*-*/ message = "segmentation faulted"; /*-*/ jmp exitWithError;
		to SIGTERM: /*-*/ message = "terminated"; /*-----------*/ jmp exitWithError;
		to SIGTRAP: /*-*/ message = "trapped"; /*--------------*/ jmp exitWithError;
		to SIGUSR1: /*-*/ /*-----------------------------------*/ jmp handleUserSignal;
		to SIGUSR2: /*-*/ /*-----------------------------------*/ jmp handleUserSignal;
		off: /*--------*/ message = "unhandled signal"; /*-----*/ jmp exitWithError;
	}
	handleUserSignal:{
		processingSignal = false;
		ret;
	}
	exitWithError:{
		quitting = true;
		finiSTDINSystem(&stdinSystem);
		finiSharedMemorySystem(&sharedMemorySystem);
		printTitledError("signal received", message);
		if(memoryManagerSystem.allocated <= 1){
			jmp exit;
		}
		start = memoryManagerSystem.data;
		current = start + 1;
		wall = start + memoryManagerSystem.allocated;
		switch(signal){
			to SIGABRT:
			to SIGBUS:
			to SIGFPE:
			to SIGILL:
			to SIGSEGV:
			to SIGTRAP:{
				printError("%s%s: %spointers at time of error:%s\n", colorStart, programName, colorError, colorEnd);
				if(memoryManagerSystem.allocated > 1){
					jmp printPointedVariables;
				}
				printError("none\n");
				jmp freePointedVariablesLoop;
			}
			off:{
				jmp freePointedVariablesLoop;
			}
		}
	}
	printPointedVariables:{
		printUnaccountedForPointers(current, wall);
		current = start + 1;
		jmp freePointedVariablesLoop;
	}
	freePointedVariablesLoop:{
		if((*current).data){
			labelExamined = (*current).label;
			(*current).free((*current).data);
		}
		if(inc current < wall){
			jmp freePointedVariablesLoop;
		}
		jmp exit;
	}
	exit:{
		finiMemorySystem();
		closeErrorStream();
		exit(EXIT_SUCCESS);
	}
}
REAPSPAWNEDPROCESSES(){
	#define ANY_CHILD /*-*/ (-1)
	(void)signal;
	jmp reapSpawnedProcessLoop;
	reapSpawnedProcessLoop:{
		if(waitpid(ANY_CHILD, NULL, WNOHANG) > 0){
			jmp reapSpawnedProcessLoop;
		}
		ret;
	}
	#undef  ANY_CHILD
}
INITMEMORYSYSTEM(){
	#define DYNAMIC_DATA_SEGMENT_BLOCK_SIZE /*-*/ (16)
	#define SHMGET_FAILURE /*------------------*/ (-1)
	memoryManagerSystem.size = 0;
	memoryManagerSystem.allocated = 0;
	memoryManagerSystem.data = NULL;
	memoryManagerSystem.mutexCreated = pthread_mutex_init(&memoryManagerSystem.mutex, NULL) == PTHREAD_MUTEX_INIT_SUCCESS;
	if(!memoryManagerSystem.mutexCreated){
		printTitledError("pthread error", "could not init memory system mutex");
	}
	ret true;
}
PUSHPOINTER(){
	uint32 token;
	if(!memoryManagerSystem.mutexCreated or !pointer){
		ret 0;
	}
	if(pthread_mutex_lock(&memoryManagerSystem.mutex) != PTHREAD_MUTEX_LOCK_SUCCESS){
		printTitledError("pthread error", "could not lock memory system mutex");
	}
	jmp pushPointer;
	pushPointer:{
		Pointer *data;
		if(memoryManagerSystem.allocated == memoryManagerSystem.size){
			void *temp;
			memoryManagerSystem.size += DYNAMIC_DATA_SEGMENT_BLOCK_SIZE;
			if(!(temp = realloc(memoryManagerSystem.data, memoryManagerSystem.size * sizeof(Pointer)))){
				memoryManagerSystem.size -= DYNAMIC_DATA_SEGMENT_BLOCK_SIZE;
				token = 0;
				jmp emergencyExit;
			}
			memoryManagerSystem.data = temp;
			if(!memoryManagerSystem.allocated){
				(*memoryManagerSystem.data).data = (void *)1;
				inc memoryManagerSystem.allocated;
			}
		}
		token = memoryManagerSystem.allocated;
		data = memoryManagerSystem.data + token;
		(*data).label = label;
		(*data).data = pointer;
		(*data).token = token;
		(*data).line = line;
		(*data).file = file;
		(*data).free = freeFunction;
		inc memoryManagerSystem.allocated;
		jmp emergencyExit;
	}
	emergencyExit:{
		if(memoryManagerSystem.mutexCreated and pthread_mutex_unlock(&memoryManagerSystem.mutex) != PTHREAD_MUTEX_UNLOCK_SUCCESS){
			printTitledError("pthread error", "could not unlock memory system mutex");
		}
		ret token;
	}
}
UPDATEPOINTER(){
	if(!memoryManagerSystem.mutexCreated or !memoryManagerSystem.data or !token or !pointer){
		ret false;
	}
	if(pthread_mutex_lock(&memoryManagerSystem.mutex) != PTHREAD_MUTEX_UNLOCK_SUCCESS){
		printTitledError("pthread error", "could not lock memory system mutex");
	}
	jmp updatePointer;
	updatePointer:{
		(*(memoryManagerSystem.data + token)).data = pointer;
		jmp emergencyExit;
	}
	emergencyExit:{
		if(memoryManagerSystem.mutexCreated and pthread_mutex_unlock(&memoryManagerSystem.mutex) != PTHREAD_MUTEX_UNLOCK_SUCCESS){
			printTitledError("pthread error", "could not unlock memory system mutex");
		}
		ret true;
	}
}
POPPOINTER(){
	if(!memoryManagerSystem.mutexCreated or !memoryManagerSystem.data or !token){
		ret false;
	}
	if(pthread_mutex_lock(&memoryManagerSystem.mutex) != PTHREAD_MUTEX_LOCK_SUCCESS){
		printTitledError("pthread error", "could not lock memory system mutex");
	}
	jmp popPointer;
	popPointer:{
		(*(memoryManagerSystem.data + token)).data = NULL;
		jmp trimSegmentLoop;
	}
	trimSegmentLoop:{
		if(!(*(memoryManagerSystem.data + dec memoryManagerSystem.allocated)).data){
			jmp trimSegmentLoop;
		}
		inc memoryManagerSystem.allocated;
		jmp emergencyExit;
	}
	emergencyExit:{
		if(memoryManagerSystem.mutexCreated and pthread_mutex_unlock(&memoryManagerSystem.mutex) != PTHREAD_MUTEX_UNLOCK_SUCCESS){
			printTitledError("pthread error", "could not unlock memory system mutex");
		}
		ret true;
	}
}
IFREE(){
	free(pointer);
	ret 0;
}
IXCBDISCONNECT(){
	xcb_flush(connection);
	xcb_disconnect(pointer);
	ret 0;
}
ISHMCTL(){
	const int shmID = (int64)pointer;
	if(shmID != SHMGET_FAILURE){
		shmctl(shmID, IPC_RMID, NULL);
	}
	ret 0;
}
FINIMEMORYSYSTEM(){
	if(memoryManagerSystem.mutexCreated){
		if(pthread_mutex_destroy(&memoryManagerSystem.mutex) != PTHREAD_MUTEX_DESTROY_SUCCESS){
			printTitledError("pthread error", "could not destroy memory system mutex");
		}
		memoryManagerSystem.mutexCreated = false;
	}
	free(memoryManagerSystem.data);
	memoryManagerSystem.size = 0;
	memoryManagerSystem.allocated = 0;
	memoryManagerSystem.data = NULL;
	ret true;
	#undef  SHMGET_FAILURE
	#undef  DYNAMIC_DATA_SEGMENT_BLOCK_SIZE
}
INITPERMISSIONSYSTEM(){
	if(!permissionSystem){
		ret false;
	}
	(*permissionSystem).normalUID = getuid();
	(*permissionSystem).normalGID = getgid();
	ret true;
}
SETPERMISSIONS(){
	const char *dataCurrent;
	const char *dataWall;
	LoadedFile loadedFile;
	char uidStringStart[10];
	char *uidStringCurrent;
	uid_t uid;
	if(!permissionSystem or ((*permissionSystem).normalUID != ROOT_UID and (*permissionSystem).normalGID != ROOT_GID)){
		ret false;
	}
	jmp loadFile;
	loadFile:{
		if(!loadFile("/proc/self/loginuid", &loadedFile)){
			ret false;
		}
		dataCurrent = loadedFile.dataStart;
		dataWall = dataCurrent + loadedFile.dataSize;
		uidStringCurrent = uidStringStart;
		uid = 0;
		jmp calculateUIDLoop;
	}
	calculateUIDLoop:{
		if(dataCurrent < dataWall){
			uid = uid * 10 + *dataCurrent - 48;
			*uidStringCurrent = *dataCurrent;
			inc uidStringCurrent;
			inc dataCurrent;
			jmp calculateUIDLoop;
		}
		free(loadedFile.dataStart);
		popPointer(loadedFile.dataToken);
		jmp getIDs;
	}
	getIDs:{
		struct passwd *passwd = getpwuid(uid);
		if(!passwd){
			ret false;
		}
		(*permissionSystem).normalUID = (*passwd).pw_uid;
		(*permissionSystem).normalGID = (*passwd).pw_gid;
		ret true;
	}
}
LOWERPERMISSIONS(){
	if(!permissionSystem or (geteuid() == (*permissionSystem).normalUID and getegid() == (*permissionSystem).normalGID)){
		ret false;
	}
	setegid((*permissionSystem).normalGID);
	seteuid((*permissionSystem).normalUID);
	ret true;
}
RAISEPERMISSIONS(){
	if(!permissionSystem or (geteuid() == getuid() and getegid() == getgid())){
		ret false;
	}
	setegid(getgid());
	seteuid(getuid());
	ret true;
}
DROPPERMISSIONS(){
	struct passwd *pw;
	char buffer[sizeof("/var/mail/") + 256];
	if(!permissionSystem){
		ret false;
	}
	pw = getpwuid((*permissionSystem).normalUID);
	if(!pw){
		ret false;
	}
	snprintf(buffer, sizeof(buffer), "/var/mail/%s", (*pw).pw_name);
	raisePermissions(permissionSystem);
	initgroups((*pw).pw_name, (*pw).pw_gid);
	setgid((*pw).pw_gid);
	setuid((*pw).pw_uid);
	unsetenv("SUDO_ASKPASS");
	unsetenv("SUDO_COMMAND");
	unsetenv("SUDO_EDITOR");
	unsetenv("SUDO_GID");
	unsetenv("SUDO_HOME");
	unsetenv("SUDO_PROMPT");
	unsetenv("SUDO_PS1");
	unsetenv("SUDO_UID");
	unsetenv("SUDO_USER");
	setenv("MAIL", buffer, true);
	setenv("HOME", (*pw).pw_dir, true);
	setenv("PWD", (*pw).pw_dir, true);
	setenv("USER", (*pw).pw_name, true);
	setenv("LOGNAME", (*pw).pw_name, true);
	setenv("SHELL", (*pw).pw_shell, true);
	setenv("LANG", setlocale(LC_ALL, ""), true);
	ret true;
}
FINIPERMISSIONSYSTEM(){
	if(!permissionSystem){
		ret false;
	}
	(*permissionSystem).normalUID = getuid();
	(*permissionSystem).normalGID = getgid();
	ret true;
}
IDENTIFYARGUMENT(){
	if(*p != '-') jmp findValueArgument;
	inc p;
	if(*p != '-') jmp findShortArgument;
	inc p;
	jmp findLongArgument;
	findValueArgument:{
		if(insensitiveStringCompare("stdout", p)) /*-*/ ret STDOUT_ARGUMENT;
		if(insensitiveStringCompare("stderr", p)) /*-*/ ret STDERR_ARGUMENT;
		/*-------------------------------------------*/ ret UNRECOGNIZED_ARGUMENT;
	}
	findShortArgument:{
		if(insensitiveStringCompare("h", p)) /*------*/ ret HELP_ARGUMENT;
		if(insensitiveStringCompare("c", p)) /*------*/ ret CONFIG_ARGUMENT;
		if(insensitiveStringCompare("e", p)) /*------*/ ret ERROR_ARGUMENT;
		if(insensitiveStringCompare("s", p)) /*------*/ ret SERVER_ARGUMENT;
		/*-------------------------------------------*/ ret UNRECOGNIZED_ARGUMENT;
	}
	findLongArgument:{
		if(insensitiveStringCompare("help", p)) /*---*/ ret HELP_ARGUMENT;
		if(insensitiveStringCompare("config", p)) /*-*/ ret CONFIG_ARGUMENT;
		if(insensitiveStringCompare("error", p)) /*--*/ ret ERROR_ARGUMENT;
		if(insensitiveStringCompare("server", p)) /*-*/ ret SERVER_ARGUMENT;
		/*-------------------------------------------*/ ret UNRECOGNIZED_ARGUMENT;
	}
}
INSENSITIVESTRINGCOMPARE(){
	jmp compareCharacterLoop;
	compareCharacterLoop:{
		char c1 = *s1;
		c1 |= 32 * (c1 >= 'A' and c1 <= 'Z');
		if(*s0 != c1) /*-*/ ret false;
		if(!c1) /*-------*/ ret true;
		inc s0;
		inc s1;
		jmp compareCharacterLoop;
	}
}
SENSITIVESTRINGCOMPARE(){
	jmp compareCharacterLoop;
	compareCharacterLoop:{
		if(*s0 != *s1) /*-*/ ret false;
		if(!*s0) /*-------*/ ret true;
		inc s0;
		inc s1;
		jmp compareCharacterLoop;
	}
}
RANDRQUERYVERSIONUNCHECKED(){
	xcb_void_cookie_t cookie;
	cookie.sequence = xcb_randr_query_version_unchecked(connection, majorVersion, minorVersion).sequence;
	ret cookie;
}
SHAPEQUERYVERSIONUNCHECKED(){
	xcb_void_cookie_t cookie;
	(void)majorVersion;
	(void)minorVersion;
	cookie.sequence = xcb_shape_query_version_unchecked(connection).sequence;
	ret cookie;
}
XFIXESQUERYVERSIONUNCHECKED(){
	xcb_void_cookie_t cookie;
	cookie.sequence = xcb_xfixes_query_version_unchecked(connection, majorVersion, minorVersion).sequence;
	ret cookie;
}
INITMONITORSYSTEM(){
	if(!monitorSystem){
		ret false;
	}
	(*monitorSystem).size = 0;
	(*monitorSystem).start = NULL;
	(*monitorSystem).token = 0;
	ret true;
}
CREATEMONITORS(){
	xcb_randr_get_monitors_reply_t *reply;
	uint32 replyToken;
	uint size;
	Monitor *start;
	Monitor *current;
	Monitor *wall;
	uint32 token;
	xcb_randr_monitor_info_iterator_t iterator;
	if(!monitorSystem){
		ret false;
	}
	reply = xcb_wait_for_reply(connection, xcb_randr_get_monitors_unchecked(connection, (*screen).root, true), NULL);
	replyToken = pushPointer(reply, "monitor reply", iFree);
	size = 1;
	if(reply){
		size = (*reply).nMonitors;
	}
	start = malloc(size * sizeof(Monitor));
	token = pushPointer(start, "monitor pointer", iFree);
	if(!start){
		printTitledError("memory allocation error", "could not allocate memory for monitors");
		free(reply);
		popPointer(replyToken);
		ret false;
	}
	current = start;
	wall = current + size;
	if(!reply){
		(*current).name = XCB_NONE;
		(*current).leftX = 0;
		(*current).topY = 0;
		(*current).rightX = screenWidthInPixels;
		(*current).bottomY = screenHeightInPixels;
		(*current).width = screenWidthInPixels;
		(*current).height = screenHeightInPixels;
		(*current).millimeterWidth = screenWidthInMillimeters;
		(*current).millimeterHeight = screenHeightInMillimeters;
		ret true;
	}
	iterator = xcb_randr_get_monitors_monitors_iterator(reply);
	jmp createMonitorLoop;
	createMonitorLoop:{
		if(current < wall){
			const Monitor *monitorCurrent = start;
			const Monitor *const monitorWall = current;
			const xcb_randr_monitor_info_t *const data = iterator.data;
			jmp removeSameMonitorLoop;
			removeSameMonitorLoop:{
				if(monitorCurrent < monitorWall){
					if((*monitorCurrent).leftX == (*data).x and (*monitorCurrent).topY == (*data).y){
						xcb_randr_monitor_info_next(&iterator);
						dec size;
						jmp createMonitorLoop;
					}
					inc monitorCurrent;
					jmp removeSameMonitorLoop;
				}
				(*current).name = (*data).name;
				(*current).leftX = (*data).x;
				(*current).topY = (*data).y;
				(*current).rightX = (*data).x + (*data).width;
				(*current).bottomY = (*data).y + (*data).height;
				(*current).width = (*data).width;
				(*current).height = (*data).height;
				(*current).millimeterWidth = (*data).width_in_millimeters;
				(*current).millimeterHeight = (*data).height_in_millimeters;
				xcb_randr_monitor_info_next(&iterator);
				inc current;
				jmp createMonitorLoop;
			}
		}
		free(reply);
		popPointer(replyToken);
		jmp compareMonitors;
	}
	compareMonitors:{
		if(size == (*monitorSystem).size){
			Monitor *oldCurrent = (*monitorSystem).start;
			current = start;
			wall = current + size;
			jmp compareMonitorLoop;
			compareMonitorLoop:{
				if(current < wall){
					if((*current).name != (*oldCurrent).name or (*current).leftX != (*oldCurrent).leftX or (*current).rightX != (*oldCurrent).rightX or (*current).width != (*oldCurrent).width or (*current).height != (*oldCurrent).height or (*current).millimeterWidth != (*oldCurrent).millimeterWidth or (*current).millimeterHeight != (*oldCurrent).millimeterHeight){
						jmp replaceMonitors;
					}
					inc oldCurrent;
					inc current;
					jmp compareMonitorLoop;
				}
				free(start);
				popPointer(token);
				ret false;
			}
		}
		jmp replaceMonitors;
	}
	replaceMonitors:{
		destroyMonitors(monitorSystem);
		(*monitorSystem).size = size;
		(*monitorSystem).start = start;
		(*monitorSystem).token = token;
		jmp trimMemory;
	}
	trimMemory:{
		if((*monitorSystem).size){
			void *const temp = realloc((*monitorSystem).start, (*monitorSystem).size * sizeof(Monitor));
			updatePointer((*monitorSystem).token, temp);
			if(temp){
				(*monitorSystem).start = temp;
			}
		}
		ret true;
	}
}
GETWHICHMONITOR(){
	switch(whichMonitor){
		to POINTER_WHICH_MONITOR:{
			ret findPointerMonitor(monitorSystem);
		}
		to FOCUSED_WINDOW_WHICH_MONITOR:{
			const xcb_window_t window = getFocusedWindow();
			if(window and window != (*screen).root){
				ret findWindowMonitor(monitorSystem, window);
			}
			ret findPointerMonitor(monitorSystem);
		}
		to ALL_WHICH_MONITOR:{
			ret NULL;
		}
		to SELF_WHICH_MONITOR:{
			ret NULL;
		}
		off:{
			ret NULL;
		}
	}
}
DESTROYMONITORS(){
	if(!monitorSystem){
		ret false;
	}
	free((*monitorSystem).start);
	popPointer((*monitorSystem).token);
	(*monitorSystem).size = 0;
	(*monitorSystem).start = NULL;
	(*monitorSystem).token = 0;
	ret true;
}
FINDPOINTERMONITOR(){
	xcb_query_pointer_reply_t *reply;
	uint32 token;
	if(!monitorSystem or !(*monitorSystem).size){
		ret NULL;
	}
	if((*monitorSystem).size == 1){
		ret (*monitorSystem).start;
	}
	reply = xcb_wait_for_reply(connection, xcb_query_pointer_unchecked(connection, (*screen).root), NULL);
	token = pushPointer(reply, "findPoinerMonitors() query pointer reply", iFree);
	if(reply){
		const int x = (*reply).root_x;
		const int y = (*reply).root_y;
		Monitor *current = (*monitorSystem).start;
		Monitor *const wall = current + (*monitorSystem).size;
		free(reply);
		popPointer(token);
		jmp findPointerMonitorLoop;
		findPointerMonitorLoop:{
			if(x >= (*current).leftX and x < (*current).rightX and y >= (*current).topY and y < (*current).bottomY){
				ret current;
			}
			if(inc current < wall){
				jmp findPointerMonitorLoop;
			}
		}
	}
	ret NULL;
}
FINDRECTANGLEMONITOR(){
	Monitor *current;
	Monitor *wall;
	uint mostPixelAmount;
	Monitor *monitor;
	if(!monitorSystem or !(*monitorSystem).size or width < 1 or height < 1){
		ret NULL;
	}
	current = (*monitorSystem).start;
	wall = current + (*monitorSystem).size;
	mostPixelAmount = 0;
	monitor = NULL;
	jmp findRectangleMonitorLoop;
	findRectangleMonitorLoop:{
		if(current < wall){
			int intersectionWidth;
			int intersectionHeight;
			uint pixelAmount;
			getIntersection((*current).leftX, (*current).topY, (*current).width, (*current).height, x, y, width, height, NULL, NULL, &intersectionWidth, &intersectionHeight);
			pixelAmount = intersectionWidth * intersectionHeight;
			if(pixelAmount > mostPixelAmount){
				monitor = current;
				mostPixelAmount = pixelAmount;
			}
			inc current;
			jmp findRectangleMonitorLoop;
		}
		ret monitor;
	}
}
FINDWINDOWMONITOR(){
	xcb_get_geometry_cookie_t geometryCookie;
	xcb_translate_coordinates_cookie_t translateCoordinatesCookie;
	xcb_get_geometry_reply_t *getGeometryReply;
	uint32 getGeometryToken;
	xcb_translate_coordinates_reply_t *translateCoordinatesReply;
	uint32 translateCoordinatesToken;
	Monitor *monitor;
	if(!monitorSystem or !(*monitorSystem).size){
		ret NULL;
	}
	if((*monitorSystem).size == 1){
		ret (*monitorSystem).start;
	}
	geometryCookie = xcb_get_geometry(connection, window);
	translateCoordinatesCookie = xcb_translate_coordinates(connection, window, (*screen).root, 0, 0);
	getGeometryReply = xcb_wait_for_reply(connection, geometryCookie, NULL);
	getGeometryToken = pushPointer(getGeometryReply, "findWindowMonitor() get geometry reply", iFree);
	translateCoordinatesReply = xcb_wait_for_reply(connection, translateCoordinatesCookie, NULL);
	translateCoordinatesToken = pushPointer(translateCoordinatesReply, "findWindowMonitor() translate coordinates reply", iFree);
	monitor = NULL;
	if(getGeometryReply and translateCoordinatesReply){
		const int width = (*getGeometryReply).width + 2 * (*getGeometryReply).border_width;
		const int height = (*getGeometryReply).height + 2 * (*getGeometryReply).border_width;
		const int leftX = (*translateCoordinatesReply).dst_x;
		const int topY = (*translateCoordinatesReply).dst_y;
		const int rightX = leftX + width;
		const int bottomY = topY + height;
		Monitor *current = (*monitorSystem).start;
		Monitor *const wall = current + (*monitorSystem).size;
		int mostPixels = 0;
		jmp findWindowMonitorLoop;
		findWindowMonitorLoop:{
			if((*current).leftX < rightX and (*current).rightX > leftX and (*current).topY < bottomY and (*current).bottomY > topY){
				const int width = ((*current).  rightX <  rightX? (*current). rightX :  rightX) - ((*current).leftX > leftX? (*current).leftX : leftX);
				const int height = ((*current).bottomY < bottomY? (*current).bottomY : bottomY) - ((*current). topY >  topY? (*current). topY :  topY);
				const int pixels = width * height;
				if(pixels > mostPixels){
					mostPixels = pixels;
					monitor = current;
				}
			}
			if(inc current < wall){
				jmp findWindowMonitorLoop;
			}
		}
	}
	free(getGeometryReply);
	popPointer(getGeometryToken);
	free(translateCoordinatesReply);
	popPointer(translateCoordinatesToken);
	ret monitor;
}
FINIMONITORSYSTEM(){
	if(!monitorSystem){
		ret false;
	}
	destroyMonitors(monitorSystem);
	free((*monitorSystem).start);
	popPointer((*monitorSystem).token);
	(*monitorSystem).size = 0;
	(*monitorSystem).start = NULL;
	(*monitorSystem).token = 0;
	ret true;
}
INITPOINTERSYSTEM(){
	if(!pointerSystem){
		ret false;
	}
	(*pointerSystem).timestamp = XCB_CURRENT_TIME;
	(*pointerSystem).x = 0;
	(*pointerSystem).y = 0;
	ret true;
}
SETPOINTER(){
	xcb_timestamp_t timestamp;
	xcb_query_pointer_reply_t *reply;
	uint32 token;
	if(!pointerSystem){
		ret false;
	}
	timestamp = getTimestamp();
	if(timestamp == (*pointerSystem).timestamp){
		ret false;
	}
	reply = xcb_wait_for_reply(connection, xcb_query_pointer_unchecked(connection, (*screen).root), NULL);
	token = pushPointer(reply, "setPointer() query pointer reply", iFree);
	if(!reply){
		ret false;
	}
	(*pointerSystem).timestamp = timestamp;
	(*pointerSystem).x = (*reply).root_x;
	(*pointerSystem).y = (*reply).root_y;
	free(reply);
	popPointer(token);
	ret true;
}
FINIPOINTERSYSTEM(){
	if(!pointerSystem){
		ret false;
	}
	(*pointerSystem).timestamp = XCB_CURRENT_TIME;
	(*pointerSystem).x = 0;
	(*pointerSystem).y = 0;
	ret true;
}
INITCURSORSYSTEM(){
	if(!cursorSystem){
		ret false;
	}
	(*cursorSystem).cursorFont = XCB_NONE;
	(*cursorSystem).cursor = XCB_NONE;
	ret true;
}
SETCURSOR(){
	if(!cursorSystem or cursorGlyph > countof(cursorGlyphList) - 1){
		ret false;
	}
	if((*cursorSystem).cursor){
		xcb_free_cursor(connection, (*cursorSystem).cursor);
	}
	if((*cursorSystem).cursorFont){
		xcb_close_font(connection, (*cursorSystem).cursorFont);
	}
	(*cursorSystem).cursorFont = xcb_generate_id(connection);
	(*cursorSystem).cursor = xcb_generate_id(connection);
	xcb_open_font(connection, (*cursorSystem).cursorFont, lengthof("cursor"), "cursor");
	{
		const uint16 redForeground   = ((foreground & 0x00FF0000) >> 16) * 257;
		const uint16 greenForeground = ((foreground & 0x0000FF00) >>  8) * 257;
		const uint16 blueForeground  = ((foreground & 0x000000FF) >>  0) * 257;
		const uint16 redBackground   = ((background & 0x00FF0000) >> 16) * 257;
		const uint16 greenBackground = ((background & 0x0000FF00) >>  8) * 257;
		const uint16 blueBackground  = ((background & 0x000000FF) >>  0) * 257;
		xcb_create_glyph_cursor(connection, (*cursorSystem).cursor, (*cursorSystem).cursorFont, (*cursorSystem).cursorFont, 2 * cursorGlyph, 2 * cursorGlyph + 1, redForeground, greenForeground, blueForeground, redBackground, greenBackground, blueBackground);
	}
	ret true;
}
FINICURSORSYSTEM(){
	if(!cursorSystem){
		ret false;
	}
	if((*cursorSystem).cursor){
		xcb_free_cursor(connection, (*cursorSystem).cursor);
		(*cursorSystem).cursor = XCB_NONE;
	}
	if((*cursorSystem).cursorFont){
		xcb_close_font(connection, (*cursorSystem).cursorFont);
		(*cursorSystem).cursorFont = XCB_NONE;
	}
	ret true;
}
INITWALLPAPERSYSTEM(){
	if(!wallpaperSystem){
		ret false;
	}
	(*wallpaperSystem).pixmap = XCB_NONE;
	(*wallpaperSystem).gc = XCB_NONE;
	(*wallpaperSystem).width = 0;
	(*wallpaperSystem).height = 0;
	(*wallpaperSystem).color = 0x00000000;
	(*wallpaperSystem).wallpaperPixmap = XCB_NONE;
	(*wallpaperSystem).wallpaperWidth = 0;
	(*wallpaperSystem).wallpaperHeight = 0;
	ret true;
}
SETWALLPAPERCOLOR(){
	if(!wallpaperSystem or !monitorSystem or !(*monitorSystem).size){
		ret false;
	}
	(*wallpaperSystem).color = color;
	createWallpaper(wallpaperSystem, monitorSystem, (*wallpaperSystem).width, (*wallpaperSystem).height);
	ret true;
}
SETWALLPAPERPIXMAP(){
	xcb_pixmap_t pixmap;
	uint width;
	uint height;
	if(!wallpaperSystem or !monitorSystem or !(*monitorSystem).size or !pixmapProperty){
		ret false;
	}
	jmp getWallpaper;
	getWallpaper:{
		xcb_get_property_reply_t *const reply = xcb_wait_for_reply(connection, xcb_get_property_unchecked(connection, false, (*screen).root, pixmapProperty, XCB_ATOM_PIXMAP, 0, 0xFFFFFFFF), NULL);
		uint32 token = pushPointer(reply, "setWallpaperPixmap() get property reply", iFree);
		if(!reply){
			ret false;
		}
		pixmap = XCB_NONE;
		if(xcb_get_property_value_length(reply) == sizeof(xcb_pixmap_t)){
			pixmap = *(xcb_pixmap_t *)xcb_get_property_value(reply);
		}
		free(reply);
		popPointer(token);
		if(!pixmap){
			ret false;
		}
		jmp getWallpaperSize;
	}
	getWallpaperSize:{
		xcb_get_geometry_reply_t *const reply = xcb_wait_for_reply(connection, xcb_get_geometry(connection, pixmap), NULL);
		uint32 token = pushPointer(reply, "setWallpaperPixmap() get geometry reply", iFree);
		width = 0;
		height = 0;
		if(reply){
			width = (*reply).width;
			height = (*reply).height;
			free(reply);
			popPointer(token);
		}
		if(!width or !height){
			ret false;
		}
		jmp setWallpaper;
	}
	setWallpaper:{
		const xcb_gcontext_t gc = xcb_generate_id(connection);
		struct{
			uint32 /*-*/ generateExpose;
		} valueList;
		valueList.generateExpose = false;
		if((*wallpaperSystem).wallpaperPixmap){
			xcb_free_pixmap(connection, (*wallpaperSystem).wallpaperPixmap);
		}
		(*wallpaperSystem).wallpaperPixmap = xcb_generate_id(connection);
		(*wallpaperSystem).wallpaperWidth = width;
		(*wallpaperSystem).wallpaperHeight = height;
		xcb_create_pixmap(connection, (*screen).root_depth, (*wallpaperSystem).wallpaperPixmap, (*screen).root, width, height);
		xcb_create_gc(connection, gc, (*wallpaperSystem).wallpaperPixmap, XCB_GC_GRAPHICS_EXPOSURES, &valueList);
		fillDrawable((*wallpaperSystem).wallpaperPixmap, gc, 0, 0, width, height, (*wallpaperSystem).color);
		xcb_discard_reply(connection, xcb_copy_area_checked(connection, pixmap, (*wallpaperSystem).wallpaperPixmap, gc, 0, 0, 0, 0, width, height));
		xcb_free_gc(connection, gc);
		jmp createWallpaper;
	}
	createWallpaper:{
		createWallpaper(wallpaperSystem, monitorSystem, (*wallpaperSystem).width, (*wallpaperSystem).height);
		ret true;
	}
}
CREATEWALLPAPER(){
	struct{
		uint32 /*-*/ generateExpose;
	} valueList;
	if(!wallpaperSystem or !monitorSystem or !(*monitorSystem).size or !width or !height){
		ret false;
	}
	valueList.generateExpose = false;
	if((*wallpaperSystem).gc){
		xcb_free_gc(connection, (*wallpaperSystem).gc);
	}
	if((*wallpaperSystem).pixmap){
		xcb_free_pixmap(connection, (*wallpaperSystem).pixmap);
	}
	(*wallpaperSystem).pixmap = xcb_generate_id(connection);
	(*wallpaperSystem).gc = xcb_generate_id(connection);
	(*wallpaperSystem).width = width;
	(*wallpaperSystem).height = height;
	xcb_create_pixmap(connection, (*screen).root_depth, (*wallpaperSystem).pixmap, (*screen).root, (*wallpaperSystem).width, (*wallpaperSystem).height);
	xcb_create_gc(connection, (*wallpaperSystem).gc, (*wallpaperSystem).pixmap, XCB_GC_GRAPHICS_EXPOSURES, &valueList);
	fillDrawable((*wallpaperSystem).pixmap, (*wallpaperSystem).gc, 0, 0, (*wallpaperSystem).width, (*wallpaperSystem).height, (*wallpaperSystem).color);
	if((*wallpaperSystem).wallpaperPixmap){
		xcb_copy_area(connection, (*wallpaperSystem).wallpaperPixmap, (*wallpaperSystem).pixmap, (*wallpaperSystem).gc, 0, 0, 0, 0, (*wallpaperSystem).wallpaperWidth, (*wallpaperSystem).wallpaperHeight);
	}
	ret true;
}
FINIWALLPAPERSYSTEM(){
	if(!wallpaperSystem){
		ret false;
	}
	(*wallpaperSystem).wallpaperWidth = 0;
	(*wallpaperSystem).wallpaperHeight = 0;
	if((*wallpaperSystem).wallpaperPixmap){
		xcb_free_pixmap(connection, (*wallpaperSystem).wallpaperPixmap);
		(*wallpaperSystem).wallpaperPixmap = XCB_NONE;
	}
	(*wallpaperSystem).width = 0;
	(*wallpaperSystem).height = 0;
	(*wallpaperSystem).color = 0x00000000;
	if((*wallpaperSystem).gc){
		xcb_free_gc(connection, (*wallpaperSystem).gc);
		(*wallpaperSystem).gc = XCB_NONE;
	}
	if((*wallpaperSystem).pixmap){
		xcb_free_pixmap(connection, (*wallpaperSystem).pixmap);
		(*wallpaperSystem).pixmap = XCB_NONE;
	}
	ret true;
}
INITCLIENTSYSTEM(){
	if(!clientSystem){
		ret false;
	}
	(*clientSystem).clientSize = 0;
	(*clientSystem).clientAllocated = 0;
	(*clientSystem).clientNotInUseOffset = 0;
	(*clientSystem).clientStart = NULL;
	(*clientSystem).clientToken = 0;
	(*clientSystem).orderedClientOffsetSize = 0;
	(*clientSystem).orderedClientOffsetAllocated = 0;
	(*clientSystem).orderedClientOffsetStart = NULL;
	(*clientSystem).orderedClientOffsetToken = 0;
	(*clientSystem).motionAction = NONE_MOTION_ACTION;
	(*clientSystem).recentlyConfiguredClientOffset = 0;
	(*clientSystem).motionClientOffset = 0;
	(*clientSystem).focusedClientOffset = 0;
	ret true;
}
CREATECLIENT(){
	Client *client;
	if(!clientSystem){
		ret false;
	}
	if(!class or class == XCB_WINDOW_CLASS_COPY_FROM_PARENT){
		class = getWindowClass(window);
	}
	if(class != XCB_WINDOW_CLASS_INPUT_OUTPUT){
		ret false;
	}
	jmp addClient;
	addClient:{
		if((*clientSystem).clientAllocated == (*clientSystem).clientSize){
			void *temp;
			(*clientSystem).clientSize += CLIENT_BLOCK_SIZE;
			temp = realloc((*clientSystem).clientStart, (*clientSystem).clientSize * sizeof(Client));
			if(!(*clientSystem).clientToken){
				(*clientSystem).clientToken = pushPointer(temp, "client pointer", iFree);
			}else{
				updatePointer((*clientSystem).clientToken, temp);
			}
			if(!temp){
				printTitledError("memory allocation error", "could not allocate memory for clients");
				(*clientSystem).clientSize -= CLIENT_BLOCK_SIZE;
				ret false;
			}
			(*clientSystem).clientStart = temp;
			if(!(*clientSystem).clientAllocated){
				(*clientSystem).clientAllocated = 1;
				(*clientSystem).clientNotInUseOffset = 1;
				(*(*clientSystem).clientStart).inUse = false;
			}
		}
		if((*clientSystem).orderedClientOffsetAllocated == (*clientSystem).orderedClientOffsetSize){
			void *temp;
			(*clientSystem).orderedClientOffsetSize += CLIENT_BLOCK_SIZE;
			temp = realloc((*clientSystem).orderedClientOffsetStart, (*clientSystem).orderedClientOffsetSize * sizeof(uint));
			if(!(*clientSystem).orderedClientOffsetToken){
				(*clientSystem).orderedClientOffsetToken = pushPointer(temp, "ordered client offset pointer", iFree);
			}else{
				updatePointer((*clientSystem).orderedClientOffsetToken, temp);
			}
			if(!temp){
				printTitledError("memory allocation error", "could not allocate memory for ordered client offsets");
				(*clientSystem).orderedClientOffsetSize -= CLIENT_BLOCK_SIZE;
				ret false;
			}
			(*clientSystem).orderedClientOffsetStart = temp;
		}
		client = (*clientSystem).clientStart + (*clientSystem).clientNotInUseOffset;
		*((*clientSystem).orderedClientOffsetStart + (*clientSystem).orderedClientOffsetAllocated) = (*clientSystem).clientNotInUseOffset;
		inc (*clientSystem).orderedClientOffsetAllocated;
		if((*clientSystem).clientNotInUseOffset == (*clientSystem).clientAllocated){
			inc (*clientSystem).clientAllocated;
			inc (*clientSystem).clientNotInUseOffset;
			jmp setClient;
		}
		jmp findNextAvailableClientSlot;
	}
	findNextAvailableClientSlot:{
		const Client *current = client + 1;
		const Client *const wall = (*clientSystem).clientStart + (*clientSystem).clientAllocated;
		jmp findNextAvailableClientSlotLoop;
		findNextAvailableClientSlotLoop:{
			if(current < wall and (*current).inUse){
				inc current;
				jmp findNextAvailableClientSlotLoop;
			}
			(*clientSystem).clientNotInUseOffset = current - (*clientSystem).clientStart;
			jmp setClient;
		}
	}
	setClient:{
		(*client).container = XCB_NONE;
		(*client).window = window;
		(*client).pixmap = XCB_NONE;
		(*client).gc = XCB_NONE;
		(*client).windowX = x;
		(*client).windowY = y;
		(*client).windowWidth = width;
		(*client).windowHeight = height;
		(*client).windowBorder = border;
		(*client).propertyPreference = NONE_PROPERTY_PREFERENCE;
		(*client).nameStart = NULL;
		(*client).nameToken = 0;
		(*client).iconNameStart = NULL;
		(*client).iconNameToken = 0;
		(*client).normalHintsFlags = NONE_NORMAL_HINT;
		(*client).hintsInput = false;
		(*client).hintsInitialState = NORMAL_STATE;
		(*client).hintsIconPixmap = XCB_NONE;
		(*client).hintsIconWindow = XCB_NONE;
		(*client).hintsIconX = 0;
		(*client).hintsIconY = 0;
		(*client).hintsIconMask = XCB_NONE;
		(*client).hintsWindowGroup = XCB_NONE;
		(*client).hintsUrgency = false;
		(*client).classStart = NULL;
		(*client).classToken = 0;
		(*client).transientFor = XCB_NONE;
		(*client).protocol = NONE_CLIENT_PROTOCOL;
		(*client).protocolStart = NULL;
		(*client).protocolToken = 0;
		(*client).colormapWindowStart = NULL;
		(*client).colormapWindowToken = 0;
		(*client).clientMachineStart = NULL;
		(*client).clientMachineToken = 0;
		(*client).clientIDStart = NULL;
		(*client).clientIDToken = 0;
		(*client).clientLeader = XCB_NONE;
		(*client).windowRoleStart = NULL;
		(*client).windowRoleToken = 0;
		(*client).stateState = WITHDRAWN_STATE;
		(*client).stateIcon = XCB_NONE;
		(*client).visibleNameStart = NULL;
		(*client).visibleNameToken = 0;
		(*client).visibleIconNameStart = NULL;
		(*client).visibleIconNameToken = 0;
		(*client).desktop = NONE_DESKTOP;
		(*client).windowType = NONE_WINDOW_TYPE;
		(*client).windowTypeStart = NULL;
		(*client).windowTypeToken = 0;
		(*client).state = NONE_STATE;
		(*client).stateStart = NULL;
		(*client).stateToken = 0;
		(*client).allowedAction = NONE_ALLOWED_ACTION;
		(*client).allowedActionStart = NULL;
		(*client).allowedActionToken = 0;
		(*client).strut = NONE_STRUT;
		(*client).iconGeometryX = 0;
		(*client).iconGeometryY = 0;
		(*client).iconGeometryWidth = 0;
		(*client).iconGeometryHeight = 0;
		(*client).iconStart = NULL;
		(*client).iconToken = 0;
		(*client).pid = 0;
		(*client).handledIcons = false;
		(*client).userTime = NONE_USER_TIME;
		(*client).frameExtentsLeft = 0;
		(*client).frameExtentsRight = 0;
		(*client).frameExtentsTop = 0;
		(*client).frameExtentsBottom = 0;
		(*client).orderType = NONE_ORDER_TYPE;
		(*client).option = overrideRedirect * OVERRIDE_REDIRECT_CLIENT_OPTION;
		(*client).workareaPosition = NONE_WORKAREA_POSITION;
		(*client).inUse = true;
		jmp selectInput;
	}
	selectInput:{
		uint32 valueMask = XCB_CW_EVENT_MASK;
		struct{
			uint32 /*-------*/ eventMask;
			xcb_cursor_t /*-*/ cursor;
		} valueList;
		valueList.eventMask = WINDOW_EVENT_MASK;
		if(cursorSystem and (*cursorSystem).cursor){
			valueMask |= XCB_CW_CURSOR;
			valueList.cursor = (*cursorSystem).cursor;
		}
		xcb_discard_reply(connection, xcb_change_window_attributes_checked(connection, (*client).window, valueMask, &valueList));
		xcb_flush(connection);
		jmp createClientObjects;
	}
	createClientObjects:{
		if(!overrideRedirect){
			uint32 valueMask = XCB_CW_BACK_PIXEL | XCB_CW_BORDER_PIXEL | XCB_CW_EVENT_MASK | XCB_CW_COLORMAP;
			struct{
				uint32 /*---------*/ backgroundColor;
				uint32 /*---------*/ borderColor;
				uint32 /*---------*/ eventMask;
				xcb_colormap_t /*-*/ colormap;
				xcb_cursor_t /*---*/ cursor;
			} valueList;
			valueList.backgroundColor = 0xFF171717;
			valueList.borderColor = 0x00000000;
			valueList.eventMask = CONTAINER_EVENT_MASK;
			valueList.colormap = colormap;
			if(cursorSystem and (*cursorSystem).cursor){
				valueMask |= XCB_CW_CURSOR;
				valueList.cursor = (*cursorSystem).cursor;
			}
			(*client).container = xcb_generate_id(connection);
			(*client).containerX = x;
			(*client).containerY = y;
			(*client).containerWidth = width + 2 * border;
			(*client).containerHeight = height + 2 * border;
			(*client).containerBorder = 0;
			(*client).windowX = 0;
			(*client).windowY = 0;
			xcb_create_window(connection, depth, (*client).container, (*screen).root, (*client).containerX, (*client).containerY, (*client).containerWidth, (*client).containerHeight, (*client).containerBorder, XCB_WINDOW_CLASS_INPUT_OUTPUT, visual, valueMask, &valueList);
		}
		ret true;
	}
}
SETDEFAULTCLIENTWINDOWTYPE(){
	void *temp;
	xcb_atom_t a;
	uint8 type;
	if(!clientSystem or !isValidClient(clientSystem, client) or (*client).windowType){
		ret false;
	}
	if(!(*client).windowTypeStart){
		(*client).windowTypeSize = 0;
	}
	inc (*client).windowTypeSize;
	temp = realloc((*client).windowTypeStart, (*client).windowTypeSize * sizeof(xcb_atom_t));
	if(!(*client).windowTypeToken){
		(*client).windowTypeToken = pushPointer(temp, "client _NET_WM_WINDOW_TYPE pointer", iFree);
	}else{
		updatePointer((*client).windowTypeToken, temp);
	}
	if(!temp){
		printTitledError("memory allocation error", "could not allocate memory for client window type");
		dec (*client).windowTypeSize;
		ret false;
	}
	(*client).windowTypeStart = temp;
	if((*client).transientFor){
		a = atom._NET_WM_WINDOW_TYPE_DIALOG;
		type = DIALOG_WINDOW_TYPE;
	}else{
		a = atom._NET_WM_WINDOW_TYPE_NORMAL;
		type = NORMAL_WINDOW_TYPE;
	}
	*((*client).windowTypeStart + (*client).windowTypeSize - 1) = a;
	(*client).windowType |= type;
	ret true;
}
UPDATECLIENTSTATE(){
	uint stateSize;
	void *temp;
	uint32 token;
	xcb_atom_t *current;
	if(!clientSystem or !isValidClient(clientSystem, client) or !state){
		ret false;
	}
	if((state & (MAXIMIZED_HORZ_STATE | MAXIMIZED_VERT_STATE)) != (MAXIMIZED_HORZ_STATE | MAXIMIZED_VERT_STATE)) /*-*/ state &= ~(MAXIMIZED_HORZ_STATE | MAXIMIZED_VERT_STATE);
	if((state & (ABOVE_STATE | BELOW_STATE)) == (ABOVE_STATE | BELOW_STATE)) /*-------------------------------------*/ state &= ~(BELOW_STATE);
	switch(action){
		to _NET_WM_STATE_ADD: /*----*/ state |= (*client).state; /*---------*/ brk;
		to _NET_WM_STATE_REMOVE: /*-*/ state = (*client).state & ~state; /*-*/ brk;
		to _NET_WM_STATE_TOGGLE: /*-*/ state ^= (*client).state; /*---------*/ brk;
		off: /*---------------------*/ /*-----------------------------------*/ ret false;
	}
	if(state == (*client).state){
		ret false;
	}
	stateSize = !!(state & MODAL_STATE) + !!(state & STICKY_STATE) + !!(state & MAXIMIZED_HORZ_STATE) + !!(state & MAXIMIZED_VERT_STATE) + !!(state & SHADED_STATE) + !!(state & SKIP_TASKBAR_STATE) + !!(state & SKIP_PAGER_STATE) + !!(state & HIDDEN_STATE) + !!(state & FULLSCREEN_STATE) + !!(state & ABOVE_STATE) + !!(state & BELOW_STATE) + !!(state & DEMANDS_ATTENTION_STATE);
	temp = NULL;
	token = 0;
	if(stateSize){
		temp = malloc(stateSize * sizeof(xcb_atom_t));
		token = pushPointer(temp, "client _NET_WM_STATE pointer", iFree);
		if(!temp){
			printTitledError("memory allocation error", "could not allocate memory for client state");
			ret false;
		}
		current = (xcb_atom_t *)temp - 1;
		if(state & MODAL_STATE) /*-------------*/ *(inc current) = atom._NET_WM_STATE_MODAL;
		if(state & STICKY_STATE) /*------------*/ *(inc current) = atom._NET_WM_STATE_STICKY;
		if(state & MAXIMIZED_HORZ_STATE) /*----*/ *(inc current) = atom._NET_WM_STATE_MAXIMIZED_HORZ;
		if(state & MAXIMIZED_VERT_STATE) /*----*/ *(inc current) = atom._NET_WM_STATE_MAXIMIZED_VERT;
		if(state & SHADED_STATE) /*------------*/ *(inc current) = atom._NET_WM_STATE_SHADED;
		if(state & SKIP_TASKBAR_STATE) /*------*/ *(inc current) = atom._NET_WM_STATE_SKIP_TASKBAR;
		if(state & SKIP_PAGER_STATE) /*--------*/ *(inc current) = atom._NET_WM_STATE_SKIP_PAGER;
		if(state & HIDDEN_STATE) /*------------*/ *(inc current) = atom._NET_WM_STATE_HIDDEN;
		if(state & FULLSCREEN_STATE) /*--------*/ *(inc current) = atom._NET_WM_STATE_FULLSCREEN;
		if(state & ABOVE_STATE) /*-------------*/ *(inc current) = atom._NET_WM_STATE_ABOVE;
		if(state & BELOW_STATE) /*-------------*/ *(inc current) = atom._NET_WM_STATE_BELOW;
		if(state & DEMANDS_ATTENTION_STATE) /*-*/ *(inc current) = atom._NET_WM_STATE_DEMANDS_ATTENTION;
	}
	free((*client).stateStart);
	popPointer((*client).stateToken);
	(*client).state = state;
	(*client).stateSize = stateSize;
	(*client).stateStart = temp;
	(*client).stateToken = token;
	ret true;
}
CHANGECLIENTSTATE(){
	if(!clientSystem or !isValidClient(clientSystem, client)){
		ret false;
	}
	if(!(*client).state){
		xcb_discard_reply(connection, xcb_delete_property_checked(connection, (*client).window, atom._NET_WM_STATE));
	}else{
		xcb_discard_reply(connection, xcb_change_property_checked(connection, XCB_PROP_MODE_REPLACE, (*client).window, atom._NET_WM_STATE, XCB_ATOM_ATOM, bitsof(xcb_atom_t), (*client).stateSize, (*client).stateStart));
	}
	ret true;
}
SETCLIENTALLOWEDACTIONS(){
	uint8 windowType;
	uint16 state;
	uint16 allowedAction;
	uint allowedActionSize;
	void *temp;
	uint32 token;
	xcb_atom_t *current;
	if(!clientSystem or !isValidClient(clientSystem, client)){
		ret false;
	}
	windowType = (*client).windowType;
	state = (*client).state;
	allowedAction = NONE_ALLOWED_ACTION;
	if(windowType & DESKTOP_WINDOW_TYPE) /*-*/ allowedAction |= NONE_ALLOWED_ACTION;
	if(windowType & DOCK_WINDOW_TYPE) /*----*/ allowedAction |= STICK_ALLOWED_ACTION | CHANGE_DESKTOP_ALLOWED_ACTION;
	if(windowType & TOOLBAR_WINDOW_TYPE) /*-*/ allowedAction |= MOVE_ALLOWED_ACTION | RESIZE_ALLOWED_ACTION | MINIMIZE_ALLOWED_ACTION | SHADE_ALLOWED_ACTION | MAXIMIZE_HORZ_ALLOWED_ACTION | MAXIMIZE_VERT_ALLOWED_ACTION | FULLSCREEN_ALLOWED_ACTION | CHANGE_DESKTOP_ALLOWED_ACTION | CLOSE_ALLOWED_ACTION;
	if(windowType & MENU_WINDOW_TYPE) /*----*/ allowedAction |= NONE_ALLOWED_ACTION;
	if(windowType & UTILITY_WINDOW_TYPE) /*-*/ allowedAction |= MOVE_ALLOWED_ACTION | RESIZE_ALLOWED_ACTION | MINIMIZE_ALLOWED_ACTION | SHADE_ALLOWED_ACTION | MAXIMIZE_HORZ_ALLOWED_ACTION | MAXIMIZE_VERT_ALLOWED_ACTION | FULLSCREEN_ALLOWED_ACTION | CHANGE_DESKTOP_ALLOWED_ACTION | CLOSE_ALLOWED_ACTION;
	if(windowType & SPLASH_WINDOW_TYPE) /*--*/ allowedAction |= STICK_ALLOWED_ACTION | CLOSE_ALLOWED_ACTION;
	if(windowType & DIALOG_WINDOW_TYPE) /*--*/ allowedAction |= MOVE_ALLOWED_ACTION | RESIZE_ALLOWED_ACTION | MINIMIZE_ALLOWED_ACTION | SHADE_ALLOWED_ACTION | MAXIMIZE_HORZ_ALLOWED_ACTION | MAXIMIZE_VERT_ALLOWED_ACTION | FULLSCREEN_ALLOWED_ACTION | CHANGE_DESKTOP_ALLOWED_ACTION | CLOSE_ALLOWED_ACTION;
	if(windowType & NORMAL_WINDOW_TYPE) /*--*/ allowedAction |= MOVE_ALLOWED_ACTION | RESIZE_ALLOWED_ACTION | MINIMIZE_ALLOWED_ACTION | SHADE_ALLOWED_ACTION | MAXIMIZE_HORZ_ALLOWED_ACTION | MAXIMIZE_VERT_ALLOWED_ACTION | FULLSCREEN_ALLOWED_ACTION | CHANGE_DESKTOP_ALLOWED_ACTION | CLOSE_ALLOWED_ACTION;
	if(state & MODAL_STATE) /*--------------------------------------------------------------------------------------*/ allowedAction &= ~(MINIMIZE_ALLOWED_ACTION | CHANGE_DESKTOP_ALLOWED_ACTION);
	if(state & STICKY_STATE) /*-------------------------------------------------------------------------------------*/ allowedAction &= ~(NONE_ALLOWED_ACTION);
	if((state & (MAXIMIZED_HORZ_STATE | MAXIMIZED_VERT_STATE)) == (MAXIMIZED_HORZ_STATE | MAXIMIZED_VERT_STATE)) /*-*/ allowedAction &= ~(MOVE_ALLOWED_ACTION | RESIZE_ALLOWED_ACTION | SHADE_ALLOWED_ACTION | STICK_ALLOWED_ACTION);
	if(state & SHADED_STATE) /*-------------------------------------------------------------------------------------*/ allowedAction &= ~(RESIZE_ALLOWED_ACTION | MAXIMIZE_HORZ_ALLOWED_ACTION | MAXIMIZE_VERT_ALLOWED_ACTION | FULLSCREEN_ALLOWED_ACTION);
	if(state & SKIP_TASKBAR_STATE) /*-------------------------------------------------------------------------------*/ allowedAction &= ~(NONE_ALLOWED_ACTION);
	if(state & SKIP_PAGER_STATE) /*---------------------------------------------------------------------------------*/ allowedAction &= ~(NONE_ALLOWED_ACTION);
	if(state & HIDDEN_STATE) /*-------------------------------------------------------------------------------------*/ allowedAction &= ~(SHADE_ALLOWED_ACTION | STICK_ALLOWED_ACTION | MAXIMIZE_HORZ_ALLOWED_ACTION | MAXIMIZE_VERT_ALLOWED_ACTION | FULLSCREEN_ALLOWED_ACTION);
	if(state & FULLSCREEN_STATE) /*---------------------------------------------------------------------------------*/ allowedAction &= ~(MOVE_ALLOWED_ACTION | RESIZE_ALLOWED_ACTION | SHADE_ALLOWED_ACTION | STICK_ALLOWED_ACTION);
	if(state & ABOVE_STATE) /*--------------------------------------------------------------------------------------*/ allowedAction &= ~(NONE_ALLOWED_ACTION);
	if(state & BELOW_STATE) /*--------------------------------------------------------------------------------------*/ allowedAction &= ~(NONE_ALLOWED_ACTION);
	if(allowedAction == (*client).allowedAction){
		ret false;
	}
	if(!allowedAction){
		free((*client).allowedActionStart);
		popPointer((*client).allowedActionSize);
		(*client).allowedAction = NONE_ALLOWED_ACTION;
		(*client).allowedActionStart = NULL;
		(*client).allowedActionSize = 0;
		ret true;
	}
	allowedActionSize = !!(allowedAction & MOVE_ALLOWED_ACTION) + !!(allowedAction & RESIZE_ALLOWED_ACTION) + !!(allowedAction & MINIMIZE_ALLOWED_ACTION) + !!(allowedAction & SHADE_ALLOWED_ACTION) + !!(allowedAction & STICK_ALLOWED_ACTION) + !!(allowedAction & MAXIMIZE_HORZ_ALLOWED_ACTION) + !!(allowedAction & MAXIMIZE_VERT_ALLOWED_ACTION) + !!(allowedAction & FULLSCREEN_ALLOWED_ACTION) + !!(allowedAction & CHANGE_DESKTOP_ALLOWED_ACTION) + !!(allowedAction & CLOSE_ALLOWED_ACTION);
	temp = malloc(allowedActionSize * sizeof(xcb_atom_t));
	token = pushPointer(temp, "client _NET_WM_ALLOWED_ACTIONS pointer", iFree);
	if(!temp){
		printTitledError("memory allocation error", "could not allocate memory for client allowed actions");
		ret false;
	}
	current = (xcb_atom_t *)temp - 1;
	if(allowedAction & MOVE_ALLOWED_ACTION) /*-----------*/ *(inc current) = atom._NET_WM_ACTION_MOVE;
	if(allowedAction & RESIZE_ALLOWED_ACTION) /*---------*/ *(inc current) = atom._NET_WM_ACTION_RESIZE;
	if(allowedAction & MINIMIZE_ALLOWED_ACTION) /*-------*/ *(inc current) = atom._NET_WM_ACTION_MINIMIZE;
	if(allowedAction & SHADE_ALLOWED_ACTION) /*----------*/ *(inc current) = atom._NET_WM_ACTION_SHADE;
	if(allowedAction & STICK_ALLOWED_ACTION) /*----------*/ *(inc current) = atom._NET_WM_ACTION_STICK;
	if(allowedAction & MAXIMIZE_HORZ_ALLOWED_ACTION) /*--*/ *(inc current) = atom._NET_WM_ACTION_MAXIMIZE_HORZ;
	if(allowedAction & MAXIMIZE_VERT_ALLOWED_ACTION) /*--*/ *(inc current) = atom._NET_WM_ACTION_MAXIMIZE_VERT;
	if(allowedAction & FULLSCREEN_ALLOWED_ACTION) /*-----*/ *(inc current) = atom._NET_WM_ACTION_FULLSCREEN;
	if(allowedAction & CHANGE_DESKTOP_ALLOWED_ACTION) /*-*/ *(inc current) = atom._NET_WM_ACTION_CHANGE_DESKTOP;
	if(allowedAction & CLOSE_ALLOWED_ACTION) /*----------*/ *(inc current) = atom._NET_WM_ACTION_CLOSE;
	free((*client).allowedActionStart);
	popPointer((*client).allowedActionToken);
	(*client).allowedAction = allowedAction;
	(*client).allowedActionSize = allowedActionSize;
	(*client).allowedActionStart = temp;
	(*client).allowedActionToken = token;
	ret true;
}
CHANGECLIENTALLOWEDACTIONS(){
	if(!clientSystem or !isValidClient(clientSystem, client)){
		ret false;
	}
	if(!(*client).allowedAction){
		xcb_discard_reply(connection, xcb_delete_property_checked(connection, (*client).window, atom._NET_WM_ALLOWED_ACTIONS));
	}else{
		xcb_discard_reply(connection, xcb_change_property_checked(connection, XCB_PROP_MODE_REPLACE, (*client).window, atom._NET_WM_ALLOWED_ACTIONS, XCB_ATOM_ATOM, bitsof(xcb_atom_t), (*client).allowedActionSize, (*client).allowedActionStart));
	}
	ret true;
}
SETCLIENTORDERTYPE(){
	uint option;
	uint windowType;
	uint state;
	uint8 orderType;
	if(!clientSystem or !isValidClient(clientSystem, client)){
		ret false;
	}
	option = (*client).option;
	windowType = (*client).windowType;
	state = (*client).state;
	if(option & OVERRIDE_REDIRECT_CLIENT_OPTION){
		orderType = NONE_ORDER_TYPE;
	}elif(windowType & DESKTOP_WINDOW_TYPE){
		orderType = DESKTOP_ORDER_TYPE;
	}elif(state & BELOW_STATE){
		orderType = BELOW_ORDER_TYPE;
	}elif(windowType & DOCK_WINDOW_TYPE){
		orderType = DOCK_ORDER_TYPE;
	}elif(state & ABOVE_STATE){
		orderType = ABOVE_ORDER_TYPE;
	}elif(state & FULLSCREEN_STATE){
		orderType = FULLSCREEN_ORDER_TYPE;
	}else{
		orderType = NORMAL_ORDER_TYPE;
	}
	if(orderType == (*client).orderType){
		ret false;
	}
	(*client).orderType = orderType;
	ret true;
}
MOVERESIZECLIENT(){
	int windowWidth;
	int windowHeight;
	int containerWidth;
	int containerHeight;
	int candidateContainerX;
	int candidateContainerY;
	int candidateContainerWidth;
	int candidateContainerHeight;
	int candidateWindowX;
	int candidateWindowY;
	int candidateWindowWidth;
	int candidateWindowHeight;
	bool configure;
	if(!clientSystem or !isValidClient(clientSystem, client) or (*client).option & (OVERRIDE_REDIRECT_CLIENT_OPTION | TEMPORARILY_UNMAPPED_CLIENT_OPTION) or windowGravity > CENTER_POINT_WINDOW_GRAVITY){
		ret false;
	}
	if(treatAsNormal){
		if(width == (int)((*client).containerWidth + 2 * (*client).containerBorder) and height == (int)((*client).containerHeight + 2 * (*client).containerBorder)){
			if(!((*client).allowedAction & MOVE_ALLOWED_ACTION)){
				ret false;
			}
		}else{
			if(!((*client).allowedAction & RESIZE_ALLOWED_ACTION)){
				ret false;
			}
		}
	}
	candidateContainerX = (*client).containerX;
	candidateContainerY = (*client).containerY;
	candidateContainerWidth = (*client).containerWidth;
	candidateContainerHeight = (*client).containerHeight;
	candidateWindowX = (*client).windowX;
	candidateWindowY = (*client).windowY;
	candidateWindowWidth = (*client).windowWidth;
	candidateWindowHeight = (*client).windowHeight;
	windowWidth = width - 2 * (*client).windowBorder - (*client).frameExtentsLeft - (*client).frameExtentsRight - 2 * (*client).containerBorder;
	windowHeight = height - 2 * (*client).windowBorder - (*client).frameExtentsTop - (*client).frameExtentsBottom - 2 * (*client).containerBorder;
	if(repositionAfterwards){
		if(windowWidth < 1){
			windowWidth = 1;
		}
		if(windowHeight < 1){
			windowHeight = 1;
		}
		containerWidth = windowWidth + 2 * (*client).windowBorder + (*client).frameExtentsLeft + (*client).frameExtentsRight;
		containerHeight = windowHeight + 2 * (*client).windowBorder + (*client).frameExtentsTop + (*client).frameExtentsBottom;
		candidateContainerX = x;
		candidateContainerY = y;
		candidateContainerWidth = containerWidth;
		candidateContainerHeight = containerHeight;
		candidateWindowX = 0;
		candidateWindowY = 0;
		candidateWindowWidth = windowWidth;
		candidateWindowHeight = windowHeight;
	}
	if(useMinimumHints and (*client).normalHintsFlags & PROGRAM_MINIMUM_SIZE_NORMAL_HINT){
		if(windowWidth < (*client).normalHintsMinWidth){
			if(windowGravity and windowGravity != NORTH_SIDE_WINDOW_GRAVITY and windowGravity != SOUTH_SIDE_WINDOW_GRAVITY){
				windowWidth = (*client).normalHintsMinWidth;
			}
		}
		if(windowHeight < (*client).normalHintsMinHeight){
			if(windowGravity and windowGravity != WEST_SIDE_WINDOW_GRAVITY and windowGravity != EAST_SIDE_WINDOW_GRAVITY){
				windowHeight = (*client).normalHintsMinHeight;
			}
		}
	}
	if(useMaximumHints and (*client).normalHintsFlags & PROGRAM_MAXIMUM_SIZE_NORMAL_HINT){
		if(windowWidth > (*client).normalHintsMaxWidth){
			if(windowGravity and windowGravity != NORTH_SIDE_WINDOW_GRAVITY and windowGravity != SOUTH_SIDE_WINDOW_GRAVITY){
				windowWidth = (*client).normalHintsMaxWidth;
			}
		}
		if(windowHeight > (*client).normalHintsMaxHeight){
			if(windowGravity and windowGravity != WEST_SIDE_WINDOW_GRAVITY and windowGravity != EAST_SIDE_WINDOW_GRAVITY){
				windowHeight = (*client).normalHintsMaxHeight;
			}
		}
	}
	if(windowWidth < 1){
		windowWidth = 1;
	}
	if(windowHeight < 1){
		windowHeight = 1;
	}
	containerWidth = windowWidth + 2 * (*client).windowBorder + (*client).frameExtentsLeft + (*client).frameExtentsRight;
	containerHeight = windowHeight + 2 * (*client).windowBorder + (*client).frameExtentsTop + (*client).frameExtentsBottom;
	if(containerWidth != candidateContainerWidth or containerHeight != candidateContainerWidth){
		const int offsetX = candidateContainerWidth - containerWidth;
		const int offsetY = candidateContainerHeight - containerHeight;
		switch(windowGravity){
			to NONE_WINDOW_GRAVITY: /*-------------*/ /*-------------*/ /*-------------*/ brk;
			to NORTH_POINT_WINDOW_GRAVITY: /*------*/ x += offsetX / 2; /*-------------*/ brk;
			to NORTH_SIDE_WINDOW_GRAVITY: /*-------*/ /*-------------*/ /*-------------*/ brk;
			to SOUTH_POINT_WINDOW_GRAVITY: /*------*/ x += offsetX / 2; y += offsetY / 1; brk;
			to SOUTH_SIDE_WINDOW_GRAVITY: /*-------*/ /*-------------*/ y += offsetY / 1; brk;
			to WEST_POINT_WINDOW_GRAVITY: /*-------*/ /*-------------*/ y += offsetY / 2; brk;
			to WEST_SIDE_WINDOW_GRAVITY: /*--------*/ /*-------------*/ /*-------------*/ brk;
			to EAST_POINT_WINDOW_GRAVITY: /*-------*/ x += offsetX / 1; y += offsetY / 2; brk;
			to EAST_SIDE_WINDOW_GRAVITY: /*--------*/ x += offsetX / 1; /*-------------*/ brk;
			to NORTH_WEST_POINT_WINDOW_GRAVITY: /*-*/ /*-------------*/ /*-------------*/ brk;
			to NORTH_EAST_POINT_WINDOW_GRAVITY: /*-*/ x += offsetX / 1; /*-------------*/ brk;
			to SOUTH_WEST_POINT_WINDOW_GRAVITY: /*-*/ /*-------------*/ y += offsetY / 1; brk;
			to SOUTH_EAST_POINT_WINDOW_GRAVITY: /*-*/ x += offsetX / 1; y += offsetY / 1; brk;
			to CENTER_POINT_WINDOW_GRAVITY: /*-----*/ x += offsetX / 2; y += offsetY / 2; brk;
			off: /*--------------------------------*/ /*-------------*/ /*-------------*/ brk;
		}
	}
	configure = windowWidth != (int)(*client).windowWidth or windowHeight != (int)(*client).windowHeight;
	(*client).containerX = x;
	(*client).containerY = y;
	(*client).containerWidth = containerWidth;
	(*client).containerHeight = containerHeight;
	(*client).windowX = 0;
	(*client).windowY = 0;
	(*client).windowWidth = windowWidth;
	(*client).windowHeight = windowHeight;
	if(!configure and !force){
		sendClientConfigureEvent(clientSystem, client);
	}else{
		xcb_discard_reply(connection, xcb_configure_window_checked(connection, (*client).window, XCB_CONFIG_WINDOW_X | XCB_CONFIG_WINDOW_Y | XCB_CONFIG_WINDOW_WIDTH | XCB_CONFIG_WINDOW_HEIGHT, &(*client).windowX));
		if(force){
			xcb_configure_window(connection, (*client).container, XCB_CONFIG_WINDOW_X | XCB_CONFIG_WINDOW_Y | XCB_CONFIG_WINDOW_WIDTH | XCB_CONFIG_WINDOW_HEIGHT, &(*client).containerX);
		}
	}
	(*client).option &= ~(HORIZONTALLY_MAXIMIZED_CLIENT_OPTION | VERTICALLY_MAXIMIZED_CLIENT_OPTION);
	(*client).workareaPosition = NONE_WORKAREA_POSITION;
	ret true;
}
SENDCLIENTCONFIGUREEVENT(){
	xcb_configure_notify_event_t message;
	Client *siblingClient;
	if(!clientSystem or !isValidClient(clientSystem, client) or (*client).option & (OVERRIDE_REDIRECT_CLIENT_OPTION | TEMPORARILY_UNMAPPED_CLIENT_OPTION)){
		ret false;
	}
	message.response_type = XCB_CONFIGURE_NOTIFY;
	message.event = (*client).window;
	message.window = (*client).window;
	message.above_sibling = XCB_NONE;
	if((siblingClient = findBelowClient(clientSystem, client))){
		message.above_sibling = (*siblingClient).window;
	}
	message.x = (*client).containerX + (*client).containerBorder + (*client).frameExtentsLeft;
	message.y = (*client).containerY + (*client).containerBorder + (*client).frameExtentsTop;
	message.width = (*client).windowWidth;
	message.height = (*client).windowHeight;
	message.border_width = (*client).windowBorder;
	message.override_redirect = false;
	xcb_discard_reply(connection, xcb_send_event_checked(connection, false, message.window, XCB_EVENT_MASK_STRUCTURE_NOTIFY, &message));
	ret true;
}
RESTACKCLIENT(){
	uint *start;
	uint *current;
	uint *wall;
	uint *top;
	uint *bottom;
	int copy0X;
	int copy0Y;
	uint copy0Width;
	uint copy0Height;
	int copy1X;
	int copy1Y;
	uint copy1Width;
	uint copy1Height;
	uint copy;
	Client *clientStart;
	if(!clientSystem or !(*clientSystem).orderedClientOffsetStart){
		ret false;
	}
	start = (*clientSystem).orderedClientOffsetStart;
	wall = start + (*clientSystem).orderedClientOffsetAllocated;
	clientStart = (*clientSystem).clientStart;
	switch(stackMode){
		to XCB_STACK_MODE_ABOVE: /*-----*/ jmp stackModeAbove;
		to XCB_STACK_MODE_BELOW: /*-----*/ jmp stackModeBelow;
		to XCB_STACK_MODE_TOP_IF: /*----*/ jmp stackModeTopIf;
		to XCB_STACK_MODE_BOTTOM_IF: /*-*/ jmp stackModeBottomIf;
		to XCB_STACK_MODE_OPPOSITE: /*--*/ jmp stackModeOpposite;
		off: /*-------------------------*/ ret false;
	}
	stackModeAbove:{
		uint *siblingClient = wall - 1;
		if(!(current = findOrderedClientOffset(clientSystem, client))){
			ret false;
		}
		copy = *current;
		if(sibling and !(siblingClient = findOrderedClientOffset(clientSystem, findClientWindow(clientSystem, sibling)))){
			jmp correctPosition;
		}
		if(current == siblingClient or current == siblingClient + 1){
			jmp correctPosition;
		}
		if(current < siblingClient){
			top = siblingClient;
			jmp moveUpLoop;
		}
		bottom = siblingClient + 1;
		jmp moveDownLoop;
	}
	stackModeBelow:{
		uint *siblingClient = start;
		if(!(current = findOrderedClientOffset(clientSystem, client))){
			ret false;
		}
		copy = *current;
		if(sibling and !(siblingClient = findOrderedClientOffset(clientSystem, findClientWindow(clientSystem, sibling)))){
			jmp correctPosition;
		}
		if(current == siblingClient or current == siblingClient - 1){
			jmp correctPosition;
		}
		if(current < siblingClient){
			top = siblingClient - 1;
			jmp moveUpLoop;
		}
		bottom = siblingClient;
		jmp moveDownLoop;
	}
	stackModeTopIf:{
		uint *siblingCurrent;
		uint *siblingWall = wall;
		Client *c;
		if(!(current = findOrderedClientOffset(clientSystem, client))){
			ret false;
		}
		copy = *current;
		if(current == wall - 1){
			jmp correctPosition;
		}
		siblingCurrent = current + 1;
		if(sibling){
			if(!(siblingCurrent = findOrderedClientOffset(clientSystem, findClientWindow(clientSystem, sibling))) or siblingCurrent <= current){
				jmp correctPosition;
			}
			siblingWall = siblingCurrent + 1;
		}
		c = clientStart + *current;
		if((*c).container){
			const uint border = 2 * (*c).containerBorder;
			copy0X = (*c).containerX;
			copy0Y = (*c).containerY;
			copy0Width = (*c).containerWidth + border;
			copy0Height = (*c).containerHeight + border;
		}else{
			const uint border = 2 * (*c).windowBorder;
			copy0X = (*c).windowX;
			copy0Y = (*c).windowY;
			copy0Width = (*c).windowWidth + border;
			copy0Height = (*c).windowHeight + border;
		}
		jmp topIfLoop;
		topIfLoop:{
			if(siblingCurrent < siblingWall){
				c = clientStart + *siblingCurrent;
				if((*c).container){
					const uint border = 2 * (*c).containerBorder;
					copy1X = (*c).containerX;
					copy1Y = (*c).containerY;
					copy1Width = (*c).containerWidth + border;
					copy1Height = (*c).containerHeight + border;
				}else{
					const uint border = 2 * (*c).windowBorder;
					copy1X = (*c).windowX;
					copy1Y = (*c).windowY;
					copy1Width = (*c).windowWidth + border;
					copy1Height = (*c).windowHeight + border;
				}
				if(intersects(copy0X, copy0Y, copy0Width, copy0Height, copy1X, copy1Y, copy1Width, copy1Height)){
					top = siblingCurrent;
					jmp moveUpLoop;
				}
				inc siblingCurrent;
				jmp topIfLoop;
			}
			jmp correctPosition;
		}
	}
	stackModeBottomIf:{
		uint *siblingStart = start - 1;
		uint *siblingCurrent;
		Client *c;
		if(!(current = findOrderedClientOffset(clientSystem, client))){
			ret false;
		}
		copy = *current;
		if(current == start){
			jmp correctPosition;
		}
		siblingCurrent = current - 1;
		if(sibling){
			if(!(siblingCurrent = findOrderedClientOffset(clientSystem, findClientWindow(clientSystem, sibling))) or siblingCurrent >= current){
				jmp correctPosition;
			}
			siblingStart = siblingCurrent - 1;
		}
		c = clientStart + *current;
		if((*c).container){
			const uint border = 2 * (*c).containerBorder;
			copy0X = (*c).containerX;
			copy0Y = (*c).containerY;
			copy0Width = (*c).containerWidth + border;
			copy0Height = (*c).containerHeight + border;
		}else{
			const uint border = 2 * (*c).windowBorder;
			copy0X = (*c).windowX;
			copy0Y = (*c).windowY;
			copy0Width = (*c).windowWidth + border;
			copy0Height = (*c).windowHeight + border;
		}
		jmp bottomIfLoop;
		bottomIfLoop:{
			if(siblingCurrent > siblingStart){
				c = clientStart + *siblingCurrent;
				if((*c).container){
					const uint border = 2 * (*c).containerBorder;
					copy1X = (*c).containerX;
					copy1Y = (*c).containerY;
					copy1Width = (*c).containerWidth + border;
					copy1Height = (*c).containerHeight + border;
				}else{
					const uint border = 2 * (*c).windowBorder;
					copy1X = (*c).windowX;
					copy1Y = (*c).windowY;
					copy1Width = (*c).windowWidth + border;
					copy1Height = (*c).windowHeight + border;
				}
				if(intersects(copy0X, copy0Y, copy0Width, copy0Height, copy1X, copy1Y, copy1Width, copy1Height)){
					top = siblingCurrent;
					jmp moveUpLoop;
				}
				dec siblingCurrent;
				jmp bottomIfLoop;
			}
			jmp correctPosition;
		}
	}
	stackModeOpposite:{
		uint *siblingStart = start - 1;
		uint *siblingCurrent;
		uint *siblingWall = wall;
		Client *c;
		if(!(current = findOrderedClientOffset(clientSystem, client))){
			ret false;
		}
		copy = *current;
		if(sibling){
			if(!(siblingCurrent = findOrderedClientOffset(clientSystem, findClientWindow(clientSystem, sibling))) or siblingCurrent == current){
				jmp correctPosition;
			}
			siblingStart = siblingCurrent - 1;
			siblingWall = siblingCurrent + 1;
		}
		c = clientStart + *current;
		if((*c).container){
			const uint border = 2 * (*c).containerBorder;
			copy0X = (*c).containerX;
			copy0Y = (*c).containerY;
			copy0Width = (*c).containerWidth + border;
			copy0Height = (*c).containerHeight + border;
		}else{
			const uint border = 2 * (*c).windowBorder;
			copy0X = (*c).windowX;
			copy0Y = (*c).windowY;
			copy0Width = (*c).windowWidth + border;
			copy0Height = (*c).windowHeight + border;
		}
		siblingCurrent = current + 1;
		jmp stackModeOppositeUpLoop;
		stackModeOppositeUpLoop:{
			if(siblingCurrent < siblingWall){
				c = clientStart + *siblingCurrent;
				if((*c).container){
					const uint border = 2 * (*c).containerBorder;
					copy1X = (*c).containerX;
					copy1Y = (*c).containerY;
					copy1Width = (*c).containerWidth + border;
					copy1Height = (*c).containerHeight + border;
				}else{
					const uint border = 2 * (*c).windowBorder;
					copy1X = (*c).windowX;
					copy1Y = (*c).windowY;
					copy1Width = (*c).windowWidth + border;
					copy1Height = (*c).windowHeight + border;
				}
				if(intersects(copy0X, copy0Y, copy0Width, copy0Height, copy1X, copy1Y, copy1Width, copy1Height)){
					top = wall - 1;
					jmp moveUpLoop;
				}
				inc siblingCurrent;
				jmp stackModeOppositeUpLoop;
			}
			siblingCurrent = current - 1;
			jmp stackModeOppositeDownLoop;
		}
		stackModeOppositeDownLoop:{
			if(siblingCurrent > siblingStart){
				c = clientStart + *siblingCurrent;
				if((*c).container){
					const uint border = 2 * (*c).containerBorder;
					copy1X = (*c).containerX;
					copy1Y = (*c).containerY;
					copy1Width = (*c).containerWidth + border;
					copy1Height = (*c).containerHeight + border;
				}else{
					const uint border = 2 * (*c).windowBorder;
					copy1X = (*c).windowX;
					copy1Y = (*c).windowY;
					copy1Width = (*c).windowWidth + border;
					copy1Height = (*c).windowHeight + border;
				}
				if(intersects(copy0X, copy0Y, copy0Width, copy0Height, copy1X, copy1Y, copy1Width, copy1Height)){
					bottom = start;
					jmp moveDownLoop;
				}
				dec siblingCurrent;
				jmp stackModeOppositeDownLoop;
			}
			jmp correctPosition;
		}
	}
	moveUpLoop:{
		if(current < top and (*(clientStart + copy)).orderType <= (*(clientStart + *(current + 1))).orderType){
			if(true){
				*current = *(current + 1);
				inc current;
				jmp moveUpLoop;
			}
		}
		jmp correctPosition;
	}
	moveDownLoop:{
		if(current > bottom and (*(clientStart + copy)).orderType >= (*(clientStart + *(current - 1))).orderType){
			if(true){
				*current = *(current - 1);
				dec current;
				jmp moveDownLoop;
			}
		}
		jmp correctPosition;
	}
	correctPosition:{
		uint *top = wall - 1;
		uint *bottom = start;
		jmp correctPositionDownLoop;
		correctPositionDownLoop:{
			if(current > bottom and (*(clientStart + copy)).orderType > (*(clientStart + *(current - 1))).orderType){
				if(true){
					*current = *(current - 1);
					dec current;
					jmp correctPositionDownLoop;
				}
			}
			jmp correctPositionUpLoop;
		}
		correctPositionUpLoop:{
			if(current < top and (*(clientStart + copy)).orderType < (*(clientStart + *(current + 1))).orderType){
				if(true){
					*current = *(current + 1);
					inc current;
					jmp correctPositionUpLoop;
				}
			}
			if(*current == copy){
				ret false;
			}
			*current = copy;
			ret true;
		}
	}
}
CONFIGURECLIENT(){
	Client *siblingClient;
	uint8 stackMode;
	uint32 valueMask;
	uint32 valueList[2];
	if(!clientSystem or !isValidClient(clientSystem, client) or ((*client).desktop != NONE_DESKTOP and (*client).desktop != 0xFFFFFFFF and !((*client).state & FULLSCREEN_STATE))){
		ret false;
	}
	if((siblingClient = findBelowDesktopClient(clientSystem, client))){
		stackMode = XCB_STACK_MODE_ABOVE;
		valueMask = XCB_CONFIG_WINDOW_SIBLING | XCB_CONFIG_WINDOW_STACK_MODE;
		*(valueList + 0) = (*siblingClient).container;
		*(valueList + 1) = stackMode;
	}elif((siblingClient = findAboveDesktopClient(clientSystem, client))){
		stackMode = XCB_STACK_MODE_BELOW;
		valueMask = XCB_CONFIG_WINDOW_SIBLING | XCB_CONFIG_WINDOW_STACK_MODE;
		*(valueList + 0) = (*siblingClient).container;
		*(valueList + 1) = stackMode;
	}else{
		stackMode = XCB_STACK_MODE_ABOVE;
		valueMask = XCB_CONFIG_WINDOW_STACK_MODE;
		*(valueList + 0) = stackMode;
	}
	xcb_configure_window(connection, (*client).container, valueMask, valueList);
	ret true;
}
ASSIGNCLIENTSTRUT(){
	Monitor *monitor;
	int x;
	int y;
	int width;
	int height;
	if(!clientSystem or !monitorSystem or !(*monitorSystem).size or !isValidClient(clientSystem, client)){
		ret false;
	}
	if((*client).strutTop){
		x = (*client).strutTopStartX;
		y = 0;
		width = (*client).strutTopEndX - (*client).strutTopStartX;
		height = (*client).strutTop;
		(*client).strut = TOP_STRUT;
	}elif((*client).strutBottom){
		x = (*client).strutBottomStartX;
		y = screenHeightInPixels - (*client).strutBottom;
		width = (*client).strutBottomEndX - (*client).strutBottomStartX;
		height = (*client).strutBottom;
		(*client).strut = BOTTOM_STRUT;
	}elif((*client).strutLeft){
		x = 0;
		y = (*client).strutLeftStartY;
		width = (*client).strutLeft;
		height = (*client).strutLeftEndY - (*client).strutLeftStartY;
		(*client).strut = LEFT_STRUT;
	}elif((*client).strutRight){
		x = screenWidthInPixels - (*client).strutRight;
		y = (*client).strutRightStartY;
		width = (*client).strutRight;
		height = (*client).strutRightEndY - (*client).strutRightStartY;
		(*client).strut = RIGHT_STRUT;
	}else{
		(*client).strut = NONE_STRUT;
		ret false;
	}
	if(width < 0 or height < 0){
		(*client).strut = NONE_STRUT;
		ret false;
	}
	if(x + width >= (int)screenWidthInPixels){
		x = (int)screenWidthInPixels - width;
	}
	if(y + height >= (int)screenHeightInPixels){
		y = (int)screenHeightInPixels - height;
	}
	x *= (x > 0);
	y *= (y > 0);
	if(!(monitor = findRectangleMonitor(monitorSystem, x, y, width, height))){
		ret false;
	}
	getIntersection((*monitor).leftX, (*monitor).topY, (*monitor).width, (*monitor).height, x, y, width, height, &x, &y, &width, &height);
	if(width < 1){
		width = 1;
	}
	if(height < 1){
		height = 1;
	}
	(*client).strutX = x;
	(*client).strutY = y;
	(*client).strutWidth = width;
	(*client).strutHeight = height;
	ret true;
}
GETFOCUSEDCLIENT(){
	if(!clientSystem or !(*clientSystem).focusedClientOffset){
		ret NULL;
	}
	ret (*clientSystem).clientStart + (*clientSystem).focusedClientOffset;
}
SETFOCUSEDCLIENT(){
	if(!clientSystem or !isValidClient(clientSystem, client) or client == getFocusedClient(clientSystem) or (*client).stateState != NORMAL_STATE){
		ret false;
	}
	if(!(*client).hintsInput and !((*client).protocol & TAKE_FOCUS_CLIENT_PROTOCOL) and !((*client).windowType & (TOOLBAR_WINDOW_TYPE | UTILITY_WINDOW_TYPE | DIALOG_WINDOW_TYPE | NORMAL_WINDOW_TYPE))){
		ret false;
	}
	if(findModalTransientForClient(clientSystem, client)){
		ret false;
	}
	if((*client).desktop != NONE_DESKTOP and (*client).desktop != 0xFFFFFFFF and (*client).desktop != currentDesktop){
		if(!(*client).hintsInput and !((*client).windowType & (TOOLBAR_WINDOW_TYPE | UTILITY_WINDOW_TYPE | DIALOG_WINDOW_TYPE | NORMAL_WINDOW_TYPE))){
			ret false;
		}
		if(updateClientState(clientSystem, client, _NET_WM_STATE_ADD, DEMANDS_ATTENTION_STATE)){
			changeClientState(clientSystem, client);
		}
		ret true;
	}
	if((*client).protocol & TAKE_FOCUS_CLIENT_PROTOCOL and !(*client).hintsInput){
		offerClientFocus(clientSystem, client);
		ret true;
	}
	xcb_discard_reply(connection, xcb_set_input_focus_checked(connection, XCB_INPUT_FOCUS_POINTER_ROOT, (*client).window, getTimestamp()));
	ret true;
}
OFFERCLIENTFOCUS(){
	xcb_client_message_event_t message;
	if(!clientSystem or !isValidClient(clientSystem, client)){
		ret false;
	}
	message.response_type = XCB_CLIENT_MESSAGE;
	message.format = 32;
	message.window = (*client).window;
	message.type = atom.WM_PROTOCOLS;
	*(message.data.data32 + 0) = atom.WM_TAKE_FOCUS;
	*(message.data.data32 + 1) = getTimestamp();
	*(message.data.data32 + 2) = 0;
	*(message.data.data32 + 3) = 0;
	*(message.data.data32 + 4) = 0;
	xcb_discard_reply(connection, xcb_send_event_checked(connection, false, message.window, XCB_NONE, &message));
	ret true;
}
FOCUSCLIENT(){
	if(!clientSystem or !isValidClient(clientSystem, client) or client == getFocusedClient(clientSystem) or (*client).stateState != NORMAL_STATE or (*client).option & TEMPORARILY_UNMAPPED_CLIENT_OPTION){
		ret false;
	}
	if(focusOnClick){
		Client *const oldFocusedClient = getFocusedClient(clientSystem);
		if(oldFocusedClient){



/*!
			if((*oldFocusedClient).container){
				const uint32 valueList = CONTAINER_EVENT_MASK;
				xcb_change_window_attributes(connection, (*oldFocusedClient).container, XCB_CW_EVENT_MASK, &valueList);
			}
			{
				const uint32 valueList = WINDOW_EVENT_MASK;
				xcb_discard_reply(connection, xcb_change_window_attributes_checked(connection, (*oldFocusedClient).window, XCB_CW_EVENT_MASK, &valueList));
			}
*/



			if((*oldFocusedClient).container){
				xcb_grab_button(connection, true, (*oldFocusedClient).container, XCB_EVENT_MASK_BUTTON_PRESS, XCB_GRAB_MODE_ASYNC, XCB_GRAB_MODE_ASYNC, XCB_NONE, XCB_NONE, XCB_BUTTON_INDEX_1, XCB_NONE);
			}
			xcb_discard_reply(connection, xcb_grab_button_checked(connection, true, (*oldFocusedClient).window, XCB_EVENT_MASK_BUTTON_PRESS, XCB_GRAB_MODE_ASYNC, XCB_GRAB_MODE_ASYNC, XCB_NONE, XCB_NONE, XCB_BUTTON_INDEX_1, XCB_NONE));



		}



/*!
		if((*client).container){
			const uint32 valueList = CONTAINER_EVENT_MASK | XCB_EVENT_MASK_BUTTON_PRESS;
			xcb_change_window_attributes(connection, (*client).container, XCB_CW_EVENT_MASK, &valueList);
		}
		{
			const uint32 valueList = WINDOW_EVENT_MASK | XCB_EVENT_MASK_BUTTON_PRESS;
			xcb_discard_reply(connection, xcb_change_window_attributes_checked(connection, (*client).window, XCB_CW_EVENT_MASK, &valueList));
		}
*/



		if((*client).container){
			xcb_ungrab_button(connection, XCB_BUTTON_INDEX_1, (*client).container, XCB_NONE);
		}
		xcb_discard_reply(connection, xcb_ungrab_button_checked(connection, XCB_BUTTON_INDEX_1, (*client).window, XCB_NONE));



	}
	(*clientSystem).focusedClientOffset = client - (*clientSystem).clientStart;
	(*client).hintsUrgency = false;
	if(updateClientState(clientSystem, client, _NET_WM_STATE_REMOVE, DEMANDS_ATTENTION_STATE)){
		changeClientState(clientSystem, client);
	}
	ret true;
}
CHANGEACTIVEWINDOW(){
	Client *client;
	xcb_window_t activeWindow;
	if(!clientSystem){
		ret false;
	}
	activeWindow = XCB_NONE;
	if((client = getFocusedClient(clientSystem))){
		activeWindow = (*client).window;
	}
	xcb_change_property(connection, XCB_PROP_MODE_REPLACE, (*screen).root, atom._NET_ACTIVE_WINDOW, XCB_ATOM_WINDOW, bitsof(xcb_window_t), 1, &activeWindow);
	ret true;
}
SETMOTIONCLIENT(){
	struct{
		uint32 /*-*/ stackMode;
	} valueList;
	if(!clientSystem or !isValidClient(clientSystem, client)){
		ret false;
	}
	if(!intersects(x, y, 1, 1, (*client).containerX, (*client).containerY, (*client).containerWidth + 2 * (*client).containerBorder, (*client).containerHeight + 2 * (*client).containerBorder)){
		ret false;
	}
	valueList.stackMode = XCB_STACK_MODE_ABOVE;
	xcb_configure_window(connection, glassWindow, XCB_CONFIG_WINDOW_STACK_MODE, &valueList);
	xcb_map_window(connection, glassWindow);
	(*clientSystem).motionAction = motionAction;
	(*clientSystem).motionGravity = motionGravity;
	(*clientSystem).motionStartingX = x;
	(*clientSystem).motionStartingY = y;
	(*clientSystem).motionX = (*client).containerX;
	(*clientSystem).motionY = (*client).containerY;
	(*clientSystem).motionWidth = (*client).containerWidth + 2 * (*client).containerBorder;
	(*clientSystem).motionHeight = (*client).containerHeight + 2 * (*client).containerBorder;
	(*clientSystem).motionClientOffset = client - (*clientSystem).clientStart;
	ret true;
}
UNSETMOTIONCLIENT(){
	if(!clientSystem or !(*clientSystem).motionAction){
		ret false;
	}
	xcb_unmap_window(connection, glassWindow);
	(*clientSystem).motionAction = NONE_MOTION_ACTION;
	(*clientSystem).motionClientOffset = 0;
	ret true;
}
CLOSECLIENT(){
	#define KILL_SUCCESS /*-*/ (0)
	if(!clientSystem or !isValidClient(clientSystem, client)){
		ret false;
	}
	switch(command){
		to NONE_CLOSE_CLIENT_COMMAND:{
			ret false;
		}
		to CLOSE_CLOSE_CLIENT_COMMAND:{
			xcb_client_message_event_t message;
			uint32 *const data = message.data.data32;
			if(!((*client).protocol & DELETE_WINDOW_CLIENT_PROTOCOL) or !((*client).allowedAction & CLOSE_ALLOWED_ACTION)){
				ret false;
			}
			message.response_type = XCB_CLIENT_MESSAGE;
			message.format = 32;
			message.window = (*client).window;
			message.type = atom.WM_PROTOCOLS;
			*(data + 0) = atom.WM_DELETE_WINDOW;
			*(data + 1) = getTimestamp();
			*(data + 2) = 0;
			*(data + 3) = 0;
			*(data + 4) = 0;
			xcb_discard_reply(connection, xcb_send_event_checked(connection, false, message.window, XCB_NONE, &message));
			ret true;
		}
		to KILL_CLOSE_CLIENT_COMMAND:{
			if(!(*client).pid or kill((*client).pid, SIGTERM) != KILL_SUCCESS){
				xcb_discard_reply(connection, xcb_kill_client_checked(connection, (*client).window));
			}
			ret true;
		}
		off:{
			ret false;
		}
	}
	#undef  KILL_SUCCESS
}
LOSEFOCUS(){
	if(!clientSystem or !getFocusedClient(clientSystem)){
		ret false;
	}
	unfocusClient(clientSystem);
	xcb_set_input_focus(connection, XCB_INPUT_FOCUS_POINTER_ROOT, defaultFocusWindow, getTimestamp());
	ret true;
}
UNFOCUSCLIENT(){
	Client *focusedClient;
	if(!clientSystem){
		ret false;
	}
	focusedClient = getFocusedClient(clientSystem);
	if(!focusedClient){
		ret false;
	}
	if(focusOnClick){
		if(focusedClient){



/*!
			if((*focusedClient).container){
				const uint32 valueList = CONTAINER_EVENT_MASK;
				xcb_change_window_attributes(connection, (*focusedClient).container, XCB_CW_EVENT_MASK, &valueList);
			}
			{
				const uint32 valueList = WINDOW_EVENT_MASK;
				xcb_discard_reply(connection, xcb_change_window_attributes_checked(connection, (*focusedClient).window, XCB_CW_EVENT_MASK, &valueList));
			}
*/



			xcb_grab_button(connection, true, (*focusedClient).container, XCB_EVENT_MASK_BUTTON_PRESS, XCB_GRAB_MODE_ASYNC, XCB_GRAB_MODE_ASYNC, XCB_NONE, XCB_NONE, XCB_BUTTON_INDEX_1, XCB_NONE);
			xcb_discard_reply(connection, xcb_grab_button_checked(connection, true, (*focusedClient).window, XCB_EVENT_MASK_BUTTON_PRESS, XCB_GRAB_MODE_ASYNC, XCB_GRAB_MODE_ASYNC, XCB_NONE, XCB_NONE, XCB_BUTTON_INDEX_1, XCB_NONE));



		}
	}
	(*clientSystem).focusedClientOffset = 0;
	ret true;
}
UNMAPCLIENT(){
	if(!clientSystem or !isValidClient(clientSystem, client) or (state != WITHDRAWN_STATE and state != ICONIC_STATE) or (*client).stateState == state){
		ret false;
	}
	if((*client).option & OVERRIDE_REDIRECT_CLIENT_OPTION){
		(*client).stateState = WITHDRAWN_STATE;
	}else{
		xcb_unmap_window(connection, (*client).container);
		xcb_discard_reply(connection, xcb_unmap_window_checked(connection, (*client).window));
		if(state == WITHDRAWN_STATE){
			xcb_discard_reply(connection, xcb_reparent_window_checked(connection, (*client).window, (*screen).root, 0, 0));
			if(updateClientState(clientSystem, client, _NET_WM_STATE_REMOVE, ~NONE_STATE)){
				changeClientState(clientSystem, client);
			}
		}else{
			if(updateClientState(clientSystem, client, _NET_WM_STATE_ADD, HIDDEN_STATE)){
				changeClientState(clientSystem, client);
			}
		}
		(*client).stateState = state;
		xcb_discard_reply(connection, xcb_change_property_checked(connection, XCB_PROP_MODE_REPLACE, (*client).window, atom.WM_STATE, atom.WM_STATE, bitsof(uint32), 2, &(*client).stateState));
		(*client).option &= ~TEMPORARILY_UNMAPPED_CLIENT_OPTION;
	}
	unsetMotionClient(clientSystem);
	if(client == getFocusedClient(clientSystem)){
		loseFocus(clientSystem);
	}
	ret true;
}
DESTROYCLIENT(){
	uint *current;
	if(!clientSystem or !isValidClient(clientSystem, client)){
		ret false;
	}
	unmapClient(clientSystem, client, WITHDRAWN_STATE);
	if((current = findOrderedClientOffset(clientSystem, client))){
		shiftMemory(current + 1, ((*clientSystem).orderedClientOffsetStart + (*clientSystem).orderedClientOffsetAllocated - current - 1) * sizeof(uint), -(int)sizeof(uint));
		dec (*clientSystem).orderedClientOffsetAllocated;
	}
	free((*client).iconStart);
	popPointer((*client).iconToken);
	free((*client).allowedActionStart);
	popPointer((*client).allowedActionToken);
	free((*client).stateStart);
	popPointer((*client).stateToken);
	free((*client).windowTypeStart);
	popPointer((*client).windowTypeToken);
	free((*client).visibleIconNameStart);
	popPointer((*client).visibleIconNameToken);
	free((*client).visibleNameStart);
	popPointer((*client).visibleNameToken);
	free((*client).windowRoleStart);
	popPointer((*client).windowRoleToken);
	free((*client).clientIDStart);
	popPointer((*client).clientIDToken);
	free((*client).clientMachineStart);
	popPointer((*client).clientMachineToken);
	free((*client).colormapWindowStart);
	popPointer((*client).colormapWindowToken);
	free((*client).protocolStart);
	popPointer((*client).protocolToken);
	free((*client).classStart);
	popPointer((*client).classToken);
	free((*client).iconNameStart);
	popPointer((*client).iconNameToken);
	free((*client).nameStart);
	popPointer((*client).nameToken);
	if((*client).gc){
		xcb_free_gc(connection, (*client).gc);
	}
	if((*client).pixmap){
		xcb_free_pixmap(connection, (*client).pixmap);
	}
	if((*client).container){
		xcb_destroy_window(connection, (*client).container);
	}
	(*client).inUse = false;
	if(client == (*clientSystem).clientStart + (*clientSystem).clientAllocated - 1){
		if(dec (*clientSystem).clientAllocated < (*clientSystem).clientNotInUseOffset){
			dec (*clientSystem).clientNotInUseOffset;
		}
	}elif(client - (*clientSystem).clientStart < (*clientSystem).clientNotInUseOffset){
		(*clientSystem).clientNotInUseOffset = client - (*clientSystem).clientStart;
	}
	ret true;
}
ISVALIDCLIENT(){
	ret clientSystem and (*clientSystem).clientAllocated > 1 and client and client > (*clientSystem).clientStart and client < (*clientSystem).clientStart + (*clientSystem).clientAllocated and (*client).inUse;
}
FINDCLIENTWINDOW(){
	Client *current;
	Client *wall;
	if(!clientSystem or !(*clientSystem).clientAllocated or !window){
		ret NULL;
	}
	current = (*clientSystem).clientStart;
	wall = current + (*clientSystem).clientAllocated;
	jmp findClientWindowLoop;
	findClientWindowLoop:{
		if(current < wall){
			if((*current).window == window){
				if(!(*current).inUse){
					ret NULL;
				}
				ret current;
			}
			inc current;
			jmp findClientWindowLoop;
		}
		ret NULL;
	}
}
FINDCLIENTCONTAINER(){
	Client *current;
	Client *wall;
	if(!clientSystem or !(*clientSystem).clientAllocated or !window){
		ret NULL;
	}
	current = (*clientSystem).clientStart;
	wall = current + (*clientSystem).clientAllocated;
	jmp findClientContainerLoop;
	findClientContainerLoop:{
		if(current < wall){
			if((*current).container == window){
				if(!(*current).inUse){
					ret NULL;
				}
				ret current;
			}
			inc current;
			jmp findClientContainerLoop;
		}
		ret NULL;
	}
}
FINDCONFIGUREDCLIENTWINDOW(){
	Client *current;
	Client *wall;
	if(!clientSystem or !(*clientSystem).clientAllocated or !window){
		ret NULL;
	}
	if((*clientSystem).recentlyConfiguredClientOffset){
		current = (*clientSystem).clientStart + (*clientSystem).recentlyConfiguredClientOffset;
		if(isValidClient(clientSystem, current) and (*current).window == window){
			ret current;
		}
		(*clientSystem).recentlyConfiguredClientOffset = 0;
	}
	current = (*clientSystem).clientStart;
	wall = current + (*clientSystem).clientAllocated;
	jmp findConfiguredClientWindowLoop;
	findConfiguredClientWindowLoop:{
		if(current < wall){
			if((*current).window == window){
				if(!(*current).inUse){
					ret NULL;
				}
				(*clientSystem).recentlyConfiguredClientOffset = current - (*clientSystem).clientStart;
				ret current;
			}
			inc current;
			jmp findConfiguredClientWindowLoop;
		}
		ret NULL;
	}
}
FINDORDEREDCLIENTOFFSET(){
	uint *current;
	uint *wall;
	Client *clientStart;
	if(!clientSystem or !isValidClient(clientSystem, client)){
		ret NULL;
	}
	current = (*clientSystem).orderedClientOffsetStart;
	wall = current + (*clientSystem).orderedClientOffsetAllocated;
	clientStart = (*clientSystem).clientStart;
	jmp findOrderedClientOffsetLoop;
	findOrderedClientOffsetLoop:{
		if(current < wall){
			if(clientStart + *current == client){
				ret current;
			}
			inc current;
			jmp findOrderedClientOffsetLoop;
		}
		ret NULL;
	}
}
FINDBELOWCLIENT(){
	uint *clientOffset;
	if(!clientSystem or !isValidClient(clientSystem, client)){
		ret NULL;
	}
	if(!(clientOffset = findOrderedClientOffset(clientSystem, client)) or clientOffset == (*clientSystem).orderedClientOffsetStart){
		ret NULL;
	}
	ret (*clientSystem).clientStart + *(clientOffset - 1);
}
FINDABOVEDESKTOPCLIENT(){
	uint *current;
	uint *wall;
	Client *clientStart;
	bool flag;
	if(!clientSystem or !(*clientSystem).orderedClientOffsetAllocated or !isValidClient(clientSystem, client) or (*client).desktop == NONE_DESKTOP){
		ret NULL;
	}
	current = (*clientSystem).orderedClientOffsetStart;
	wall = current + (*clientSystem).orderedClientOffsetAllocated;
	clientStart = (*clientSystem).clientStart;
	flag = false;
	jmp findAboveDesktopClientLoop;
	findAboveDesktopClientLoop:{
		if(current < wall){
			Client *const c = clientStart + *current;
			if(flag and (*c).desktop == (*client).desktop){
				ret c;
			}
			if(c == client){
				flag = true;
			}
			inc current;
			jmp findAboveDesktopClientLoop;
		}
		ret NULL;
	}
}
FINDBELOWDESKTOPCLIENT(){
	uint *start;
	uint *current;
	Client *clientStart;
	bool flag;
	if(!(*clientSystem).orderedClientOffsetAllocated or !isValidClient(clientSystem, client) or (*client).desktop == NONE_DESKTOP){
		ret NULL;
	}
	start = (*clientSystem).orderedClientOffsetStart;
	current = start + (*clientSystem).orderedClientOffsetAllocated - 1;
	clientStart = (*clientSystem).clientStart;
	flag = false;
	jmp findBelowDesktopClientLoop;
	findBelowDesktopClientLoop:{
		if(current >= start){
			Client *const c = clientStart + *current;
			if(flag and (*c).desktop == (*client).desktop){
				ret c;
			}
			if(c == client){
				flag = true;
			}
			dec current;
			jmp findBelowDesktopClientLoop;
		}
		ret NULL;
	}
}
FINDMODALTRANSIENTFORCLIENT(){
	Client *current;
	Client *wall;
	xcb_window_t window;
	if(!clientSystem or !isValidClient(clientSystem, client)){
		ret NULL;
	}
	current = (*clientSystem).clientStart;
	wall = current + (*clientSystem).clientAllocated;
	window = (*client).window;
	jmp findModalTransientForClientLoop;
	findModalTransientForClientLoop:{
		if(current < wall){
			if((*current).transientFor == window and (*current).state & MODAL_STATE){
				if(!(*current).inUse){
					ret NULL;
				}
				ret current;
			}
			inc current;
			jmp findModalTransientForClientLoop;
		}
		ret NULL;
	}
}
FINDBELOWMANAGEDCLIENT(){
	uint *start;
	uint *current;
	Client *clientStart;
	bool flag;
	if(!clientSystem or !(*clientSystem).orderedClientOffsetAllocated or !isValidClient(clientSystem, client) or (*client).option & OVERRIDE_REDIRECT_CLIENT_OPTION){
		ret NULL;
	}
	start = (*clientSystem).orderedClientOffsetStart;
	current = start + (*clientSystem).orderedClientOffsetAllocated - 1;
	clientStart = (*clientSystem).clientStart;
	flag = false;
	jmp findBelowManagedClientLoop;
	findBelowManagedClientLoop:{
		if(current >= start){
			Client *const c = clientStart + *current;
			if(flag and !((*c).option & OVERRIDE_REDIRECT_CLIENT_OPTION)){
				ret c;
			}
			if(c == client){
				flag = true;
			}
			dec current;
			jmp findBelowManagedClientLoop;
		}
		ret NULL;
	}
}
FINICLIENTSYSTEM(){
	if(!clientSystem){
		ret false;
	}
	if((*clientSystem).clientAllocated){
		Client *current = (*clientSystem).clientStart;
		Client *const wall = current + (*clientSystem).clientAllocated;
		jmp destroyClientLoop;
		destroyClientLoop:{
			if(current < wall){
				if((*current).inUse){
					xcb_discard_reply(connection, xcb_reparent_window_checked(connection, (*current).window, (*screen).root, 0, 0));
					free((*current).iconStart);
					popPointer((*current).iconToken);
					(*current).iconSize = 0;
					(*current).iconStart = NULL;
					(*current).iconToken = 0;
					free((*current).allowedActionStart);
					popPointer((*current).allowedActionToken);
					(*current).allowedActionSize = 0;
					(*current).allowedActionStart = NULL;
					(*current).allowedActionToken = 0;
					free((*current).stateStart);
					popPointer((*current).stateToken);
					(*current).stateSize = 0;
					(*current).stateStart = NULL;
					(*current).stateToken = 0;
					free((*current).windowTypeStart);
					popPointer((*current).windowTypeToken);
					(*current).windowTypeSize = 0;
					(*current).windowTypeStart = NULL;
					(*current).windowTypeToken = 0;
					free((*current).visibleIconNameStart);
					popPointer((*current).visibleIconNameToken);
					(*current).visibleIconNameSize = 0;
					(*current).visibleIconNameStart = NULL;
					(*current).visibleIconNameToken = 0;
					free((*current).visibleNameStart);
					popPointer((*current).visibleNameToken);
					(*current).visibleNameSize = 0;
					(*current).visibleNameStart = NULL;
					(*current).visibleNameToken = 0;
					free((*current).windowRoleStart);
					popPointer((*current).windowRoleToken);
					(*current).windowRoleSize = 0;
					(*current).windowRoleStart = NULL;
					(*current).windowRoleToken = 0;
					free((*current).clientIDStart);
					popPointer((*current).clientIDToken);
					(*current).clientIDSize = 0;
					(*current).clientIDStart = NULL;
					(*current).clientIDToken = 0;
					free((*current).clientMachineStart);
					popPointer((*current).clientMachineToken);
					(*current).clientMachineSize = 0;
					(*current).clientMachineStart = NULL;
					(*current).clientMachineToken = 0;
					free((*current).colormapWindowStart);
					popPointer((*current).colormapWindowToken);
					(*current).colormapWindowSize = 0;
					(*current).colormapWindowStart = NULL;
					(*current).colormapWindowToken = 0;
					free((*current).protocolStart);
					popPointer((*current).protocolToken);
					(*current).protocolSize = 0;
					(*current).protocolStart = NULL;
					(*current).protocolToken = 0;
					free((*current).classStart);
					popPointer((*current).classToken);
					(*current).classSize = 0;
					(*current).classStart = NULL;
					(*current).classToken = 0;
					free((*current).iconNameStart);
					popPointer((*current).iconNameToken);
					(*current).iconNameSize = 0;
					(*current).iconNameStart = NULL;
					(*current).iconNameToken = 0;
					free((*current).nameStart);
					popPointer((*current).nameToken);
					(*current).nameSize = 0;
					(*current).nameStart = NULL;
					(*current).nameToken = 0;
					if((*current).gc){
						xcb_free_gc(connection, (*current).gc);
						(*current).gc = XCB_NONE;
					}
					if((*current).pixmap){
						xcb_free_pixmap(connection, (*current).pixmap);
						(*current).pixmap = XCB_NONE;
					}
					if((*current).container){
						xcb_destroy_window(connection, (*current).container);
						(*current).container = XCB_NONE;
					}
				}
				inc current;
				jmp destroyClientLoop;
			}
		}
	}
	(*clientSystem).motionAction = NONE_MOTION_ACTION;
	(*clientSystem).recentlyConfiguredClientOffset = 0;
	(*clientSystem).motionClientOffset = 0;
	(*clientSystem).focusedClientOffset = 0;
	free((*clientSystem).orderedClientOffsetStart);
	popPointer((*clientSystem).orderedClientOffsetToken);
	(*clientSystem).orderedClientOffsetSize = 0;
	(*clientSystem).orderedClientOffsetAllocated = 0;
	(*clientSystem).orderedClientOffsetStart = NULL;
	(*clientSystem).orderedClientOffsetToken = 0;
	free((*clientSystem).clientStart);
	popPointer((*clientSystem).clientToken);
	(*clientSystem).clientSize = 0;
	(*clientSystem).clientAllocated = 0;
	(*clientSystem).clientNotInUseOffset = 0;
	(*clientSystem).clientStart = NULL;
	(*clientSystem).clientToken = 0;
	ret true;
}
INITVIRTUALROOTSYSTEM(){
	if(!virtualRootSystem){
		ret false;
	}
	(*virtualRootSystem).virtualRootSize = 0;
	(*virtualRootSystem).virtualRootAllocated = 0;
	(*virtualRootSystem).virtualRootStart = NULL;
	(*virtualRootSystem).virtualRootToken = 0;
	(*virtualRootSystem).workareaEdgeOffsetSize = 0;
	(*virtualRootSystem).workareaEdgeOffsetStart = NULL;
	(*virtualRootSystem).workareaEdgeOffsetToken = 0;
	(*virtualRootSystem).windowSize = 0;
	(*virtualRootSystem).windowStart = NULL;
	(*virtualRootSystem).windowToken = 0;
	(*virtualRootSystem).viewportSize = 0;
	(*virtualRootSystem).viewportStart = NULL;
	(*virtualRootSystem).viewportToken = 0;
	(*virtualRootSystem).desktopNamesSize = 0;
	(*virtualRootSystem).desktopNamesStart = NULL;
	(*virtualRootSystem).desktopNamesToken = 0;
	(*virtualRootSystem).workareaSize = 0;
	(*virtualRootSystem).workareaStart = NULL;
	(*virtualRootSystem).workareaToken = 0;
	(*virtualRootSystem).width = 1;
	(*virtualRootSystem).height = 1;
	(*virtualRootSystem).currentDesktop = NONE_DESKTOP;
	(*virtualRootSystem).showingDesktop = false;
	(*virtualRootSystem).desktopLayoutColumns = 0;
	(*virtualRootSystem).desktopLayoutRows = 0;
	(*virtualRootSystem).desktopLayoutOrientation = _NET_WM_ORIENTATION_HORZ;
	(*virtualRootSystem).desktopLayoutStartingCorner = _NET_WM_TOPLEFT;
	(*virtualRootSystem).mapped = false;
	ret true;
}
SETVIRTUALROOTAMOUNT(){
	int addedSize;
	if(!virtualRootSystem or !monitorSystem or !(*monitorSystem).size or !clientSystem or !size){
		ret false;
	}
	addedSize = (int)size - (int)(*virtualRootSystem).virtualRootAllocated;
	if(!addedSize){
		ret false;
	}
	if((*virtualRootSystem).virtualRootAllocated + addedSize >= (*virtualRootSystem).virtualRootSize){
		void *temp;
		(*virtualRootSystem).virtualRootSize += addedSize;
		temp = realloc((*virtualRootSystem).virtualRootStart, (*virtualRootSystem).virtualRootSize * sizeof(VirtualRoot));
		if(!(*virtualRootSystem).virtualRootToken){
			(*virtualRootSystem).virtualRootToken = pushPointer(temp, "virtual root pointer", iFree);
		}else{
			updatePointer((*virtualRootSystem).virtualRootToken, temp);
		}
		if(!temp){
			printTitledError("memory allocation error", "could not allocate memory for virtual roots");
			(*virtualRootSystem).virtualRootSize -= addedSize;
			ret false;
		}
		(*virtualRootSystem).virtualRootStart = temp;
	}
	if((*virtualRootSystem).virtualRootAllocated + addedSize >= (*virtualRootSystem).windowSize){
		void *temp;
		(*virtualRootSystem).windowSize += addedSize;
		temp = realloc((*virtualRootSystem).windowStart, (*virtualRootSystem).windowSize * sizeof(xcb_window_t));
		if(!(*virtualRootSystem).windowToken){
			(*virtualRootSystem).windowToken = pushPointer(temp, "virtual root window pointer", iFree);
		}else{
			updatePointer((*virtualRootSystem).windowToken, temp);
		}
		if(!temp){
			printTitledError("memory allocation error", "could not allocate memory for virtual root windows");
			(*virtualRootSystem).windowSize -= addedSize;
			ret false;
		}
		(*virtualRootSystem).windowStart = temp;
	}
	if((*virtualRootSystem).virtualRootAllocated + addedSize >= (*virtualRootSystem).viewportSize){
		void *temp;
		(*virtualRootSystem).viewportSize += addedSize;
		temp = realloc((*virtualRootSystem).viewportStart, (*virtualRootSystem).viewportSize * sizeof(Viewport));
		if(!(*virtualRootSystem).viewportToken){
			(*virtualRootSystem).viewportToken = pushPointer(temp, "virtual root viewport pointer", iFree);
		}else{
			updatePointer((*virtualRootSystem).viewportToken, temp);
		}
		if(!temp){
			printTitledError("memory allocation error", "could not allocate memory for virtual root viewports");
			(*virtualRootSystem).viewportSize -= addedSize;
			ret false;
		}
		(*virtualRootSystem).viewportStart = temp;
	}
	if((*virtualRootSystem).virtualRootAllocated + addedSize >= (*virtualRootSystem).workareaSize){
		void *temp;
		(*virtualRootSystem).workareaSize += addedSize;
		temp = realloc((*virtualRootSystem).workareaStart, (*virtualRootSystem).workareaSize * sizeof(Workarea));
		if(!(*virtualRootSystem).workareaToken){
			(*virtualRootSystem).workareaToken = pushPointer(temp, "virtual root workarea pointer", iFree);
		}else{
			updatePointer((*virtualRootSystem).workareaToken, temp);
		}
		if(!temp){
			printTitledError("memory allocation error", "could not allocate memory for virtual root workareas");
			(*virtualRootSystem).workareaSize -= addedSize;
			ret false;
		}
		(*virtualRootSystem).workareaStart = temp;
	}
	(*virtualRootSystem).virtualRootAllocated += addedSize;
	if(addedSize > 0){
		VirtualRoot *current = (*virtualRootSystem).virtualRootStart + (*virtualRootSystem).virtualRootAllocated - addedSize;
		VirtualRoot *const wall = (*virtualRootSystem).virtualRootStart + (*virtualRootSystem).virtualRootAllocated;
		xcb_window_t *windowCurrent = (*virtualRootSystem).windowStart + (*virtualRootSystem).virtualRootAllocated - addedSize;
		Viewport *viewportCurrent = (*virtualRootSystem).viewportStart + (*virtualRootSystem).virtualRootAllocated - addedSize;
		uint32 valueMask = XCB_CW_BACK_PIXEL | XCB_CW_BORDER_PIXEL | XCB_CW_EVENT_MASK | XCB_CW_COLORMAP;
		struct{
			uint32 /*---------*/ backgroundColor;
			uint32 /*---------*/ borderColor;
			uint32 /*---------*/ eventMask;
			xcb_colormap_t /*-*/ colormap;
			xcb_cursor_t /*---*/ cursor;
		} valueList;
		struct{
			uint32 /*---------*/ stackMode;
		} windowValueList;
		struct{
			uint32 /*---------*/ generateExpose;
		} gcValueList;
		valueList.backgroundColor = 0x00000000;
		valueList.borderColor = 0x00000000;
		valueList.eventMask = XCB_EVENT_MASK_NO_EVENT;
		valueList.colormap = (*screen).default_colormap;
		if(cursorSystem and (*cursorSystem).cursor){
			valueMask |= XCB_CW_CURSOR;
			valueList.cursor = (*cursorSystem).cursor;
		}
		windowValueList.stackMode = XCB_STACK_MODE_BELOW;
		gcValueList.generateExpose = false;
		jmp createVirtualRootLoop;
		createVirtualRootLoop:{
			if(current < wall){
				(*current).window = xcb_generate_id(connection);
				(*current).pixmap = xcb_generate_id(connection);
				(*current).gc = xcb_generate_id(connection);
				(*current).orderedClientOffsetSize = 0;
				(*current).orderedClientOffsetAllocated = 0;
				(*current).orderedClientOffsetStart = NULL;
				(*current).orderedClientOffsetToken = 0;
				(*current).nameSize = 0;
				(*current).nameStart = NULL;
				(*current).nameToken = 0;
				(*current).workareaEdgeOffsetSize = (*monitorSystem).size;
				(*current).workareaEdgeOffsetStart = malloc((*current).workareaEdgeOffsetSize * sizeof(EdgeOffset));
				(*current).workareaEdgeOffsetToken = pushPointer((*current).workareaEdgeOffsetStart, "virtual root monitor workarea pointer", iFree);
				if(!(*current).workareaEdgeOffsetStart){
					printTitledError("memory allocation error", "could not allocate memory for virtual root monitor workareas");
					(*current).workareaEdgeOffsetSize = 0;
				}else{
					EdgeOffset *edgeOffsetCurrent = (*current).workareaEdgeOffsetStart;
					EdgeOffset *const edgeOffsetWall = edgeOffsetCurrent + (*current).workareaEdgeOffsetSize;
					jmp setEdgeOffsetLoop;
					setEdgeOffsetLoop:{
						if(edgeOffsetCurrent < edgeOffsetWall){
							(*edgeOffsetCurrent).top = 0;
							(*edgeOffsetCurrent).bottom = 0;
							(*edgeOffsetCurrent).left = 0;
							(*edgeOffsetCurrent).right = 0;
							inc edgeOffsetCurrent;
							jmp setEdgeOffsetLoop;
						}
					}
				}
				*windowCurrent = (*current).window;
				(*viewportCurrent).x = 0;
				(*viewportCurrent).y = 0;
				xcb_create_window(connection, (*screen).root_depth, (*current).window, (*screen).root, 0, 0, (*virtualRootSystem).width, (*virtualRootSystem).height, 0, XCB_WINDOW_CLASS_INPUT_OUTPUT, (*screen).root_visual, valueMask, &valueList);
				xcb_configure_window(connection, (*current).window, XCB_CONFIG_WINDOW_STACK_MODE, &windowValueList);
				xcb_create_pixmap(connection, (*screen).root_depth, (*current).pixmap, (*screen).root, (*virtualRootSystem).width, (*virtualRootSystem).height);
				xcb_create_gc(connection, (*current).gc, (*current).pixmap, XCB_GC_GRAPHICS_EXPOSURES, &gcValueList);
				xcb_change_window_attributes(connection, (*current).window, XCB_CW_BACK_PIXMAP, &(*current).pixmap);
				fillDrawable((*current).pixmap, (*current).gc, 0, 0, (*virtualRootSystem).width, (*virtualRootSystem).height, 0x00000000);
				inc windowCurrent;
				inc viewportCurrent;
				inc current;
				jmp createVirtualRootLoop;
			}
			if(!(*virtualRootSystem).mapped){
				jmp emergencyExit;
			}
			current = (*virtualRootSystem).virtualRootStart + (*virtualRootSystem).virtualRootAllocated - addedSize;
			jmp mapVirtualRootLoop;
		}
		mapVirtualRootLoop:{
			if(current < wall){
				xcb_map_window(connection, (*current).window);
				inc current;
				jmp mapVirtualRootLoop;
			}
			jmp emergencyExit;
		}
	}
	if(addedSize < 0){
		const uint lastVirtualRoot = (*virtualRootSystem).virtualRootAllocated - 1;
		VirtualRoot *current = (*virtualRootSystem).virtualRootStart + (*virtualRootSystem).virtualRootAllocated;
		VirtualRoot *const wall = current - addedSize;
		if((*virtualRootSystem).currentDesktop != NONE_DESKTOP and (*virtualRootSystem).currentDesktop >= (*virtualRootSystem).virtualRootAllocated){
			gotoVirtualRoot(virtualRootSystem, clientSystem, lastVirtualRoot, true);
		}
		jmp destroyVirtualRootLoop;
		destroyVirtualRootLoop:{
			if(current < wall){
				if((*current).orderedClientOffsetStart){
					uint *clientCurrent = (*current).orderedClientOffsetStart;
					uint *const clientWall = clientCurrent + (*current).orderedClientOffsetAllocated;
					Client *const clientStart = (*clientSystem).clientStart;
					jmp changeClientVirtualRootLoop;
					changeClientVirtualRootLoop:{
						if(clientCurrent < clientWall){
							moveClientToVirtualRoot(virtualRootSystem, monitorSystem, clientSystem, clientStart + *clientCurrent, lastVirtualRoot, true);
							inc clientCurrent;
							jmp changeClientVirtualRootLoop;
						}
					}
				}
				destroyVirtualRoot(virtualRootSystem, current);
				inc current;
				jmp destroyVirtualRootLoop;
			}
			jmp emergencyExit;
		}
	}
	emergencyExit:{
		if((*virtualRootSystem).currentDesktop == NONE_DESKTOP){
			gotoVirtualRoot(virtualRootSystem, clientSystem, 0, true);
		}
		xcb_change_property(connection, XCB_PROP_MODE_REPLACE, (*screen).root, atom._NET_NUMBER_OF_DESKTOPS, XCB_ATOM_CARDINAL, bitsof(uint32), 1, &(*virtualRootSystem).virtualRootAllocated);
		xcb_change_property(connection, XCB_PROP_MODE_REPLACE, (*screen).root, atom._NET_DESKTOP_GEOMETRY, XCB_ATOM_CARDINAL, bitsof(uint32), 2, &(*virtualRootSystem).width);
		xcb_change_property(connection, XCB_PROP_MODE_REPLACE, (*screen).root, atom._NET_DESKTOP_VIEWPORT, XCB_ATOM_CARDINAL, bitsof(int32), (*virtualRootSystem).virtualRootAllocated * 2, (*virtualRootSystem).viewportStart);
		if(setVirtualRootNames(virtualRootSystem)){
			xcb_change_property(connection, XCB_PROP_MODE_REPLACE, (*screen).root, atom._NET_DESKTOP_NAMES, atom.UTF8_STRING, bitsof(uint8), (*virtualRootSystem).desktopNamesSize, (*virtualRootSystem).desktopNamesStart);
		}
		if(setVirtualRootWorkarea(virtualRootSystem, monitorSystem)){
			changeVirtualRootWorkarea(virtualRootSystem);
		}
		xcb_change_property(connection, XCB_PROP_MODE_REPLACE, (*screen).root, atom._NET_VIRTUAL_ROOTS, XCB_ATOM_WINDOW, bitsof(xcb_window_t), (*virtualRootSystem).virtualRootAllocated, (*virtualRootSystem).windowStart);
		ret true;
	}
}
SETVIRTUALROOTWORKAREA(){
	int virtualRootWidth;
	int virtualRootHeight;
	VirtualRoot *current;
	VirtualRoot *wall;
	int outerOffsetTop;
	int outerOffsetBottom;
	int outerOffsetLeft;
	int outerOffsetRight;
	Workarea *workareaCurrent;
	if(!virtualRootSystem or !(*virtualRootSystem).virtualRootAllocated or !monitorSystem or !(*monitorSystem).size){
		ret false;
	}
	virtualRootWidth = (*virtualRootSystem).width;
	virtualRootHeight = (*virtualRootSystem).height;
	jmp calculateOuterOffsets;
	calculateOuterOffsets:{
		outerOffsetTop = 0;
		outerOffsetBottom = 0;
		outerOffsetLeft = 0;
		outerOffsetRight = 0;
		if((*virtualRootSystem).workareaEdgeOffsetStart){
			const EdgeOffset *edgeCurrent = (*virtualRootSystem).workareaEdgeOffsetStart;
			const EdgeOffset *const edgeWall = edgeCurrent + (*virtualRootSystem).workareaEdgeOffsetSize;
			Monitor *monitorCurrent = (*monitorSystem).start;
			jmp calculateOuterOffsetsLoop;
			calculateOuterOffsetsLoop:{
				if(edgeCurrent < edgeWall){
					if(!(*monitorCurrent).leftX) /*-----------------------*/ outerOffsetLeft += (*edgeCurrent).left;
					if((*monitorCurrent).rightX == virtualRootWidth) /*---*/ outerOffsetRight += (*edgeCurrent).right;
					if(!(*monitorCurrent).topY) /*------------------------*/ outerOffsetTop += (*edgeCurrent).top;
					if((*monitorCurrent).bottomY == virtualRootHeight) /*-*/ outerOffsetBottom += (*edgeCurrent).bottom;
					inc monitorCurrent;
					inc edgeCurrent;
					jmp calculateOuterOffsetsLoop;
				}
			}
		}
		current = (*virtualRootSystem).virtualRootStart;
		wall = current + (*virtualRootSystem).virtualRootAllocated;
		workareaCurrent = (*virtualRootSystem).workareaStart;
		jmp setVirtualRootWorkareaLoop;
	}
	setVirtualRootWorkareaLoop:{
		if(current < wall){
			int innerOffsetTop = 0;
			int innerOffsetBottom = 0;
			int innerOffsetLeft = 0;
			int innerOffsetRight = 0;
			int width;
			int height;
			if((*current).workareaEdgeOffsetStart){
				const EdgeOffset *edgeCurrent = (*current).workareaEdgeOffsetStart;
				const EdgeOffset *const edgeWall = edgeCurrent + (*current).workareaEdgeOffsetSize;
				Monitor *monitorCurrent = (*monitorSystem).start;
				jmp calculateInnerOffsetsLoop;
				calculateInnerOffsetsLoop:{
					if(edgeCurrent < edgeWall){
						if(!(*monitorCurrent).leftX) /*-----------------------*/ innerOffsetLeft += (*edgeCurrent).left;
						if((*monitorCurrent).rightX == virtualRootWidth) /*---*/ innerOffsetRight += (*edgeCurrent).right;
						if(!(*monitorCurrent).topY) /*------------------------*/ innerOffsetTop += (*edgeCurrent).top;
						if((*monitorCurrent).bottomY == virtualRootHeight) /*-*/ innerOffsetBottom += (*edgeCurrent).bottom;
						inc monitorCurrent;
						inc edgeCurrent;
						jmp calculateInnerOffsetsLoop;
					}
				}
			}
			width = virtualRootWidth - outerOffsetLeft - innerOffsetLeft - outerOffsetRight - innerOffsetRight;
			height = virtualRootHeight - outerOffsetTop - innerOffsetTop - outerOffsetBottom - innerOffsetBottom;
			if(width < 0){
				width = 0;
			}
			if(height < 0){
				height = 0;
			}
			(*workareaCurrent).x = outerOffsetLeft + innerOffsetLeft;
			(*workareaCurrent).y = outerOffsetTop + innerOffsetTop;
			(*workareaCurrent).width = width;
			(*workareaCurrent).height = height;
			inc workareaCurrent;
			inc current;
			jmp setVirtualRootWorkareaLoop;
		}
		ret true;
	}
}
CHANGEVIRTUALROOTWORKAREA(){
	if(!virtualRootSystem or !(*virtualRootSystem).virtualRootAllocated){
		ret false;
	}
	xcb_change_property(connection, XCB_PROP_MODE_REPLACE, (*screen).root, atom._NET_WORKAREA, XCB_ATOM_CARDINAL, bitsof(uint32), (*virtualRootSystem).virtualRootAllocated * 4, (*virtualRootSystem).workareaStart);
	ret true;
}
SETVIRTUALROOTNAMES(){
	VirtualRoot *start;
	VirtualRoot *current;
	VirtualRoot *wall;
	uint8 *desktopNamesCurrent;
	if(!virtualRootSystem or !(*virtualRootSystem).virtualRootAllocated){
		ret false;
	}
	start = (*virtualRootSystem).virtualRootStart;
	current = start;
	wall = current + (*virtualRootSystem).virtualRootAllocated;
	(*virtualRootSystem).desktopNamesSize = 0;
	desktopNamesCurrent = (*virtualRootSystem).desktopNamesStart;
	jmp appendDesktopNameLoop;
	appendDesktopNameLoop:{
		if(current < wall){
			if(!(*current).nameStart){
				const uint32 which = current - start;
				setVirtualRootNumberName(virtualRootSystem, which, which + 1);
			}
			if((*current).nameStart){
				const uint offset = desktopNamesCurrent - (*virtualRootSystem).desktopNamesStart;
				uint size = (*virtualRootSystem).desktopNamesSize + (*current).nameSize;
				void *const temp = realloc((*virtualRootSystem).desktopNamesStart, size * sizeof(uint8));
				if(!(*virtualRootSystem).desktopNamesToken){
					(*virtualRootSystem).desktopNamesToken = pushPointer(temp, "virtual root desktop name pointer", iFree);
				}else{
					updatePointer((*virtualRootSystem).desktopNamesToken, temp);
				}
				if(!temp){
					printTitledError("memory allocation error", "could not allocate memory for virtual root desktop names");
					ret false;
				}
				(*virtualRootSystem).desktopNamesStart = temp;
				(*virtualRootSystem).desktopNamesSize = size;
				desktopNamesCurrent = (*virtualRootSystem).desktopNamesStart + offset;
				copyMemory((*current).nameStart, desktopNamesCurrent, (*current).nameSize);
				desktopNamesCurrent += (*current).nameSize;
			}
			inc current;
			jmp appendDesktopNameLoop;
		}
		ret true;
	}
}
SETVIRTUALROOTNAME(){
	void *nameStart;
	uint32 nameToken;
	VirtualRoot *virtualRoot;
	if(!virtualRootSystem or which >= (*virtualRootSystem).virtualRootAllocated){
		ret false;
	}
	nameStart = malloc((length + 1) * sizeof(uint8));
	nameToken = pushPointer(nameStart, "virtual root name pointer", iFree);
	if(!nameStart){
		printTitledError("memory allocation error", "could not allocate memory for virtual root desktop name");
		ret false;
	}
	copyMemory(name, nameStart, length * sizeof(uint8));
	*((uint8 *)nameStart + length) = '\0';
	virtualRoot = (*virtualRootSystem).virtualRootStart + which;
	free((*virtualRoot).nameStart);
	popPointer((*virtualRoot).nameToken);
	(*virtualRoot).nameSize = length + 1;
	(*virtualRoot).nameStart = nameStart;
	(*virtualRoot).nameToken = nameToken;
	ret true;
}
SETVIRTUALROOTNUMBERNAME(){
	uint length;
	void *nameStart;
	uint32 nameToken;
	if(!virtualRootSystem or which >= (*virtualRootSystem).virtualRootAllocated){
		ret false;
	}
	jmp getNumberLength;
	getNumberLength:{
		uint n = number;
		length = 0;
		jmp getNumberLengthLoop;
		getNumberLengthLoop:{
			if(n){
				n /= 10;
				inc length;
				jmp getNumberLengthLoop;
			}
		}
		if(!length){
			length = 1;
		}
		jmp allocateName;
	}
	allocateName:{
		nameStart = malloc((length + 1) * sizeof(uint8));
		nameToken = pushPointer(nameStart, "virtual root name pointer", iFree);
		if(!nameStart){
			printTitledError("memory allocation error", "could not allocate memory for virtual root desktop number name");
			ret false;
		}
		jmp storeNumber;
	}
	storeNumber:{
		uint8 *nameCurrent = (uint8 *)nameStart + length;
		*nameCurrent = '\0';
		dec nameCurrent;
		jmp storeNumberLoop;
		storeNumberLoop:{
			if(number){
				*nameCurrent = number % 10 + 48;
				dec nameCurrent;
				number /= 10;
				jmp storeNumberLoop;
			}
			jmp storeName;
		}
	}
	storeName:{
		VirtualRoot *const virtualRoot = (*virtualRootSystem).virtualRootStart + which;
		free((*virtualRoot).nameStart);
		popPointer((*virtualRoot).nameToken);
		(*virtualRoot).nameSize = length + 1;
		(*virtualRoot).nameStart = nameStart;
		(*virtualRoot).nameToken = nameToken;
		ret true;
	}
}
GOTOVIRTUALROOT(){
	if(!virtualRootSystem or !clientSystem or which >= (*virtualRootSystem).virtualRootAllocated or which == NONE_DESKTOP or which == (*virtualRootSystem).currentDesktop){
		ret false;
	}
	if(loseClientFocus){
		loseFocus(clientSystem);
	}
	if((*virtualRootSystem).currentDesktop == NONE_DESKTOP){
		(*virtualRootSystem).currentDesktop = 0;
	}
	configureFullscreenVirtualRootClients(virtualRootSystem, clientSystem, which);
	if((*virtualRootSystem).virtualRootAllocated > 1 and which != (*virtualRootSystem).currentDesktop){
		struct{
			xcb_window_t /*-*/ sibling;
			uint32 /*-------*/ stackMode;
		} valueList;
		valueList.sibling = (*((*virtualRootSystem).virtualRootStart + (*virtualRootSystem).currentDesktop)).window;
		valueList.stackMode = XCB_STACK_MODE_ABOVE;
		xcb_configure_window(connection, (*((*virtualRootSystem).virtualRootStart + which)).window, XCB_CONFIG_WINDOW_SIBLING | XCB_CONFIG_WINDOW_STACK_MODE, &valueList);
	}
	showVirtualRootDesktop(virtualRootSystem, clientSystem, (*virtualRootSystem).currentDesktop, false);
	(*virtualRootSystem).currentDesktop = which;
	xcb_change_property(connection, XCB_PROP_MODE_REPLACE, (*screen).root, atom._NET_CURRENT_DESKTOP, XCB_ATOM_CARDINAL, bitsof(uint32), 1, &(*virtualRootSystem).currentDesktop);
	ret true;
}
CONFIGUREFULLSCREENVIRTUALROOTCLIENTS(){
	uint *start;
	uint *current;
	uint *wall;
	Client *clientStart;
	struct{
		xcb_window_t /*-*/ sibling;
		uint32 /*-------*/ stackMode;
	} valueList;
	if(!virtualRootSystem or (*virtualRootSystem).currentDesktop == NONE_DESKTOP or !clientSystem or !(*clientSystem).orderedClientOffsetStart or which >= (*virtualRootSystem).virtualRootAllocated or which == NONE_DESKTOP){
		ret false;
	}
	start = (*clientSystem).orderedClientOffsetStart;
	wall = start + (*clientSystem).orderedClientOffsetAllocated;
	current = wall - 1;
	clientStart = (*clientSystem).clientStart;
	valueList.sibling = (*((*virtualRootSystem).virtualRootStart + (*virtualRootSystem).currentDesktop)).window;
	valueList.stackMode = XCB_STACK_MODE_ABOVE;
	jmp findTopOwnedWindowLoop;
	findTopOwnedWindowLoop:{
		if(current >= start){
			Client *const client = clientStart + *current;
			if(!((*client).option & OVERRIDE_REDIRECT_CLIENT_OPTION) and ((*client).desktop == 0xFFFFFFFF or ((*client).state & FULLSCREEN_STATE and (*client).desktop == (*virtualRootSystem).currentDesktop))){
				valueList.sibling = (*client).container;
			}else{
				dec current;
				jmp findTopOwnedWindowLoop;
			}
		}
		current = wall - 1;
		jmp configureFullscreenClientAboveLoop;
	}
	configureFullscreenClientAboveLoop:{
		if(current >= start){
			Client *const client = clientStart + *current;
			if((*client).state & FULLSCREEN_STATE and (*client).desktop == which){
				xcb_window_t window = (*client).container;
				if(!window){
					window = (*client).window;
				}
				xcb_discard_reply(connection, xcb_configure_window_checked(connection, window, XCB_CONFIG_WINDOW_SIBLING | XCB_CONFIG_WINDOW_STACK_MODE, &valueList));
			}
			dec current;
			jmp configureFullscreenClientAboveLoop;
		}
		current = start;
		jmp configureFullscreenClientBelowLoop;
	}
	configureFullscreenClientBelowLoop:{
		if(current < wall){
			Client *const client = clientStart + *current;
			if((*client).state & FULLSCREEN_STATE and (*client).desktop == (*virtualRootSystem).currentDesktop){
				xcb_window_t window = (*client).container;
				struct{
					uint32 /*-*/ stackMode;
				} valueList;
				if(!window){
					window = (*client).window;
				}
				valueList.stackMode = XCB_STACK_MODE_BELOW;
				xcb_discard_reply(connection, xcb_configure_window_checked(connection, window, XCB_CONFIG_WINDOW_STACK_MODE, &valueList));
			}
			inc current;
			jmp configureFullscreenClientBelowLoop;
		}
		ret true;
	}
}
RESIZEVIRTUALROOT(){
	VirtualRoot *current;
	VirtualRoot *wall;
	struct{
		uint32 /*-*/ width;
		uint32 /*-*/ height;
	} windowValueList;
	struct{
		uint32 /*-*/ generateExpose;
	} gcValueList;
	if(!virtualRootSystem or !monitorSystem or !(*monitorSystem).size or !wallpaperSystem or !(*wallpaperSystem).pixmap or !clientSystem or !width or !height){
		ret false;
	}
	(*virtualRootSystem).width = width;
	(*virtualRootSystem).height = height;
	if((*virtualRootSystem).workareaEdgeOffsetSize != (*monitorSystem).size){



		/*! add support for normal windows. */



		Client *current = (*clientSystem).clientStart;
		Client *const wall = current + (*clientSystem).clientAllocated;
		jmp removeVirtualRootClientWorkareaLoop;
		removeVirtualRootClientWorkareaLoop:{
			if(current < wall){
				if((*current).inUse){
					removeVirtualRootClientWorkarea(virtualRootSystem, monitorSystem, clientSystem, current);
				}
				inc current;
				jmp removeVirtualRootClientWorkareaLoop;
			}
			setVirtualRootGlobalEdgeOffset(virtualRootSystem, monitorSystem);
			current = (*clientSystem).clientStart;
			jmp addVirtualRootClientWorkareaLoop;
		}
		addVirtualRootClientWorkareaLoop:{
			if(current < wall){
				if((*current).inUse){
					if(addVirtualRootClientWorkarea(virtualRootSystem, monitorSystem, clientSystem, current)){
						updateVirtualRootStrutedClients(virtualRootSystem, monitorSystem, clientSystem, current, ADD_UPDATE_WORKAREA_ACTION);
					}
				}
				inc current;
				jmp addVirtualRootClientWorkareaLoop;
			}
			updateVirtualRootWorkareaClients(virtualRootSystem, monitorSystem, clientSystem);
		}
	}
	current = (*virtualRootSystem).virtualRootStart;
	wall = current + (*virtualRootSystem).virtualRootAllocated;
	windowValueList.width = (*virtualRootSystem).width;
	windowValueList.height = (*virtualRootSystem).height;
	gcValueList.generateExpose = false;
	jmp configureVirtualRootLoop;
	configureVirtualRootLoop:{
		if(current < wall){
			if((*current).gc){
				xcb_free_gc(connection, (*current).gc);
			}
			if((*current).pixmap){
				xcb_free_pixmap(connection, (*current).pixmap);
			}
			(*current).pixmap = xcb_generate_id(connection);
			(*current).gc = xcb_generate_id(connection);
			xcb_configure_window(connection, (*current).window, XCB_CONFIG_WINDOW_WIDTH | XCB_CONFIG_WINDOW_HEIGHT, &windowValueList);
			xcb_create_pixmap(connection, (*screen).root_depth, (*current).pixmap, (*screen).root, (*virtualRootSystem).width, (*virtualRootSystem).height);
			xcb_create_gc(connection, (*current).gc, (*current).pixmap, XCB_GC_GRAPHICS_EXPOSURES, &gcValueList);
			xcb_change_window_attributes(connection, (*current).window, XCB_CW_BACK_PIXMAP, &(*current).pixmap);
			inc current;
			jmp configureVirtualRootLoop;
		}
		jmp applyProperties;
	}
	applyProperties:{
		xcb_change_property(connection, XCB_PROP_MODE_REPLACE, (*screen).root, atom._NET_DESKTOP_GEOMETRY, XCB_ATOM_CARDINAL, bitsof(uint32), 2, &(*virtualRootSystem).width);
		if(setVirtualRootWorkarea(virtualRootSystem, monitorSystem)){
			changeVirtualRootWorkarea(virtualRootSystem);
		}
		ret true;
	}
}
SETVIRTUALROOTGLOBALEDGEOFFSET(){
	uint32 size;
	EdgeOffset *start;
	uint32 token;
	EdgeOffset *current;
	EdgeOffset *wall;
	if(!virtualRootSystem or !monitorSystem or !(*monitorSystem).size){
		ret false;
	}
	size = (*monitorSystem).size;
	start = malloc(size * sizeof(EdgeOffset));
	token = pushPointer(start, "virtual root monitor workarea pointer", iFree);
	if(start){
		free((*virtualRootSystem).workareaEdgeOffsetStart);
		popPointer((*virtualRootSystem).workareaEdgeOffsetToken);
		(*virtualRootSystem).workareaEdgeOffsetSize = size;
		(*virtualRootSystem).workareaEdgeOffsetStart = start;
		(*virtualRootSystem).workareaEdgeOffsetToken = token;
	}
	current = (*virtualRootSystem).workareaEdgeOffsetStart;
	wall = current + (*virtualRootSystem).workareaEdgeOffsetSize;
	jmp setOuterEdgeOffsetLoop;
	setOuterEdgeOffsetLoop:{
		if(current < wall){
			(*current).top = 0;
			(*current).bottom = 0;
			(*current).left = 0;
			(*current).right = 0;
			inc current;
			jmp setOuterEdgeOffsetLoop;
		}
		jmp setInnerEdgeOffset;
	}
	setInnerEdgeOffset:{
		VirtualRoot *virtualRootCurrent = (*virtualRootSystem).virtualRootStart;
		VirtualRoot *const virtualRootWall = virtualRootCurrent + (*virtualRootSystem).virtualRootAllocated;
		jmp setInnerEdgeOffsetLoop0;
		setInnerEdgeOffsetLoop0:{
			if(virtualRootCurrent < virtualRootWall){
				size = (*monitorSystem).size;
				start = malloc(size * sizeof(EdgeOffset));
				token = pushPointer(start, "virtual root monitor workarea pointer", iFree);
				if(start){
					free((*virtualRootCurrent).workareaEdgeOffsetStart);
					popPointer((*virtualRootCurrent).workareaEdgeOffsetToken);
					(*virtualRootCurrent).workareaEdgeOffsetSize = size;
					(*virtualRootCurrent).workareaEdgeOffsetStart = start;
					(*virtualRootCurrent).workareaEdgeOffsetToken = token;
				}
				current = (*virtualRootCurrent).workareaEdgeOffsetStart;
				wall = current + (*virtualRootCurrent).workareaEdgeOffsetSize;
				jmp setInnerEdgeOffsetLoop1;
				setInnerEdgeOffsetLoop1:{
					if(current < wall){
						(*current).top = 0;
						(*current).bottom = 0;
						(*current).left = 0;
						(*current).right = 0;
						inc current;
						jmp setInnerEdgeOffsetLoop1;
					}
					inc virtualRootCurrent;
					jmp setInnerEdgeOffsetLoop0;
				}
			}
			ret true;
		}
	}
}
SETVIRTUALROOTWALLPAPER(){
	VirtualRoot *current;
	VirtualRoot *wall;
	if(!virtualRootSystem or !(*virtualRootSystem).virtualRootAllocated or !wallpaperSystem){
		ret false;
	}
	current = (*virtualRootSystem).virtualRootStart;
	wall = current + (*virtualRootSystem).virtualRootAllocated;
	jmp applyWallpaperLoop;
	applyWallpaperLoop:{
		if(current < wall){
			fillDrawable((*current).pixmap, (*current).gc, 0, 0, (*virtualRootSystem).width, (*virtualRootSystem).height, (*wallpaperSystem).color);
			if((*wallpaperSystem).pixmap){
				xcb_copy_area(connection, (*wallpaperSystem).pixmap, (*current).pixmap, (*current).gc, 0, 0, 0, 0, (*wallpaperSystem).width, (*wallpaperSystem).height);
			}
			inc current;
			jmp applyWallpaperLoop;
		}
		if(!(*virtualRootSystem).mapped){
			ret true;
		}
		current = (*virtualRootSystem).virtualRootStart;
		jmp clearAreaLoop;
	}
	clearAreaLoop:{
		if(current < wall){
			xcb_clear_area(connection, false, (*current).window, 0, 0, 0, 0);
			inc current;
			jmp clearAreaLoop;
		}
		ret true;
	}
}
RESTACKVIRTUALROOTBELOW(){
	VirtualRoot *start;
	VirtualRoot *current;
	VirtualRoot *wall;
	uint currentDesktop;
	struct{
		uint32 /*-*/ stackMode;
	} valueList;
	if(!virtualRootSystem or !(*virtualRootSystem).virtualRootAllocated or (*virtualRootSystem).currentDesktop == NONE_DESKTOP){
		ret false;
	}
	start = (*virtualRootSystem).virtualRootStart;
	current = start;
	wall = current + (*virtualRootSystem).virtualRootAllocated;
	valueList.stackMode = XCB_STACK_MODE_BELOW;
	currentDesktop = (*virtualRootSystem).currentDesktop;
	jmp restackVirtualRootBelowLoop;
	restackVirtualRootBelowLoop:{
		if(current < wall){
			if(current - start != currentDesktop){
				xcb_configure_window(connection, (*current).window, XCB_CONFIG_WINDOW_STACK_MODE, &valueList);
			}
			inc current;
			jmp restackVirtualRootBelowLoop;
		}
		jmp restackCurrentVirtualRootAbove;
	}
	restackCurrentVirtualRootAbove:{
		if((*virtualRootSystem).virtualRootAllocated == 1){
			xcb_configure_window(connection, (*current).window, XCB_CONFIG_WINDOW_STACK_MODE, &valueList);
		}else{
			struct{
				xcb_window_t /*-*/ sibling;
				uint32 /*-------*/ stackMode;
			} valueList;
			valueList.sibling = (*start).window;
			valueList.stackMode = XCB_STACK_MODE_ABOVE;
			xcb_configure_window(connection, (*current).window, XCB_CONFIG_WINDOW_SIBLING | XCB_CONFIG_WINDOW_STACK_MODE, &valueList);
		}
		ret true;
	}
}
MAPVIRTUALROOTS(){
	VirtualRoot *current;
	VirtualRoot *wall;
	if(!virtualRootSystem or !(*virtualRootSystem).virtualRootAllocated){
		ret false;
	}
	current = (*virtualRootSystem).virtualRootStart;
	wall = current + (*virtualRootSystem).virtualRootAllocated;
	jmp mapWindowLoop;
	mapWindowLoop:{
		if(current < wall){
			xcb_map_window(connection, (*current).window);
			inc current;
			jmp mapWindowLoop;
		}
		(*virtualRootSystem).mapped = true;
		ret true;
	}
}
SETCLIENTVIRTUALROOT(){
	uint *clientOffset;
	VirtualRoot *oldVirtualRoot;
	VirtualRoot *newVirtualRoot;
	xcb_window_t newParent;
	if(!virtualRootSystem or !(*virtualRootSystem).virtualRootAllocated or !clientSystem or !isValidClient(clientSystem, client) or (*client).option & OVERRIDE_REDIRECT_CLIENT_OPTION or ((*client).stateState != WITHDRAWN_STATE and !((*client).allowedAction & CHANGE_DESKTOP_ALLOWED_ACTION)) or (which != NONE_DESKTOP and which != 0xFFFFFFFF and which >= (*virtualRootSystem).virtualRootAllocated) or which == (*client).desktop){
		ret false;
	}
	oldVirtualRoot = NULL;
	newVirtualRoot = NULL;
	newParent = XCB_NONE;
	if((*client).desktop == NONE_DESKTOP or (*client).desktop == 0xFFFFFFFF){
		if(which != NONE_DESKTOP and which != 0xFFFFFFFF){
			newVirtualRoot = (*virtualRootSystem).virtualRootStart + which;
			newParent = (*newVirtualRoot).window;
		}
	}elif(which == NONE_DESKTOP or which == 0xFFFFFFFF){
		oldVirtualRoot = (*virtualRootSystem).virtualRootStart + (*client).desktop;
		newParent = (*screen).root;
	}else{
		oldVirtualRoot = (*virtualRootSystem).virtualRootStart + (*client).desktop;
		newVirtualRoot = (*virtualRootSystem).virtualRootStart + which;
		newParent = (*newVirtualRoot).window;
	}
	if(oldVirtualRoot){
		if(!(clientOffset = findOrderedVirtualRootClientOffset(virtualRootSystem, oldVirtualRoot, clientSystem, (*client).window))){
			ret false;
		}
	}
	if(newVirtualRoot){
		if((*newVirtualRoot).orderedClientOffsetAllocated == (*newVirtualRoot).orderedClientOffsetSize){
			void *temp;
			(*newVirtualRoot).orderedClientOffsetSize += CLIENT_BLOCK_SIZE;
			temp = realloc((*newVirtualRoot).orderedClientOffsetStart, (*newVirtualRoot).orderedClientOffsetSize * sizeof(uint));
			if(!(*newVirtualRoot).orderedClientOffsetToken){
				(*newVirtualRoot).orderedClientOffsetToken = pushPointer(temp, "virtual root ordered client offset pointer", iFree);
			}else{
				updatePointer((*newVirtualRoot).orderedClientOffsetToken, temp);
			}
			if(!temp){
				printTitledError("memory allocation error", "could not allocate memory for virtual root ordered client offsets");
				(*newVirtualRoot).orderedClientOffsetSize -= CLIENT_BLOCK_SIZE;
				ret false;
			}
			(*newVirtualRoot).orderedClientOffsetStart = temp;
		}
	}
	if(oldVirtualRoot){
		shiftMemory(clientOffset + 1, ((*oldVirtualRoot).orderedClientOffsetStart + (*oldVirtualRoot).orderedClientOffsetAllocated - clientOffset - 1) * sizeof(uint), -(int)sizeof(uint));
		dec (*oldVirtualRoot).orderedClientOffsetAllocated;
	}
	if(newParent and !((*client).state & FULLSCREEN_STATE)){
		xcb_reparent_window(connection, (*client).container, newParent, (*client).containerX, (*client).containerY);
	}
	(*client).desktop = which;
	if(newVirtualRoot){
		*((*newVirtualRoot).orderedClientOffsetStart + (*newVirtualRoot).orderedClientOffsetAllocated) = client - (*clientSystem).clientStart;
		inc (*newVirtualRoot).orderedClientOffsetAllocated;
	}
	ret true;
}
CHANGEVIRTUALROOTCLIENTDESKTOP(){
	if(!virtualRootSystem or !clientSystem or !isValidClient(clientSystem, client)){
		ret false;
	}
	if((*client).desktop == NONE_DESKTOP){
		xcb_discard_reply(connection, xcb_delete_property_checked(connection, (*client).window, atom._NET_WM_DESKTOP));
	}else{
		xcb_discard_reply(connection, xcb_change_property_checked(connection, XCB_PROP_MODE_REPLACE, (*client).window, atom._NET_WM_DESKTOP, XCB_ATOM_CARDINAL, bitsof(uint32), 1, &(*client).desktop));
	}
	ret true;
}
MOVECLIENTTOVIRTUALROOT(){
	if(!virtualRootSystem or !(*virtualRootSystem).virtualRootAllocated or !monitorSystem or !(*monitorSystem).size or !clientSystem or !isValidClient(clientSystem, client) or (*client).option & OVERRIDE_REDIRECT_CLIENT_OPTION or ((*client).stateState != WITHDRAWN_STATE and !((*client).allowedAction & CHANGE_DESKTOP_ALLOWED_ACTION)) or (which != NONE_DESKTOP and which != 0xFFFFFFFF and which >= (*virtualRootSystem).virtualRootAllocated) or which == (*client).desktop){
		ret false;
	}
	if(loseClientFocus and client == getFocusedClient(clientSystem)){
		loseFocus(clientSystem);
	}
	if(removeVirtualRootClientWorkarea(virtualRootSystem, monitorSystem, clientSystem, client)){
		updateVirtualRootStrutedClients(virtualRootSystem, monitorSystem, clientSystem, client, REMOVE_UPDATE_WORKAREA_ACTION);
		updateVirtualRootWorkareaClients(virtualRootSystem, monitorSystem, clientSystem);
	}
	if(setClientVirtualRoot(virtualRootSystem, clientSystem, client, which)){
		configureVirtualRootClient(virtualRootSystem, clientSystem, client);
		if((*client).strut){
			updateVirtualRootWorkareaClients(virtualRootSystem, monitorSystem, clientSystem);
		}else{
			updateVirtualRootWorkareaClient(virtualRootSystem, monitorSystem, clientSystem, client);
		}
		changeVirtualRootClientDesktop(virtualRootSystem, clientSystem, client);
	}
	if(addVirtualRootClientWorkarea(virtualRootSystem, monitorSystem, clientSystem, client)){
		updateVirtualRootStrutedClients(virtualRootSystem, monitorSystem, clientSystem, client, ADD_UPDATE_WORKAREA_ACTION);
		updateVirtualRootWorkareaClients(virtualRootSystem, monitorSystem, clientSystem);
	}
	if((*client).strut){
		if(setVirtualRootWorkarea(virtualRootSystem, monitorSystem)){
			changeVirtualRootWorkarea(virtualRootSystem);
		}
	}
	ret true;
}
CONFIGUREVIRTUALROOTCLIENT(){
	Client *siblingClient;
	uint8 stackMode;
	xcb_window_t sibling;
	uint32 valueMask;
	uint32 valueList[2];
	if(!virtualRootSystem or !clientSystem or !isValidClient(clientSystem, client) or (*client).desktop == NONE_DESKTOP or (*client).desktop == 0xFFFFFFFF or (*client).state & FULLSCREEN_STATE){
		ret false;
	}
	if((siblingClient = findBelowDesktopClient(clientSystem, client))){
		stackMode = XCB_STACK_MODE_ABOVE;
		sibling = (*siblingClient).window;
		valueMask = XCB_CONFIG_WINDOW_SIBLING | XCB_CONFIG_WINDOW_STACK_MODE;
		*(valueList + 0) = (*siblingClient).container;
		*(valueList + 1) = XCB_STACK_MODE_ABOVE;
	}else{
		stackMode = XCB_STACK_MODE_BELOW;
		sibling = XCB_NONE;
		valueMask = XCB_CONFIG_WINDOW_STACK_MODE;
		*(valueList + 0) = XCB_STACK_MODE_BELOW;
	}
	if(!restackVirtualRootClient(virtualRootSystem, clientSystem, client, stackMode, sibling)){
		ret false;
	}
	xcb_configure_window(connection, (*client).container, valueMask, valueList);
	ret true;
}
RESTACKVIRTUALROOTCLIENT(){
	VirtualRoot *virtualRoot;
	uint *start;
	uint *current;
	uint *wall;
	uint copy;
	if(!virtualRootSystem or !(*virtualRootSystem).virtualRootAllocated or !clientSystem or !isValidClient(clientSystem, client) or (*client).desktop == NONE_DESKTOP or (*client).desktop == 0xFFFFFFFF){
		ret false;
	}
	virtualRoot = (*virtualRootSystem).virtualRootStart + (*client).desktop;
	if(!(*virtualRoot).orderedClientOffsetStart){
		ret false;
	}
	start = (*virtualRoot).orderedClientOffsetStart;
	wall = start + (*virtualRoot).orderedClientOffsetAllocated;
	switch(stackMode){
		to XCB_STACK_MODE_ABOVE: /*-*/ jmp stackModeAbove;
		to XCB_STACK_MODE_BELOW: /*-*/ jmp stackModeBelow;
		off: /*---------------------*/ ret false;
	}
	stackModeAbove:{
		uint *siblingClient = wall - 1;
		if(sibling and !(siblingClient = findOrderedVirtualRootClientOffset(virtualRootSystem, virtualRoot, clientSystem, sibling))){
			ret false;
		}
		if(!(current = findOrderedVirtualRootClientOffset(virtualRootSystem, virtualRoot, clientSystem, (*client).window)) or current == siblingClient or current == siblingClient + 1){
			ret false;
		}
		copy = *current;
		if(current < siblingClient){
			shiftMemory(current + 1, (siblingClient - current) * sizeof(uint), -(int)sizeof(uint));
			*siblingClient = copy;
			ret true;
		}
		shiftMemory(siblingClient + 1, (current - siblingClient - 1) * sizeof(uint), sizeof(uint));
		*(siblingClient + 1) = copy;
		ret true;
	}
	stackModeBelow:{
		uint *siblingClient = start;
		if(sibling and !(siblingClient = findOrderedVirtualRootClientOffset(virtualRootSystem, virtualRoot, clientSystem, sibling))){
			ret false;
		}
		if(!(current = findOrderedVirtualRootClientOffset(virtualRootSystem, virtualRoot, clientSystem, (*client).window)) or current == siblingClient or current == siblingClient - 1){
			ret false;
		}
		copy = *current;
		if(current < siblingClient){
			shiftMemory(current + 1, (siblingClient - current - 1) * sizeof(uint), -(int)sizeof(uint));
			*(siblingClient - 1) = copy;
			ret true;
		}
		shiftMemory(siblingClient, (current - siblingClient) * sizeof(uint), sizeof(uint));
		*siblingClient = copy;
		ret true;
	}
}
ADDVIRTUALROOTCLIENTWORKAREA(){
	uint monitorOffset;
	if(!virtualRootSystem or !(*virtualRootSystem).virtualRootAllocated or !monitorSystem or !(*monitorSystem).size or (*monitorSystem).size != (*virtualRootSystem).workareaEdgeOffsetSize or !clientSystem or !isValidClient(clientSystem, client) or (*client).stateState != NORMAL_STATE or !(*client).strut){
		ret false;
	}
	jmp findMonitorOffset;
	findMonitorOffset:{
		Monitor *monitor;
		if(!(monitor = findRectangleMonitor(monitorSystem, (*client).strutX, (*client).strutY, (*client).strutWidth, (*client).strutHeight))){
			ret false;
		}
		monitorOffset = monitor - (*monitorSystem).start;
		jmp calculateWorkarea;
	}
	calculateWorkarea:{
		EdgeOffset *edgeOffset = (*virtualRootSystem).workareaEdgeOffsetStart + monitorOffset;
		int x = 0;
		int y = 0;
		if((*client).desktop == NONE_DESKTOP or (*client).desktop == 0xFFFFFFFF){
			switch((*client).strut){
				to TOP_STRUT: /*----*/ y = 0; /*---------------------------------------------------*/ brk;
				to BOTTOM_STRUT: /*-*/ y = (*virtualRootSystem).height - (*client).strutHeight; /*-*/ brk;
				to LEFT_STRUT: /*---*/ x = 0; /*---------------------------------------------------*/ brk;
				to RIGHT_STRUT: /*--*/ x = (*virtualRootSystem).width - (*client).strutWidth; /*---*/ brk;
				off: /*-------------*/ /*----------------------------------------------------------*/ brk;
			}
		}else{
			if(!(*virtualRootSystem).virtualRootAllocated){
				ret false;
			}
			switch((*client).strut){
				to TOP_STRUT: /*----*/ y = (*edgeOffset).top; /*----------------------------------------------------------*/ brk;
				to BOTTOM_STRUT: /*-*/ y = (*virtualRootSystem).height - (*edgeOffset).bottom - (*client).strutHeight; /*-*/ brk;
				to LEFT_STRUT: /*---*/ x = (*edgeOffset).left; /*---------------------------------------------------------*/ brk;
				to RIGHT_STRUT: /*--*/ x = (*virtualRootSystem).width - (*edgeOffset).right - (*client).strutWidth; /*----*/ brk;
				off: /*-------------*/ /*---------------------------------------------------------------------------------*/ brk;
			}
			edgeOffset = (*((*virtualRootSystem).virtualRootStart + (*client).desktop)).workareaEdgeOffsetStart + monitorOffset;
		}
		switch((*client).strut){
			to TOP_STRUT: /*----*/ (*client).strutY = y; (*edgeOffset).top += (*client).strutHeight; /*----*/ brk;
			to BOTTOM_STRUT: /*-*/ (*client).strutY = y; (*edgeOffset).bottom += (*client).strutHeight; /*-*/ brk;
			to LEFT_STRUT: /*---*/ (*client).strutX = x; (*edgeOffset).left += (*client).strutWidth; /*----*/ brk;
			to RIGHT_STRUT: /*--*/ (*client).strutX = x; (*edgeOffset).right += (*client).strutWidth; /*---*/ brk;
			off: /*-------------*/ /*-----------------*/ /*------------------------------------------------*/ brk;
		}
		ret true;
	}
}
UPDATEVIRTUALROOTSTRUTEDCLIENTS(){
	Client *current;
	Client *wall;
	uint clientMonitorOffset;
	int multiplier;
	if(!virtualRootSystem or !(*virtualRootSystem).virtualRootAllocated or !monitorSystem or !(*monitorSystem).size or !clientSystem or !isValidClient(clientSystem, client) or !action or action > REMOVE_UPDATE_WORKAREA_ACTION){
		ret false;
	}
	jmp findMonitorOffset;
	findMonitorOffset:{
		Monitor *monitor;
		if(!(monitor = findRectangleMonitor(monitorSystem, (*client).strutX, (*client).strutY, (*client).strutWidth, (*client).strutHeight))){
			ret false;
		}
		current = (*clientSystem).clientStart;
		wall = current + (*clientSystem).clientAllocated;
		clientMonitorOffset = monitor - (*monitorSystem).start;
		multiplier = 1 - (action == REMOVE_UPDATE_WORKAREA_ACTION) * 2;
		jmp updateVirtualRootStrutedClientsLoop;
	}
	updateVirtualRootStrutedClientsLoop:{
		if(current < wall){
			if(current != client and (*current).strut == (*client).strut and (*current).stateState == NORMAL_STATE){
				if((*client).desktop == NONE_DESKTOP or (*client).desktop == 0xFFFFFFFF or ((*current).desktop != NONE_DESKTOP and (*current).desktop != 0xFFFFFFFF)){
					Monitor *monitor;
					uint monitorOffset;
					if(!(monitor = findRectangleMonitor(monitorSystem, (*current).strutX, (*current).strutY, (*current).strutWidth, (*current).strutHeight))){
						ret false;
					}
					monitorOffset = monitor - (*monitorSystem).start;
					if(monitorOffset == clientMonitorOffset){
						const int width = (*client).strutWidth;
						const int height = (*client).strutHeight;
						switch((*current).strut){
							to TOP_STRUT: /*----*/ (*client).strutY -= multiplier * height; /*-*/ brk;
							to BOTTOM_STRUT: /*-*/ (*client).strutY += multiplier * height; /*-*/ brk;
							to LEFT_STRUT: /*---*/ (*client).strutX -= multiplier * width; /*--*/ brk;
							to RIGHT_STRUT: /*--*/ (*client).strutX += multiplier * width; /*--*/ brk;
							off: /*-------------*/ /*------------------------------------------*/ brk;
						}
						moveResizeClient(clientSystem, client, (*client).strutX, (*client).strutY, (*client).strutWidth, (*client).strutHeight, false, false, false, false, false, NONE_WINDOW_GRAVITY);
					}
				}
			}
			inc current;
			jmp updateVirtualRootStrutedClientsLoop;
		}
		ret true;
	}
}
REMOVEVIRTUALROOTCLIENTWORKAREA(){
	uint monitorOffset;
	if(!virtualRootSystem or !(*virtualRootSystem).virtualRootStart or !monitorSystem or !(*monitorSystem).size or (*monitorSystem).size != (*virtualRootSystem).workareaEdgeOffsetSize or !clientSystem or !isValidClient(clientSystem, client) or (*client).stateState != NORMAL_STATE or !(*client).strut or (*client).desktop == NONE_DESKTOP){
		ret false;
	}
	jmp findMonitorOffset;
	findMonitorOffset:{
		Monitor *monitor;
		if(!(monitor = findRectangleMonitor(monitorSystem, (*client).strutX, (*client).strutY, (*client).strutWidth, (*client).strutHeight))){
			ret false;
		}
		monitorOffset = monitor - (*monitorSystem).start;
		jmp calculateWorkarea;
	}
	calculateWorkarea:{
		EdgeOffset *edgeOffset;
		if((*client).desktop == 0xFFFFFFFF){
			edgeOffset = (*virtualRootSystem).workareaEdgeOffsetStart + monitorOffset;
		}else{
			edgeOffset = (*((*virtualRootSystem).virtualRootStart + (*client).desktop)).workareaEdgeOffsetStart + monitorOffset;
		}
		switch((*client).strut){
			to TOP_STRUT: /*----*/ (*edgeOffset).top -= (*client).strutHeight; /*----*/ brk;
			to BOTTOM_STRUT: /*-*/ (*edgeOffset).bottom -= (*client).strutHeight; /*-*/ brk;
			to LEFT_STRUT: /*---*/ (*edgeOffset).left -= (*client).strutWidth; /*----*/ brk;
			to RIGHT_STRUT: /*--*/ (*edgeOffset).right -= (*client).strutWidth; /*---*/ brk;
			off: /*-------------*/ /*------------------------------------------------*/ brk;
		}
		ret true;
	}
}
MAXIMIZECLIENT(){
	Monitor *monitor;
	int x;
	int y;
	uint width;
	uint height;
	uint8 option;
	uint8 workareaPosition;
	if(!virtualRootSystem or !(*virtualRootSystem).virtualRootAllocated or !monitorSystem or !(*monitorSystem).size or (*monitorSystem).size != (*virtualRootSystem).workareaEdgeOffsetSize or !clientSystem or !isValidClient(clientSystem, client) or (*client).option & (OVERRIDE_REDIRECT_CLIENT_OPTION | TEMPORARILY_UNMAPPED_CLIENT_OPTION) or ((*client).allowedAction & (MAXIMIZE_HORZ_ALLOWED_ACTION | MAXIMIZE_VERT_ALLOWED_ACTION)) != (MAXIMIZE_HORZ_ALLOWED_ACTION | MAXIMIZE_VERT_ALLOWED_ACTION) or ((*client).state & (MAXIMIZED_HORZ_STATE | MAXIMIZED_VERT_STATE)) == (MAXIMIZED_HORZ_STATE | MAXIMIZED_VERT_STATE) or !whichMonitor or whichMonitor >= ALL_WHICH_MONITOR){
		ret false;
	}
	if(!(monitor = getWhichMonitor(monitorSystem, whichMonitor))){
		ret false;
	}
	if(!updateClientState(clientSystem, client, _NET_WM_STATE_ADD, MAXIMIZED_HORZ_STATE | MAXIMIZED_VERT_STATE)){
		ret false;
	}
	option = (*client).option & (HORIZONTALLY_MAXIMIZED_CLIENT_OPTION | VERTICALLY_MAXIMIZED_CLIENT_OPTION);
	workareaPosition = (*client).workareaPosition;
	if(!((*client).state & FULLSCREEN_STATE)){
		(*client).oldContainerX = (*client).containerX;
		(*client).oldContainerY = (*client).containerY;
		(*client).oldContainerWidth = (*client).containerWidth;
		(*client).oldContainerHeight = (*client).containerHeight;
		(*client).oldContainerBorder = (*client).containerBorder;
	}elif((*client).desktop != NONE_DESKTOP and (*client).desktop != 0xFFFFFFFF){
		xcb_reparent_window(connection, (*client).container, (*((*virtualRootSystem).virtualRootStart + (*client).desktop)).window, (*client).containerX, (*client).containerY);
	}
	updateClientState(clientSystem, client, _NET_WM_STATE_REMOVE, FULLSCREEN_STATE);
	{
		const uint monitorOffset = monitor - (*monitorSystem).start;
		const EdgeOffset *const outerEdgeOffset = (*virtualRootSystem).workareaEdgeOffsetStart + monitorOffset;
		const EdgeOffset *const innerEdgeOffset = (*((*virtualRootSystem).virtualRootStart + (*client).desktop)).workareaEdgeOffsetStart + monitorOffset;
		x = (*monitor).leftX + (*outerEdgeOffset).left + (*innerEdgeOffset).left;
		y = (*monitor).topY + (*outerEdgeOffset).top + (*innerEdgeOffset).top;
		width = (*monitor).width - (*outerEdgeOffset).left - (*innerEdgeOffset).left - (*innerEdgeOffset).right - (*outerEdgeOffset).right;
		height = (*monitor).height - (*outerEdgeOffset).top - (*innerEdgeOffset).top - (*innerEdgeOffset).bottom - (*outerEdgeOffset).bottom;
	}
	moveResizeClient(clientSystem, client, x, y, width, height, false, false, false, false, false, NONE_WINDOW_GRAVITY);
	(*client).option |= option;
	(*client).workareaPosition = workareaPosition;
	if(setClientAllowedActions(clientSystem, client)){
		changeClientAllowedActions(clientSystem, client);
	}
	changeClientState(clientSystem, client);
	ret true;
}
UNMAXIMIZECLIENT(){
	uint8 option;
	uint8 workareaPosition;
	if(!virtualRootSystem or !(*virtualRootSystem).virtualRootAllocated or !monitorSystem or !(*monitorSystem).size or (*monitorSystem).size != (*virtualRootSystem).workareaEdgeOffsetSize or !clientSystem or !isValidClient(clientSystem, client) or (*client).option & (OVERRIDE_REDIRECT_CLIENT_OPTION | TEMPORARILY_UNMAPPED_CLIENT_OPTION) or ((*client).state & (MAXIMIZED_HORZ_STATE | MAXIMIZED_VERT_STATE)) != (MAXIMIZED_HORZ_STATE | MAXIMIZED_VERT_STATE)){
		ret false;
	}
	if(!updateClientState(clientSystem, client, _NET_WM_STATE_REMOVE, MAXIMIZED_HORZ_STATE | MAXIMIZED_VERT_STATE)){
		ret false;
	}
	option = (*client).option & (HORIZONTALLY_MAXIMIZED_CLIENT_OPTION | VERTICALLY_MAXIMIZED_CLIENT_OPTION);
	workareaPosition = (*client).workareaPosition;
	(*client).containerX = (*client).oldContainerX;
	(*client).containerY = (*client).oldContainerY;
	(*client).containerWidth = (*client).oldContainerWidth;
	(*client).containerHeight = (*client).oldContainerHeight;
	(*client).containerBorder = (*client).oldContainerBorder;
	if((*client).option & (HORIZONTALLY_MAXIMIZED_CLIENT_OPTION | VERTICALLY_MAXIMIZED_CLIENT_OPTION)){
		(*client).allowedAction |= MOVE_ALLOWED_ACTION | RESIZE_ALLOWED_ACTION;
		updateVirtualRootWorkareaClient(virtualRootSystem, monitorSystem, clientSystem, client);
	}else{
		moveResizeClient(clientSystem, client, (*client).containerX, (*client).containerY, (*client).containerWidth + 2 * (*client).containerBorder, (*client).containerHeight + 2 * (*client).containerBorder, false, false, false, false, false, NONE_WINDOW_GRAVITY);
		(*client).option |= option;
		(*client).workareaPosition = workareaPosition;
	}
	if(setClientAllowedActions(clientSystem, client)){
		changeClientAllowedActions(clientSystem, client);
	}
	changeClientState(clientSystem, client);
	ret true;
}
FULLSCREENCLIENT(){
	Monitor *monitor;
	uint8 option;
	uint8 workareaPosition;
	if(!virtualRootSystem or !(*virtualRootSystem).virtualRootAllocated or !monitorSystem or !(*monitorSystem).size or (*monitorSystem).size != (*virtualRootSystem).workareaEdgeOffsetSize or !clientSystem or !isValidClient(clientSystem, client) or (*client).option & (OVERRIDE_REDIRECT_CLIENT_OPTION | TEMPORARILY_UNMAPPED_CLIENT_OPTION) or !((*client).allowedAction & FULLSCREEN_ALLOWED_ACTION) or (*client).state & FULLSCREEN_STATE or (*client).desktop == NONE_DESKTOP or (*client).desktop == 0xFFFFFFFF or !whichMonitor or whichMonitor >= ALL_WHICH_MONITOR){
		ret false;
	}
	if(!(monitor = getWhichMonitor(monitorSystem, whichMonitor))){
		ret false;
	}
	if(!updateClientState(clientSystem, client, _NET_WM_STATE_ADD, FULLSCREEN_STATE)){
		ret false;
	}
	option = (*client).option & (HORIZONTALLY_MAXIMIZED_CLIENT_OPTION | VERTICALLY_MAXIMIZED_CLIENT_OPTION);
	workareaPosition = (*client).workareaPosition;
	if(((*client).state & (MAXIMIZED_HORZ_STATE | MAXIMIZED_VERT_STATE)) != (MAXIMIZED_HORZ_STATE | MAXIMIZED_VERT_STATE)){
		(*client).oldContainerX = (*client).containerX;
		(*client).oldContainerY = (*client).containerY;
		(*client).oldContainerWidth = (*client).containerWidth;
		(*client).oldContainerHeight = (*client).containerHeight;
		(*client).oldContainerBorder = (*client).containerBorder;
	}
	if((*client).desktop != NONE_DESKTOP and (*client).desktop != 0xFFFFFFFF){
		xcb_reparent_window(connection, (*client).container, (*screen).root, (*client).containerX, (*client).containerY);
	}
	updateClientState(clientSystem, client, _NET_WM_STATE_REMOVE, MAXIMIZED_HORZ_STATE | MAXIMIZED_VERT_STATE);
	moveResizeClient(clientSystem, client, (*monitor).leftX, (*monitor).topY, (*monitor).width, (*monitor).height, false, false, false, false, false, NONE_WINDOW_GRAVITY);
	(*client).option |= option;
	(*client).workareaPosition = workareaPosition;
	if(setClientAllowedActions(clientSystem, client)){
		changeClientAllowedActions(clientSystem, client);
	}
	changeClientState(clientSystem, client);
	ret true;
}
UNFULLSCREENCLIENT(){
	uint8 option;
	uint8 workareaPosition;
	if(!virtualRootSystem or !(*virtualRootSystem).virtualRootAllocated or !monitorSystem or !(*monitorSystem).size or !clientSystem or !isValidClient(clientSystem, client) or (*client).option & (OVERRIDE_REDIRECT_CLIENT_OPTION | TEMPORARILY_UNMAPPED_CLIENT_OPTION) or !((*client).state & FULLSCREEN_STATE)){
		ret false;
	}
	if(!updateClientState(clientSystem, client, _NET_WM_STATE_REMOVE, FULLSCREEN_STATE)){
		ret false;
	}
	option = (*client).option & (HORIZONTALLY_MAXIMIZED_CLIENT_OPTION | VERTICALLY_MAXIMIZED_CLIENT_OPTION);
	workareaPosition = (*client).workareaPosition;
	if((*client).desktop != NONE_DESKTOP and (*client).desktop != 0xFFFFFFFF){
		xcb_reparent_window(connection, (*client).container, (*((*virtualRootSystem).virtualRootStart + (*client).desktop)).window, (*client).containerX, (*client).containerY);
	}
	(*client).containerX = (*client).oldContainerX;
	(*client).containerY = (*client).oldContainerY;
	(*client).containerWidth = (*client).oldContainerWidth;
	(*client).containerHeight = (*client).oldContainerHeight;
	(*client).containerBorder = (*client).oldContainerBorder;
	if((*client).option & (HORIZONTALLY_MAXIMIZED_CLIENT_OPTION | VERTICALLY_MAXIMIZED_CLIENT_OPTION)){
		(*client).allowedAction |= MOVE_ALLOWED_ACTION | RESIZE_ALLOWED_ACTION;
		updateVirtualRootWorkareaClient(virtualRootSystem, monitorSystem, clientSystem, client);
	}else{
		moveResizeClient(clientSystem, client, (*client).containerX, (*client).containerY, (*client).containerWidth + 2 * (*client).containerBorder, (*client).containerHeight + 2 * (*client).containerBorder, false, false, false, false, false, NONE_WINDOW_GRAVITY);
		(*client).option |= option;
		(*client).workareaPosition = workareaPosition;
	}
	if(setClientAllowedActions(clientSystem, client)){
		changeClientAllowedActions(clientSystem, client);
	}
	changeClientState(clientSystem, client);
	ret true;
}
MOVERESIZEWORKAREACLIENT(){
	Monitor *monitor;
	int workareaX;
	int workareaY;
	int workareaWidth;
	int workareaHeight;
	int x;
	int y;
	int width;
	int height;
	uint8 windowGravity;
	if(!virtualRootSystem or !(*virtualRootSystem).virtualRootAllocated or !monitorSystem or !(*monitorSystem).size or (*virtualRootSystem).workareaEdgeOffsetSize != (*monitorSystem).size or !isValidClient(clientSystem, client) or (*client).desktop == NONE_DESKTOP or (*client).desktop == 0xFFFFFFFF or (*client).desktop >= (*virtualRootSystem).virtualRootAllocated or (*client).state & FULLSCREEN_STATE or (*client).option & (OVERRIDE_REDIRECT_CLIENT_OPTION | TEMPORARILY_UNMAPPED_CLIENT_OPTION)){
		ret false;
	}
	if(!(monitor = getWhichMonitor(monitorSystem, whichMonitor))){
		if(whichMonitor != SELF_WHICH_MONITOR){
			ret false;
		}
		if(!(monitor = findRectangleMonitor(monitorSystem, (*client).containerX, (*client).containerY, (*client).containerWidth + 2 * (*client).containerBorder, (*client).containerHeight + 2 * (*client).containerBorder))){
			ret false;
		}
	}
	{
		const uint monitorOffset = monitor - (*monitorSystem).start;
		const EdgeOffset *const outerEdgeOffset = (*virtualRootSystem).workareaEdgeOffsetStart + monitorOffset;
		const EdgeOffset *const innerEdgeOffset = (*((*virtualRootSystem).virtualRootStart + (*client).desktop)).workareaEdgeOffsetStart + monitorOffset;
		workareaX = (*monitor).leftX + (*outerEdgeOffset).left + (*innerEdgeOffset).left;
		workareaY = (*monitor).topY + (*outerEdgeOffset).top + (*innerEdgeOffset).top;
		workareaWidth = (*monitor).width - (*outerEdgeOffset).left - (*innerEdgeOffset).left - (*innerEdgeOffset).right - (*outerEdgeOffset).right;
		workareaHeight = (*monitor).height - (*outerEdgeOffset).top - (*innerEdgeOffset).top - (*innerEdgeOffset).bottom - (*outerEdgeOffset).bottom;
	}
	switch(workareaPosition){
		to NONE_WORKAREA_POSITION: /*---------*/ /*--------------------------------*/ /*----------------------------------*/ /*----------------------------------------------*/ /*------------------------------------------------*/ /*--------------------------------------------------*/ ret false;
		to TOP_WORKAREA_POSITION: /*----------*/ width = workareaWidth / 1; /*-----*/ height = workareaHeight / 2; /*-----*/ x = workareaX; /*-------------------------------*/ y = workareaY; /*---------------------------------*/ windowGravity = NORTH_SIDE_WINDOW_GRAVITY; /*-------*/ brk;
		to BOTTOM_WORKAREA_POSITION: /*-------*/ width = workareaWidth / 1; /*-----*/ height = workareaHeight / 2; /*-----*/ x = workareaX; /*-------------------------------*/ y = workareaY + workareaHeight - height; /*-------*/ windowGravity = SOUTH_SIDE_WINDOW_GRAVITY; /*-------*/ brk;
		to LEFT_WORKAREA_POSITION: /*---------*/ width = workareaWidth / 2; /*-----*/ height = workareaHeight / 1; /*-----*/ x = workareaX; /*-------------------------------*/ y = workareaY; /*---------------------------------*/ windowGravity = WEST_SIDE_WINDOW_GRAVITY; /*--------*/ brk;
		to RIGHT_WORKAREA_POSITION: /*--------*/ width = workareaWidth / 2; /*-----*/ height = workareaHeight / 1; /*-----*/ x = workareaX + workareaWidth - width; /*-------*/ y = workareaY; /*---------------------------------*/ windowGravity = EAST_SIDE_WINDOW_GRAVITY; /*--------*/ brk;
		to TOP_LEFT_WORKAREA_POSITION: /*-----*/ width = workareaWidth / 2; /*-----*/ height = workareaHeight / 2; /*-----*/ x = workareaX; /*-------------------------------*/ y = workareaY; /*---------------------------------*/ windowGravity = NORTH_WEST_POINT_WINDOW_GRAVITY; /*-*/ brk;
		to TOP_RIGHT_WORKAREA_POSITION: /*----*/ width = workareaWidth / 2; /*-----*/ height = workareaHeight / 2; /*-----*/ x = workareaX + workareaWidth - width; /*-------*/ y = workareaY; /*---------------------------------*/ windowGravity = NORTH_EAST_POINT_WINDOW_GRAVITY; /*-*/ brk;
		to BOTTOM_LEFT_WORKAREA_POSITION: /*--*/ width = workareaWidth / 2; /*-----*/ height = workareaHeight / 2; /*-----*/ x = workareaX; /*-------------------------------*/ y = workareaY + workareaHeight - height; /*-------*/ windowGravity = SOUTH_WEST_POINT_WINDOW_GRAVITY; /*-*/ brk;
		to BOTTOM_RIGHT_WORKAREA_POSITION: /*-*/ width = workareaWidth / 2; /*-----*/ height = workareaHeight / 2; /*-----*/ x = workareaX + workareaWidth - width; /*-------*/ y = workareaY + workareaHeight - height; /*-------*/ windowGravity = SOUTH_EAST_POINT_WINDOW_GRAVITY; /*-*/ brk;
		to CENTER_WORKAREA_POSITION: /*-------*/ width = workareaWidth * 3 / 4; /*-*/ height = workareaHeight * 3 / 4; /*-*/ x = workareaX + (workareaWidth - width) / 2; /*-*/ y = workareaY + (workareaHeight - height) / 2; /*-*/ windowGravity = CENTER_POINT_WINDOW_GRAVITY; /*-----*/ brk;
		to FULL_WORKAREA_POSITION: /*---------*/ width = workareaWidth / 1; /*-----*/ height = workareaHeight / 1; /*-----*/ x = workareaX; /*-------------------------------*/ y = workareaY; /*---------------------------------*/ windowGravity = NONE_WINDOW_GRAVITY; /*-------------*/ brk;
		off: /*-------------------------------*/ /*--------------------------------*/ /*----------------------------------*/ /*----------------------------------------------*/ /*------------------------------------------------*/ /*--------------------------------------------------*/ ret false;
	}
	if(!moveResizeClient(clientSystem, client, x, y, width, height, false, true, false, false, true, windowGravity)){
		ret false;
	}
	(*client).workareaPosition = workareaPosition;
	switch(workareaPosition){
		to NONE_WORKAREA_POSITION: /*---------*/ /*------------------------------------------------------------------------------------------------*/ ret false;
		to TOP_WORKAREA_POSITION: /*----------*/ (*client).option |= HORIZONTALLY_MAXIMIZED_CLIENT_OPTION; /*--------------------------------------*/ brk;
		to BOTTOM_WORKAREA_POSITION: /*-------*/ (*client).option |= HORIZONTALLY_MAXIMIZED_CLIENT_OPTION; /*--------------------------------------*/ brk;
		to LEFT_WORKAREA_POSITION: /*---------*/ (*client).option |= VERTICALLY_MAXIMIZED_CLIENT_OPTION; /*----------------------------------------*/ brk;
		to RIGHT_WORKAREA_POSITION: /*--------*/ (*client).option |= VERTICALLY_MAXIMIZED_CLIENT_OPTION; /*----------------------------------------*/ brk;
		to TOP_LEFT_WORKAREA_POSITION: /*-----*/ /*------------------------------------------------------------------------------------------------*/ brk;
		to TOP_RIGHT_WORKAREA_POSITION: /*----*/ /*------------------------------------------------------------------------------------------------*/ brk;
		to BOTTOM_LEFT_WORKAREA_POSITION: /*--*/ /*------------------------------------------------------------------------------------------------*/ brk;
		to BOTTOM_RIGHT_WORKAREA_POSITION: /*-*/ /*------------------------------------------------------------------------------------------------*/ brk;
		to CENTER_WORKAREA_POSITION: /*-------*/ /*------------------------------------------------------------------------------------------------*/ brk;
		to FULL_WORKAREA_POSITION: /*---------*/ (*client).option |= HORIZONTALLY_MAXIMIZED_CLIENT_OPTION | VERTICALLY_MAXIMIZED_CLIENT_OPTION; /*-*/ brk;
		off: /*-------------------------------*/ /*------------------------------------------------------------------------------------------------*/ ret false;
	}
	ret true;
}
UPDATEVIRTUALROOTWORKAREACLIENT(){
	if(!virtualRootSystem or !(*virtualRootSystem).virtualRootAllocated or !monitorSystem or !(*monitorSystem).size or !clientSystem or !isValidClient(clientSystem, client) or (*client).strut or (*client).stateState != NORMAL_STATE or (((*client).state & (MAXIMIZED_HORZ_STATE | MAXIMIZED_VERT_STATE)) != (MAXIMIZED_HORZ_STATE | MAXIMIZED_VERT_STATE) and !((*client).option & (HORIZONTALLY_MAXIMIZED_CLIENT_OPTION | VERTICALLY_MAXIMIZED_CLIENT_OPTION)))){
		ret false;
	}
	moveResizeWorkareaClient(virtualRootSystem, monitorSystem, clientSystem, client, SELF_WHICH_MONITOR, (*client).workareaPosition);
	ret true;
}
UPDATEVIRTUALROOTWORKAREACLIENTS(){
	VirtualRoot *current;
	VirtualRoot *wall;
	Client *clientStart;
	if(!virtualRootSystem or !(*virtualRootSystem).virtualRootAllocated or !(*virtualRootSystem).workareaEdgeOffsetSize or !monitorSystem or !(*monitorSystem).size or (*monitorSystem).size != (*virtualRootSystem).workareaEdgeOffsetSize or !clientSystem or !(*clientSystem).clientAllocated){
		ret false;
	}
	current = (*virtualRootSystem).virtualRootStart;
	wall = current + (*virtualRootSystem).virtualRootAllocated;
	clientStart = (*clientSystem).clientStart;
	jmp updateVirtualRootLoop;
	updateVirtualRootLoop:{
		if(current < wall){
			if((*current).orderedClientOffsetAllocated){
				uint *ordedredClientOffsetCurrent = (*current).orderedClientOffsetStart;
				uint *const ordedredClientOffsetWall = ordedredClientOffsetCurrent + (*current).orderedClientOffsetAllocated;
				jmp updateClientLoop;
				updateClientLoop:{
					if(ordedredClientOffsetCurrent < ordedredClientOffsetWall){
						Client *const client = clientStart + *ordedredClientOffsetCurrent;
						if(!(*client).strut and (*client).stateState == NORMAL_STATE and (((*client).state & (MAXIMIZED_HORZ_STATE | MAXIMIZED_VERT_STATE)) == (MAXIMIZED_HORZ_STATE | MAXIMIZED_VERT_STATE) or (*client).option & (HORIZONTALLY_MAXIMIZED_CLIENT_OPTION | VERTICALLY_MAXIMIZED_CLIENT_OPTION))){
							const EdgeOffset *outerEdgeOffset;
							const EdgeOffset *innerEdgeOffset;
							const uint8 option = (*client).option & (HORIZONTALLY_MAXIMIZED_CLIENT_OPTION | VERTICALLY_MAXIMIZED_CLIENT_OPTION);
							const uint8 workareaPosition = (*client).workareaPosition;
							Monitor *monitor;
							uint monitorOffset;
							int workareaX;
							int workareaY;
							int workareaWidth;
							int workareaHeight;
							if(!(monitor = findRectangleMonitor(monitorSystem, (*client).containerX, (*client).containerY, (*client).containerWidth + 2 * (*client).containerBorder, (*client).containerHeight + 2 * (*client).containerBorder))){
								ret false;
							}
							monitorOffset = monitor - (*monitorSystem).start;
							outerEdgeOffset = (*virtualRootSystem).workareaEdgeOffsetStart + monitorOffset;
							innerEdgeOffset = (*current).workareaEdgeOffsetStart + monitorOffset;
							workareaX = (*monitor).leftX + (*outerEdgeOffset).left + (*innerEdgeOffset).left;
							workareaY = (*monitor).topY + (*outerEdgeOffset).top + (*innerEdgeOffset).top;
							workareaWidth = (*monitor).width - (*outerEdgeOffset).left - (*innerEdgeOffset).left - (*innerEdgeOffset).right - (*outerEdgeOffset).right;
							workareaHeight = (*monitor).height - (*outerEdgeOffset).top - (*innerEdgeOffset).top - (*innerEdgeOffset).bottom - (*outerEdgeOffset).bottom;
							if(((*client).state & (MAXIMIZED_HORZ_STATE | MAXIMIZED_VERT_STATE)) == (MAXIMIZED_HORZ_STATE | MAXIMIZED_VERT_STATE) or ((*client).option & (HORIZONTALLY_MAXIMIZED_CLIENT_OPTION | VERTICALLY_MAXIMIZED_CLIENT_OPTION)) == (HORIZONTALLY_MAXIMIZED_CLIENT_OPTION | VERTICALLY_MAXIMIZED_CLIENT_OPTION)){
								moveResizeClient(clientSystem, client, workareaX, workareaY, workareaWidth, workareaHeight, false, false, true, false, true, NONE_WINDOW_GRAVITY);
							}elif((*client).option & HORIZONTALLY_MAXIMIZED_CLIENT_OPTION){
								moveResizeClient(clientSystem, client, workareaX, (*client).containerY, workareaWidth, (*client).containerHeight + 2 * (*client).containerBorder, false, false, true, false, true, NONE_WINDOW_GRAVITY);
							}else{
								moveResizeClient(clientSystem, client, (*client).containerX, workareaY, (*client).containerWidth + 2 * (*client).containerBorder, workareaHeight, false, false, true, false, true, NONE_WINDOW_GRAVITY);
							}
							(*client).option |= option;
							(*client).workareaPosition = workareaPosition;
						}
						inc ordedredClientOffsetCurrent;
						jmp updateClientLoop;
					}
				}
			}
			inc current;
			jmp updateVirtualRootLoop;
		}
		ret true;
	}
}
SHOWVIRTUALROOTDESKTOP(){
	VirtualRoot *virtualRoot;
	uint *current;
	uint *wall;
	if(!virtualRootSystem or !clientSystem or !(*clientSystem).clientAllocated or showDesktop == (*virtualRootSystem).showingDesktop or which >= (*virtualRootSystem).virtualRootAllocated or which == NONE_DESKTOP){
		ret false;
	}
	virtualRoot = (*virtualRootSystem).virtualRootStart + which;
	current = (*virtualRoot).orderedClientOffsetStart;
	wall = current + (*virtualRoot).orderedClientOffsetAllocated;
	jmp showDesktopLoop;
	showDesktopLoop:{
		if(current < wall){
			Client *const client = (*clientSystem).clientStart + *current;
			if(!((*client).option & OVERRIDE_REDIRECT_CLIENT_OPTION) and !((*client).windowType & (DESKTOP_WINDOW_TYPE | DOCK_WINDOW_TYPE))){
				if(showDesktop){
					if((*client).stateState & NORMAL_STATE){
						xcb_unmap_window(connection, (*client).container);
						(*client).option |= TEMPORARILY_UNMAPPED_CLIENT_OPTION;
					}
				}else{
					if((*client).option & TEMPORARILY_UNMAPPED_CLIENT_OPTION){
						xcb_map_window(connection, (*client).container);
						(*client).option &= ~TEMPORARILY_UNMAPPED_CLIENT_OPTION;
					}
				}
			}
			inc current;
			jmp showDesktopLoop;
		}
		(*virtualRootSystem).showingDesktop = showDesktop;
		xcb_change_property(connection, XCB_PROP_MODE_REPLACE, (*screen).root, atom._NET_SHOWING_DESKTOP, XCB_ATOM_CARDINAL, bitsof(uint32), 1, &(*virtualRootSystem).showingDesktop);
		ret true;
	}
}
DESTROYVIRTUALROOT(){
	if(!virtualRootSystem or !isValidVirtualRoot(virtualRootSystem, virtualRoot)){
		ret false;
	}
	if((*virtualRoot).gc){
		xcb_free_gc(connection, (*virtualRoot).gc);
		(*virtualRoot).gc = XCB_NONE;
	}
	if((*virtualRoot).pixmap){
		xcb_free_pixmap(connection, (*virtualRoot).pixmap);
		(*virtualRoot).pixmap = XCB_NONE;
	}
	if((*virtualRoot).window){
		xcb_destroy_window(connection, (*virtualRoot).window);
		(*virtualRoot).window = XCB_NONE;
	}
	free((*virtualRoot).workareaEdgeOffsetStart);
	popPointer((*virtualRoot).workareaEdgeOffsetToken);
	(*virtualRoot).workareaEdgeOffsetSize = 0;
	(*virtualRoot).workareaEdgeOffsetStart = NULL;
	(*virtualRoot).workareaEdgeOffsetToken = 0;
	free((*virtualRoot).nameStart);
	popPointer((*virtualRoot).nameToken);
	(*virtualRoot).nameSize = 0;
	(*virtualRoot).nameStart = NULL;
	(*virtualRoot).nameToken = 0;
	free((*virtualRoot).orderedClientOffsetStart);
	popPointer((*virtualRoot).orderedClientOffsetToken);
	(*virtualRoot).orderedClientOffsetSize = 0;
	(*virtualRoot).orderedClientOffsetAllocated = 0;
	(*virtualRoot).orderedClientOffsetStart = NULL;
	(*virtualRoot).orderedClientOffsetToken = 0;
	ret true;
}
ISVALIDVIRTUALROOT(){
	ret virtualRootSystem and virtualRoot and virtualRoot >= (*virtualRootSystem).virtualRootStart and virtualRoot < (*virtualRootSystem).virtualRootStart + (*virtualRootSystem).virtualRootAllocated;
}
FINDVIRTUALROOT(){
	VirtualRoot *current;
	VirtualRoot *wall;
	if(!virtualRootSystem or !(*virtualRootSystem).virtualRootAllocated or !window){
		ret NULL;
	}
	current = (*virtualRootSystem).virtualRootStart;
	wall = current + (*virtualRootSystem).virtualRootAllocated;
	jmp findVirtualRootLoop;
	findVirtualRootLoop:{
		if(current < wall){
			if((*current).window == window){
				ret current;
			}
			inc current;
			jmp findVirtualRootLoop;
		}
		ret NULL;
	}
}
FINDORDEREDVIRTUALROOTCLIENTOFFSET(){
	uint *current;
	uint *wall;
	Client *clientStart;
	if(!virtualRootSystem or !isValidVirtualRoot(virtualRootSystem, virtualRoot) or !(*virtualRoot).orderedClientOffsetAllocated or !clientSystem or !(*clientSystem).clientAllocated or !window){
		ret NULL;
	}
	current = (*virtualRoot).orderedClientOffsetStart;
	wall = current + (*virtualRoot).orderedClientOffsetAllocated;
	clientStart = (*clientSystem).clientStart;
	jmp findOrderedVirtualRootClientOffsetLoop;
	findOrderedVirtualRootClientOffsetLoop:{
		if(current < wall){
			if((*(clientStart + *current)).window == window){
				ret current;
			}
			inc current;
			jmp findOrderedVirtualRootClientOffsetLoop;
		}
		ret NULL;
	}
}
FINDPOSITIONEDORDEREDVIRTUALROOTCLIENT(){
	VirtualRoot *virtualRoot;
	uint *start;
	uint *current;
	Client *clientStart;
	if(!virtualRootSystem or !clientSystem or !(*clientSystem).clientAllocated or which >= (*virtualRootSystem).virtualRootAllocated or which == NONE_DESKTOP or which == 0xFFFFFFFF){
		ret NULL;
	}
	virtualRoot = (*virtualRootSystem).virtualRootStart + which;
	if(!isValidVirtualRoot(virtualRootSystem, virtualRoot) or !(*virtualRoot).orderedClientOffsetStart){
		ret NULL;
	}
	start = (*virtualRoot).orderedClientOffsetStart;
	current = start + (*virtualRoot).orderedClientOffsetAllocated - 1;
	clientStart = (*clientSystem).clientStart;
	jmp findPositionedOrderedVirtualRootClientLoop;
	findPositionedOrderedVirtualRootClientLoop:{
		if(current >= start){
			Client *const client = clientStart + *current;
			if((*client).inUse and (*client).containerX <= x and (*client).containerX + (int)((*client).containerWidth + 2 * (*client).containerBorder) > x and (*client).containerY <= y and (*client).containerY + (int)((*client).containerHeight + 2 * (*client).containerBorder) > y){
				ret client;
			}
			dec current;
			jmp findPositionedOrderedVirtualRootClientLoop;
		}
		ret NULL;
	}
}
FINIVIRTUALROOTSYSTEM(){
	VirtualRoot *current;
	VirtualRoot *wall;
	if(!virtualRootSystem){
		ret false;
	}
	if((*virtualRootSystem).virtualRootAllocated){
		current = (*virtualRootSystem).virtualRootStart;
		wall = current + (*virtualRootSystem).virtualRootAllocated;
		jmp destroyVirtualRootLoop;
		destroyVirtualRootLoop:{
			if(current < wall){
				destroyVirtualRoot(virtualRootSystem, current);
				inc current;
				jmp destroyVirtualRootLoop;
			}
		}
	}
	(*virtualRootSystem).width = 0;
	(*virtualRootSystem).height = 0;
	(*virtualRootSystem).currentDesktop = NONE_DESKTOP;
	(*virtualRootSystem).showingDesktop = false;
	(*virtualRootSystem).desktopLayoutColumns = 0;
	(*virtualRootSystem).desktopLayoutRows = 0;
	(*virtualRootSystem).desktopLayoutOrientation = _NET_WM_ORIENTATION_HORZ;
	(*virtualRootSystem).desktopLayoutStartingCorner = _NET_WM_TOPLEFT;
	(*virtualRootSystem).mapped = false;
	free((*virtualRootSystem).workareaStart);
	popPointer((*virtualRootSystem).workareaToken);
	(*virtualRootSystem).workareaSize = 0;
	(*virtualRootSystem).workareaStart = NULL;
	(*virtualRootSystem).workareaToken = 0;
	free((*virtualRootSystem).desktopNamesStart);
	popPointer((*virtualRootSystem).desktopNamesToken);
	(*virtualRootSystem).desktopNamesSize = 0;
	(*virtualRootSystem).desktopNamesStart = NULL;
	(*virtualRootSystem).desktopNamesToken = 0;
	free((*virtualRootSystem).viewportStart);
	popPointer((*virtualRootSystem).viewportToken);
	(*virtualRootSystem).viewportSize = 0;
	(*virtualRootSystem).viewportStart = NULL;
	(*virtualRootSystem).viewportToken = 0;
	free((*virtualRootSystem).windowStart);
	popPointer((*virtualRootSystem).windowToken);
	(*virtualRootSystem).windowSize = 0;
	(*virtualRootSystem).windowStart = NULL;
	(*virtualRootSystem).windowToken = 0;
	free((*virtualRootSystem).workareaEdgeOffsetStart);
	popPointer((*virtualRootSystem).workareaEdgeOffsetToken);
	(*virtualRootSystem).workareaEdgeOffsetSize = 0;
	(*virtualRootSystem).workareaEdgeOffsetStart = NULL;
	(*virtualRootSystem).workareaEdgeOffsetToken = 0;
	free((*virtualRootSystem).virtualRootStart);
	popPointer((*virtualRootSystem).virtualRootToken);
	(*virtualRootSystem).virtualRootSize = 0;
	(*virtualRootSystem).virtualRootAllocated = 0;
	(*virtualRootSystem).virtualRootStart = NULL;
	(*virtualRootSystem).virtualRootToken = 0;
	ret true;
}
INITCLIENTLISTSYSTEM(){
	#define CLIENT_LIST_BLOCK_SIZE /*-*/ (16)
	if(!clientListSystem){
		ret false;
	}
	(*clientListSystem).clientSize = 0;
	(*clientListSystem).clientAllocated = 0;
	(*clientListSystem).clientStart = NULL;
	(*clientListSystem).clientToken = 0;
	(*clientListSystem).property = XCB_NONE;
	ret true;
}
SETCLIENTLISTPROPERTY(){
	if(!clientListSystem or !property){
		ret false;
	}
	(*clientListSystem).property = property;
	ret true;
}
ADDCLIENTLISTWINDOW(){
	if(!clientListSystem){
		ret false;
	}
	if((*clientListSystem).clientAllocated == (*clientListSystem).clientSize){
		void *temp;
		(*clientListSystem).clientSize += CLIENT_LIST_BLOCK_SIZE;
		temp = realloc((*clientListSystem).clientStart, (*clientListSystem).clientSize * sizeof(xcb_window_t));
		if(!(*clientListSystem).clientToken){
			(*clientListSystem).clientToken = pushPointer(temp, "client list window pointer", iFree);
		}else{
			updatePointer((*clientListSystem).clientToken, temp);
		}
		if(!temp){
			printTitledError("memory allocation error", "could not allocate memory for client list");
			(*clientListSystem).clientSize -= CLIENT_LIST_BLOCK_SIZE;
			ret false;
		}
		(*clientListSystem).clientStart = temp;
	}
	*((*clientListSystem).clientStart + (*clientListSystem).clientAllocated) = window;
	inc (*clientListSystem).clientAllocated;
	ret true;
}
CONFIGURECLIENTLISTCLIENT(){
	Client *siblingClient;
	uint8 stackMode;
	xcb_window_t sibling;
	if(!clientListSystem or !clientSystem or !isValidClient(clientSystem, client)){
		ret false;
	}
	if((siblingClient = findBelowManagedClient(clientSystem, client))){
		stackMode = XCB_STACK_MODE_ABOVE;
		sibling = (*siblingClient).window;
	}else{
		stackMode = XCB_STACK_MODE_BELOW;
		sibling = XCB_NONE;
	}
	if(!restackClientListWindow(clientListSystem, (*client).window, stackMode, sibling)){
		ret false;
	}
	ret true;
}
RESTACKCLIENTLISTWINDOW(){
	xcb_window_t *start;
	xcb_window_t *current;
	xcb_window_t *wall;
	xcb_window_t copy;
	if(!clientListSystem or !(*clientListSystem).clientAllocated){
		ret false;
	}
	start = (*clientListSystem).clientStart;
	wall = start + (*clientListSystem).clientAllocated;
	switch(stackMode){
		to XCB_STACK_MODE_ABOVE: /*-*/ jmp stackModeAbove;
		to XCB_STACK_MODE_BELOW: /*-*/ jmp stackModeBelow;
		off: /*---------------------*/ ret false;
	}
	stackModeAbove:{
		xcb_window_t *siblingWindow = wall - 1;
		if(!(current = findClientListWindow(clientListSystem, window))){
			ret false;
		}
		if(sibling and !(siblingWindow = findClientListWindow(clientListSystem, sibling))){
			ret false;
		}
		if(current == siblingWindow or current == siblingWindow + 1){
			ret false;
		}
		copy = *current;
		if(current < siblingWindow){
			shiftMemory(current + 1, (siblingWindow - current) * sizeof(xcb_window_t), -(int)sizeof(xcb_window_t));
			*siblingWindow = copy;
			ret true;
		}
		shiftMemory(siblingWindow + 1, (current - siblingWindow - 1) * sizeof(xcb_window_t), sizeof(xcb_window_t));
		*(siblingWindow + 1) = copy;
		ret true;
	}
	stackModeBelow:{
		xcb_window_t *siblingWindow = start;
		if(!(current = findClientListWindow(clientListSystem, window))){
			ret false;
		}
		if(sibling and !(siblingWindow = findClientListWindow(clientListSystem, sibling))){
			ret false;
		}
		if(current == siblingWindow or current == siblingWindow - 1){
			ret false;
		}
		copy = *current;
		if(current < siblingWindow){
			shiftMemory(current + 1, (siblingWindow - current - 1) * sizeof(xcb_window_t), -(int)sizeof(xcb_window_t));
			*(siblingWindow - 1) = copy;
			ret true;
		}
		shiftMemory(siblingWindow, (current - siblingWindow) * sizeof(xcb_window_t), sizeof(xcb_window_t));
		*siblingWindow = copy;
		ret true;
	}
}
CHANGECLIENTLISTPROPERTY(){
	if(!clientListSystem or !(*clientListSystem).property){
		ret false;
	}
	xcb_change_property(connection, XCB_PROP_MODE_REPLACE, (*screen).root, (*clientListSystem).property, XCB_ATOM_WINDOW, bitsof(xcb_window_t), (*clientListSystem).clientAllocated, (*clientListSystem).clientStart);
	ret true;
}
REMOVECLIENTLISTWINDOW(){
	xcb_window_t *current;
	if(!(current = findClientListWindow(clientListSystem, window))){
		ret false;
	}
	shiftMemory(current + 1, ((*clientListSystem).clientStart + (*clientListSystem).clientAllocated - current - 1) * sizeof(xcb_window_t), -(int)sizeof(xcb_window_t));
	dec (*clientListSystem).clientAllocated;
	ret true;
}
FINDCLIENTLISTWINDOW(){
	xcb_window_t *current;
	xcb_window_t *wall;
	if(!clientListSystem or !(*clientListSystem).clientStart or !window){
		ret NULL;
	}
	current = (*clientListSystem).clientStart;
	wall = current + (*clientListSystem).clientAllocated;
	jmp findClientListWindowLoop;
	findClientListWindowLoop:{
		if(current < wall){
			if(*current == window){
				ret current;
			}
			inc current;
			jmp findClientListWindowLoop;
		}
		ret NULL;
	}
}
FINICLIENTLISTSYSTEM(){
	if(!clientListSystem){
		ret false;
	}
	free((*clientListSystem).clientStart);
	popPointer((*clientListSystem).clientToken);
	(*clientListSystem).clientSize = 0;
	(*clientListSystem).clientAllocated = 0;
	(*clientListSystem).clientStart = NULL;
	(*clientListSystem).clientToken = 0;
	(*clientListSystem).property = XCB_NONE;
	ret true;
	#undef  CLIENT_LIST_BLOCK_SIZE
}
INITWINDOWMANAGERSYSTEM(){
	jmp updateSelection;
	updateSelection:{
		previousWMSelectionWindow = XCB_NONE;
		wmSelectionTimestamp = getTimestamp();
		jmp selectInput;
	}
	selectInput:{
		xcb_generic_error_t *error;
		uint32 token;
		struct{
			uint32 /*-*/ eventMask;
		} valueList;
		valueList.eventMask = XCB_EVENT_MASK_SUBSTRUCTURE_NOTIFY | XCB_EVENT_MASK_SUBSTRUCTURE_REDIRECT | XCB_EVENT_MASK_PROPERTY_CHANGE | XCB_EVENT_MASK_COLOR_MAP_CHANGE;
		error = xcb_request_check(connection, xcb_change_window_attributes_checked(connection, (*screen).root, XCB_CW_EVENT_MASK, &valueList));
		token = pushPointer(error, "initWindowManagerSystem() change window attributes error", iFree);
		if(error){
			if((*error).error_code == XCB_ACCESS){
				printTitledError("access error", "a window manager is already running");
			}else{
				printTitledError("select input error", "could not apply to receive root window events");
			}
			free(error);
			popPointer(token);
			ret false;
		}
		jmp initSystems;
	}
	initSystems:{
		uint32 valueMask;
		struct{
			uint32 /*-------*/ eventMask;
			xcb_cursor_t /*-*/ cursor;
		} valueList;
		setCursor(&cursorSystem, LEFT_POINTER_CURSOR_GLYPH, 0x00171717, 0x00E8E8E8);
		setWallpaperColor(&wallpaperSystem, &monitorSystem, 0xFF171717);
		setWallpaperPixmap(&wallpaperSystem, &monitorSystem, atom._XROOTPMAP_ID);
		createWallpaper(&wallpaperSystem, &monitorSystem, screenWidthInPixels, screenHeightInPixels);
		resizeVirtualRoot(&virtualRootSystem, &monitorSystem, &wallpaperSystem, &clientSystem, screenWidthInPixels, screenHeightInPixels);
		setVirtualRootAmount(&virtualRootSystem, &monitorSystem, &clientSystem, &cursorSystem, 10);
		setVirtualRootWallpaper(&virtualRootSystem, &wallpaperSystem);
		mapVirtualRoots(&virtualRootSystem);
		valueMask = XCB_CW_EVENT_MASK;
		if(cursorSystem.cursor){
			valueMask |= XCB_CW_CURSOR;
			valueList.cursor = cursorSystem.cursor;
		}
		wmCheckWindow = xcb_generate_id(connection);
		defaultFocusWindow = xcb_generate_id(connection);
		glassWindow = xcb_generate_id(connection);
		xcb_create_window(connection, XCB_COPY_FROM_PARENT, wmCheckWindow, (*screen).root, -1, -1, 1, 1, 0, XCB_WINDOW_CLASS_INPUT_ONLY, (*screen).root_visual, XCB_NONE, NULL);
		valueList.eventMask = XCB_EVENT_MASK_FOCUS_CHANGE;
		xcb_create_window(connection, XCB_COPY_FROM_PARENT, defaultFocusWindow, (*screen).root, -1, -1, 1, 1, 0, XCB_WINDOW_CLASS_INPUT_ONLY, (*screen).root_visual, XCB_CW_EVENT_MASK, &valueList);
		valueList.eventMask = XCB_EVENT_MASK_KEY_RELEASE | XCB_EVENT_MASK_BUTTON_RELEASE | XCB_EVENT_MASK_POINTER_MOTION;
		xcb_create_window(connection, XCB_COPY_FROM_PARENT, glassWindow, (*screen).root, 0, 0, screenWidthInPixels, screenHeightInPixels, 0, XCB_WINDOW_CLASS_INPUT_ONLY, (*screen).root_visual, valueMask, &valueList);
		xcb_map_window(connection, defaultFocusWindow);
		xcb_set_input_focus(connection, XCB_INPUT_FOCUS_POINTER_ROOT, defaultFocusWindow, getTimestamp());
		/*! set desktop layout here if not set already */
		setClientListProperty(&clientListSystem, atom._NET_CLIENT_LIST);
		setClientListProperty(&clientListStackingSystem, atom._NET_CLIENT_LIST_STACKING);
		xcb_change_property(connection, XCB_PROP_MODE_REPLACE, wmCheckWindow, atom._NET_WM_NAME, atom.UTF8_STRING, bitsof(uint8), lengthof(PROGRAM_NAME), PROGRAM_NAME);
		xcb_change_property(connection, XCB_PROP_MODE_REPLACE, wmCheckWindow, atom._NET_SUPPORTING_WM_CHECK, XCB_ATOM_WINDOW, bitsof(xcb_window_t), 1, &wmCheckWindow);
		xcb_change_property(connection, XCB_PROP_MODE_REPLACE, defaultFocusWindow, atom.WM_NAME, XCB_ATOM_STRING, bitsof(uint8), lengthof(PROGRAM_NAME), PROGRAM_NAME);
		xcb_change_property(connection, XCB_PROP_MODE_REPLACE, defaultFocusWindow, atom._NET_WM_NAME, atom.UTF8_STRING, bitsof(uint8), lengthof(PROGRAM_NAME), PROGRAM_NAME);
		xcb_change_property(connection, XCB_PROP_MODE_REPLACE, (*screen).root, atom._NET_SUPPORTING_WM_CHECK, XCB_ATOM_WINDOW, bitsof(xcb_window_t), 1, &wmCheckWindow);
		xcb_change_property(connection, XCB_PROP_MODE_REPLACE, (*screen).root, atom._NET_WM_NAME, atom.UTF8_STRING, bitsof(uint8), lengthof(PROGRAM_NAME), PROGRAM_NAME);
		setNetSupported();
		changeActiveWindow(&clientSystem);
		jmp announce;
	}
	announce:{
		xcb_client_message_event_t message;
		uint32 *const data = message.data.data32;
		message.response_type = XCB_CLIENT_MESSAGE;
		message.format = 32;
		message.window = (*screen).root;
		message.type = atom.MANAGER;
		*(data + 0) = getTimestamp();
		*(data + 1) = atom.WM_Sn;
		*(data + 2) = wmSelectionWindow;
		*(data + 3) = 0;
		*(data + 4) = 0;
		xcb_send_event(connection, false, message.window, XCB_EVENT_MASK_STRUCTURE_NOTIFY, &message);
		ret true;
	}
}
SETNETSUPPORTED(){
	#define UNSUPPORTED(a) /*--*/ EMPTY_MACRO
	#define INITIALIZE(a) /*---*/ XCB_NONE,
	#define APPEND(a) /*-------*/ *current = atom.a; inc current;
	#define ATOM(SUPPORTED) /*-*/ { \
		  SUPPORTED(_NET_SUPPORTED) \
		  SUPPORTED(_NET_CLIENT_LIST) \
		  SUPPORTED(_NET_CLIENT_LIST_STACKING) \
		  SUPPORTED(_NET_NUMBER_OF_DESKTOPS) \
		  SUPPORTED(_NET_DESKTOP_GEOMETRY) \
		  SUPPORTED(_NET_DESKTOP_VIEWPORT) \
		  SUPPORTED(_NET_CURRENT_DESKTOP) \
		  SUPPORTED(_NET_DESKTOP_NAMES) \
		  SUPPORTED(_NET_ACTIVE_WINDOW) \
		  SUPPORTED(_NET_WORKAREA) \
		  SUPPORTED(_NET_SUPPORTING_WM_CHECK) \
		  SUPPORTED(_NET_VIRTUAL_ROOTS) \
		UNSUPPORTED(_NET_DESKTOP_LAYOUT) \
		  SUPPORTED(_NET_SHOWING_DESKTOP) \
		  SUPPORTED(_NET_CLOSE_WINDOW) \
		UNSUPPORTED(_NET_MOVERESIZE_WINDOW) \
		UNSUPPORTED(_NET_WM_MOVERESIZE) \
		  SUPPORTED(_NET_RESTACK_WINDOW) \
		  SUPPORTED(_NET_REQUEST_FRAME_EXTENTS) \
		  SUPPORTED(_NET_WM_NAME) \
		  SUPPORTED(_NET_WM_VISIBLE_NAME) \
		UNSUPPORTED(_NET_WM_ICON_NAME) \
		UNSUPPORTED(_NET_WM_VISIBLE_ICON_NAME) \
		  SUPPORTED(_NET_WM_DESKTOP) \
		  SUPPORTED(_NET_WM_WINDOW_TYPE) \
		  SUPPORTED(_NET_WM_WINDOW_TYPE_DESKTOP) \
		  SUPPORTED(_NET_WM_WINDOW_TYPE_DOCK) \
		  SUPPORTED(_NET_WM_WINDOW_TYPE_TOOLBAR) \
		  SUPPORTED(_NET_WM_WINDOW_TYPE_MENU) \
		  SUPPORTED(_NET_WM_WINDOW_TYPE_UTILITY) \
		  SUPPORTED(_NET_WM_WINDOW_TYPE_SPLASH) \
		  SUPPORTED(_NET_WM_WINDOW_TYPE_DIALOG) \
		  SUPPORTED(_NET_WM_WINDOW_TYPE_NORMAL) \
		  SUPPORTED(_NET_WM_STATE) \
		  SUPPORTED(_NET_WM_STATE_MODAL) \
		UNSUPPORTED(_NET_WM_STATE_STICKY) \
		  SUPPORTED(_NET_WM_STATE_MAXIMIZED_HORZ) \
		  SUPPORTED(_NET_WM_STATE_MAXIMIZED_VERT) \
		UNSUPPORTED(_NET_WM_STATE_SHADED) \
		  SUPPORTED(_NET_WM_STATE_SKIP_TASKBAR) \
		  SUPPORTED(_NET_WM_STATE_SKIP_PAGER) \
		  SUPPORTED(_NET_WM_STATE_HIDDEN) \
		  SUPPORTED(_NET_WM_STATE_FULLSCREEN) \
		  SUPPORTED(_NET_WM_STATE_ABOVE) \
		  SUPPORTED(_NET_WM_STATE_BELOW) \
		  SUPPORTED(_NET_WM_STATE_DEMANDS_ATTENTION) \
		  SUPPORTED(_NET_WM_ALLOWED_ACTIONS) \
		  SUPPORTED(_NET_WM_ACTION_MOVE) \
		  SUPPORTED(_NET_WM_ACTION_RESIZE) \
		  SUPPORTED(_NET_WM_ACTION_MINIMIZE) \
		UNSUPPORTED(_NET_WM_ACTION_SHADE) \
		UNSUPPORTED(_NET_WM_ACTION_STICK) \
		  SUPPORTED(_NET_WM_ACTION_MAXIMIZE_HORZ) \
		  SUPPORTED(_NET_WM_ACTION_MAXIMIZE_VERT) \
		  SUPPORTED(_NET_WM_ACTION_FULLSCREEN) \
		  SUPPORTED(_NET_WM_ACTION_CHANGE_DESKTOP) \
		  SUPPORTED(_NET_WM_ACTION_CLOSE) \
		  SUPPORTED(_NET_WM_STRUT) \
		  SUPPORTED(_NET_WM_STRUT_PARTIAL) \
		UNSUPPORTED(_NET_WM_ICON_GEOMETRY) \
		UNSUPPORTED(_NET_WM_ICON) \
		  SUPPORTED(_NET_WM_PID) \
		  SUPPORTED(_NET_WM_HANDLED_ICONS) \
		  SUPPORTED(_NET_WM_USER_TIME) \
		  SUPPORTED(_NET_FRAME_EXTENTS) \
		UNSUPPORTED(_NET_WM_PING) \
		UNSUPPORTED(_NET_WM_SYNC_REQUEST) \
		UNSUPPORTED(_NET_WM_SYNC_REQUEST_COUNTER) \
	}
	xcb_atom_t valueList[] = ATOM(INITIALIZE);
	xcb_atom_t *current = valueList;
	ATOM(APPEND);
	resetProperty((*screen).root, atom._NET_SUPPORTED, XCB_ATOM_ATOM, sizeof(xcb_atom_t), countof(valueList), valueList);
	ret true;
	#undef  ATOM
	#undef  APPEND
	#undef  INITIALIZE
	#undef  UNSUPPORTED
}
STORECLIENTPROPERTIES(){
	xcb_window_t container;
	xcb_window_t window;
	xcb_list_properties_reply_t *reply;
	uint32 token;
	if(!client){
		ret false;
	}
	container = (*client).container;
	window = (*client).window;
	reply = xcb_wait_for_reply(connection, xcb_list_properties(connection, window), NULL);
	token = pushPointer(reply, "storeClientProperties() list properties reply", iFree);
	if(reply){
		const uint length = xcb_list_properties_atoms_length(reply);
		if(length){
			const xcb_atom_t *current = xcb_list_properties_atoms(reply);
			const xcb_atom_t *const wall = current + length;
			jmp copyPropertyLoop;
			copyPropertyLoop:{
				xcb_get_property_reply_t *const reply = xcb_wait_for_reply(connection, xcb_get_property(connection, false, window, *current, XCB_GET_PROPERTY_TYPE_ANY, 0, 0xFFFFFFFF), NULL);
				uint32 token = pushPointer(reply, "storeClientProperties() get property reply", iFree);
				if(reply){
					const void *const value = xcb_get_property_value(reply);
					if(container){
						const uint size = (*reply).format / 8;
						uint length = xcb_get_property_value_length(reply);
						if(size){
							length /= size;
						}
						xcb_change_property(connection, XCB_PROP_MODE_REPLACE, container, *current, (*reply).type, (*reply).format, length, value);
					}
					storeClientProperty(client, *current, xcb_get_property_value_length(reply), value);
					free(reply);
					popPointer(token);
				}
				if(inc current < wall){
					jmp copyPropertyLoop;
				}
			}
		}
		free(reply);
		popPointer(token);
	}
	ret true;
}
STORECLIENTPROPERTY(){
	if(!client or !property){
		ret false;
	}
	if(property == atom.WM_NAME){
		if((*client).propertyPreference & NAME_PROPERTY_PREFERENCE or !length or !value){
			ret false;
		}
		if(!*((uint8 *)value + length / sizeof(uint8) - 1)){
			dec length;
		}
		if(!reallocateProperty(sizeof(uint8), length, value, "client WM_NAME pointer", &(*client).nameSize, &(*client).nameStart, &(*client).nameToken)){
			ret false;
		}
		if(reallocateProperty(sizeof(uint8), length, value, "client _NET_WM_VISIBLE_NAME pointer", &(*client).visibleNameSize, &(*client).visibleNameStart, &(*client).visibleNameToken)){
			xcb_discard_reply(connection, xcb_change_property_checked(connection, XCB_PROP_MODE_REPLACE, (*client).window, atom._NET_WM_VISIBLE_NAME, atom.UTF8_STRING, bitsof(uint8), (*client).visibleNameSize, (*client).visibleNameStart));
		}
		ret true;
	}
	if(property == atom.WM_ICON_NAME){
		if((*client).propertyPreference & ICON_NAME_PROPERTY_PREFERENCE or !length or !value){
			ret false;
		}
		if(!*((uint8 *)value + length / sizeof(uint8) - 1)){
			dec length;
		}
		if(!reallocateProperty(sizeof(uint8), length, value, "client WM_ICON_NAME pointer", &(*client).iconNameSize, &(*client).iconNameStart, &(*client).iconNameToken)){
			ret false;
		}
		if(reallocateProperty(sizeof(uint8), length, value, "client _NET_WM_VISIBLE_ICON_NAME pointer", &(*client).visibleIconNameSize, &(*client).visibleIconNameStart, &(*client).visibleIconNameToken)){
			xcb_discard_reply(connection, xcb_change_property_checked(connection, XCB_PROP_MODE_REPLACE, (*client).window, atom._NET_WM_VISIBLE_ICON_NAME, atom.UTF8_STRING, bitsof(uint8), (*client).visibleIconNameSize, (*client).visibleIconNameStart));
		}
		ret true;
	}



























/*!
	if(property == atom.WM_NORMAL_HINTS){
		uint32 flags;
		if(!length or !value){
			ret false;
		}
		flags = *(uint32 *)value;
		(*client).normalHintsFlags |= flags;
		value = (uint32 *)value + 1;
		length -= 1 * sizeof(uint32);
		if(flags & (USER_POSITION_NORMAL_HINT | PROGRAM_POSITION_NORMAL_HINT) and length >= 2){
			(*client).normalHintsX = *((int32 *)value + 0);
			(*client).normalHintsY = *((int32 *)value + 1);
			value = (int32 *)value + 2;
			length -= 2 * sizeof(int32);
		}
		if(flags & (USER_SIZE_NORMAL_HINT | PROGRAM_SIZE_NORMAL_HINT) and length >= 2){
			(*client).normalHintsWidth = *((int32 *)value + 0);
			(*client).normalHintsHeight = *((int32 *)value + 1);
			value = (int32 *)value + 2;
			length -= 2 * sizeof(int32);
		}
		if(flags & PROGRAM_MINIMUM_SIZE_NORMAL_HINT and length >= 2){
			(*client).normalHintsMinWidth = *((int32 *)value + 0);
			(*client).normalHintsMinHeight = *((int32 *)value + 1);
			value = (int32 *)value + 2;
			length -= 2 * sizeof(int32);
		}
		if(flags & PROGRAM_MAXIMUM_SIZE_NORMAL_HINT and length >= 2){
			(*client).normalHintsMaxWidth = *((int32 *)value + 0);
			(*client).normalHintsMaxHeight = *((int32 *)value + 1);
			value = (int32 *)value + 2;
			length -= 2 * sizeof(int32);
		}
		if(flags & PROGRAM_RESIZE_INCREMENT_NORMAL_HINT and length >= 2){
			(*client).normalHintsWidthInc = *((int32 *)value + 0);
			(*client).normalHintsHeightInc = *((int32 *)value + 1);
			value = (int32 *)value + 2;
			length -= 2 * sizeof(int32);
		}
		if(flags & PROGRAM_ASPECT_NORMAL_HINT and length >= 4){
			(*client).normalHintsMinAspectNumerator = *((int32 *)value + 0);
			(*client).normalHintsMinAspectDenominator = *((int32 *)value + 1);
			(*client).normalHintsMaxAspectNumerator = *((int32 *)value + 2);
			(*client).normalHintsMaxAspectDenominator = *((int32 *)value + 3);
			value = (int32 *)value + 4;
			length -= 4 * sizeof(int32);
		}
		if(flags & PROGRAM_BASE_SIZE_NORMAL_HINT and length >= 2){
			(*client).normalHintsBaseWidth = *((int32 *)value + 0);
			(*client).normalHintsBaseHeight = *((int32 *)value + 1);
			value = (int32 *)value + 2;
			length -= 2 * sizeof(int32);
		}
		if(flags & PROGRAM_WINDOW_GRAVITY_NORMAL_HINT and length >= 1){
			(*client).normalHintsWindowGravity = *((int32 *)value + 0);
			if((*client).normalHintsWindowGravity == XCB_GRAVITY_WIN_UNMAP){
				(*client).normalHintsWindowGravity = XCB_GRAVITY_NORTH_WEST;
			}
		}
		if(!(*client).normalHintsMinWidth){
			(*client).normalHintsMinWidth = (*client).normalHintsBaseWidth;
			(*client).normalHintsMinHeight = (*client).normalHintsBaseHeight;
		}
		if(!(*client).normalHintsBaseWidth){
			(*client).normalHintsBaseWidth = (*client).normalHintsMinWidth;
			(*client).normalHintsBaseHeight = (*client).normalHintsMinHeight;
		}
		ret true;
	}
	if(property == atom.WM_HINTS){
		uint32 flags;
		if(!length or !value){
			ret false;
		}
		flags = *(uint32 *)value;
		value = (uint32 *)value + 1;
		length -= 1 * sizeof(uint32);
		if(flags & INPUT_HINT and length >= 1){
			(*client).hintsInput = !!*((uint32 *)value + 0);
			value = (uint32 *)value + 1;
			length -= 1 * sizeof(uint32);
		}
		if(flags & STATE_HINT and length >= 1){
			(*client).hintsInitialState = *((uint32 *)value + 0);
			if((*client).hintsInitialState != NORMAL_STATE and (*client).hintsInitialState != ICONIC_STATE){
				(*client).hintsInitialState = NORMAL_STATE;
			}
			value = (uint32 *)value + 1;
			length -= 1 * sizeof(uint32);
		}
		if(flags & ICON_PIXMAP_HINT and length >= 1){
			(*client).hintsIconPixmap = *((xcb_pixmap_t *)value + 0);
			value = (xcb_pixmap_t *)value + 1;
			length -= 1 * sizeof(xcb_pixmap_t);
		}
		if(flags & ICON_WINDOW_HINT and length >= 1){
			(*client).hintsIconWindow = *((xcb_window_t *)value + 0);
			value = (xcb_window_t *)value + 1;
			length -= 1 * sizeof(xcb_window_t);
		}
		if(flags & ICON_POSITION_HINT and length >= 2){
			(*client).hintsIconX = *((int32 *)value + 0);
			(*client).hintsIconY = *((int32 *)value + 1);
			value = (int32 *)value + 2;
			length -= 2 * sizeof(int32);
		}
		if(flags & ICON_MASK_HINT and length >= 1){
			(*client).hintsIconMask = *((xcb_pixmap_t *)value + 0);
			value = (xcb_pixmap_t *)value + 1;
			length -= 1 * sizeof(xcb_pixmap_t);
		}
		if(flags & WINDOW_GROUP_HINT and length >= 1){
			(*client).hintsWindowGroup = *((xcb_window_t *)value + 0);
		}
		if(flags & URGENCY_HINT){
			(*client).hintsUrgency = true;
		}
		ret true;
	}
*/









	if(property == atom.WM_NORMAL_HINTS){
		uint32 flags;
		if(!length or length != 18 * sizeof(uint32) or !value){
			ret false;
		}
		flags = *((uint32 *)value + 0);
		(*client).normalHintsFlags = flags;
		if(flags & (USER_POSITION_NORMAL_HINT | PROGRAM_POSITION_NORMAL_HINT)){
			(*client).normalHintsX = *((int32 *)value + 1);
			(*client).normalHintsY = *((int32 *)value + 2);
		}
		if(flags & (USER_SIZE_NORMAL_HINT | PROGRAM_SIZE_NORMAL_HINT)){
			(*client).normalHintsWidth = *((int32 *)value + 3);
			(*client).normalHintsHeight = *((int32 *)value + 4);
		}
		if(flags & PROGRAM_MINIMUM_SIZE_NORMAL_HINT){
			(*client).normalHintsMinWidth = *((int32 *)value + 5);
			(*client).normalHintsMinHeight = *((int32 *)value + 6);
		}
		if(flags & PROGRAM_MAXIMUM_SIZE_NORMAL_HINT){
			(*client).normalHintsMaxWidth = *((int32 *)value + 7);
			(*client).normalHintsMaxHeight = *((int32 *)value + 8);
		}
		if(flags & PROGRAM_RESIZE_INCREMENT_NORMAL_HINT){
			(*client).normalHintsWidthInc = *((int32 *)value + 9);
			(*client).normalHintsHeightInc = *((int32 *)value + 10);
		}
		if(flags & PROGRAM_ASPECT_NORMAL_HINT){
			(*client).normalHintsMinAspectNumerator = *((int32 *)value + 11);
			(*client).normalHintsMinAspectDenominator = *((int32 *)value + 12);
			(*client).normalHintsMaxAspectNumerator = *((int32 *)value + 13);
			(*client).normalHintsMaxAspectDenominator = *((int32 *)value + 14);
		}
		if(flags & PROGRAM_BASE_SIZE_NORMAL_HINT){
			(*client).normalHintsBaseWidth = *((int32 *)value + 15);
			(*client).normalHintsBaseHeight = *((int32 *)value + 16);
		}
		if(flags & PROGRAM_WINDOW_GRAVITY_NORMAL_HINT){
			(*client).normalHintsWindowGravity = *((int32 *)value + 17);
			if((*client).normalHintsWindowGravity == XCB_GRAVITY_WIN_UNMAP){
				(*client).normalHintsWindowGravity = XCB_GRAVITY_NORTH_WEST;
			}
		}



		/*! what are these checks, my boy */

		if(!(*client).normalHintsMinWidth){
			(*client).normalHintsMinWidth = (*client).normalHintsBaseWidth;
			(*client).normalHintsMinHeight = (*client).normalHintsBaseHeight;
		}
		if(!(*client).normalHintsBaseWidth){
			(*client).normalHintsBaseWidth = (*client).normalHintsMinWidth;
			(*client).normalHintsBaseHeight = (*client).normalHintsMinHeight;
		}



		ret true;
	}
	if(property == atom.WM_HINTS){
		uint32 flags;
		if(!length or length != 9 * sizeof(uint32) or !value){
			ret false;
		}
		flags = *((uint32 *)value + 0);
		if(flags & INPUT_HINT){
			(*client).hintsInput = !!*((uint32 *)value + 1);
		}
		if(flags & STATE_HINT){
			(*client).hintsInitialState = *((uint32 *)value + 2);
			if((*client).hintsInitialState != NORMAL_STATE and (*client).hintsInitialState != ICONIC_STATE){
				(*client).hintsInitialState = NORMAL_STATE;
			}
		}
		if(flags & ICON_PIXMAP_HINT){
			(*client).hintsIconPixmap = *((xcb_pixmap_t *)value + 3);
		}
		if(flags & ICON_WINDOW_HINT){
			(*client).hintsIconWindow = *((xcb_window_t *)value + 4);
		}
		if(flags & ICON_POSITION_HINT){
			(*client).hintsIconX = *((int32 *)value + 5);
			(*client).hintsIconY = *((int32 *)value + 6);
		}
		if(flags & ICON_MASK_HINT){
			(*client).hintsIconMask = *((xcb_pixmap_t *)value + 7);
		}
		if(flags & WINDOW_GROUP_HINT){
			(*client).hintsWindowGroup = *((xcb_window_t *)value + 8);
		}
		if(flags & URGENCY_HINT){
			(*client).hintsUrgency = true;
		}
		ret true;
	}



























	if(property == atom.WM_CLASS){
		if((*client).stateState != WITHDRAWN_STATE or !length or !value){
			ret false;
		}
		if(*((uint8 *)value + length / sizeof(uint8) - 1)){
			inc length;
		}
		if(!reallocateProperty(sizeof(uint8), length, value, "client WM_CLASS pointer", &(*client).classSize, &(*client).classStart, &(*client).classToken)){
			ret false;
		}
		*((*client).classStart + length / sizeof(uint8) - 1) = '\0';
		ret true;
	}
	if(property == atom.WM_TRANSIENT_FOR){
		if(length != sizeof(xcb_window_t) or !value){
			ret false;
		}
		(*client).transientFor = *(xcb_window_t *)value;
		/*! update stacking to keep the transient above its parent. */
		ret true;
	}
	if(property == atom.WM_PROTOCOLS){
		xcb_window_t *current;
		xcb_window_t *wall;
		if(!length or !value){
			ret false;
		}
		if(!reallocateProperty(sizeof(xcb_atom_t), length, value, "client WM_PROTOCOLS pointer", &(*client).protocolSize, (uint8 **)&(*client).protocolStart, &(*client).protocolToken)){
			ret false;
		}
		current = (*client).protocolStart;
		wall = current + (*client).protocolSize;
		(*client).protocol = NONE_CLIENT_PROTOCOL;
		jmp storeProtocolLoop;
		storeProtocolLoop:{
			const xcb_atom_t a = *current;
			if(a == atom.WM_TAKE_FOCUS){
				(*client).protocol |= TAKE_FOCUS_CLIENT_PROTOCOL;
			}elif(a == atom.WM_DELETE_WINDOW){
				(*client).protocol |= DELETE_WINDOW_CLIENT_PROTOCOL;
			}elif(a == atom._NET_WM_PING){
				(*client).protocol |= PING_CLIENT_PROTOCOL;
			}elif(a == atom._NET_WM_SYNC_REQUEST){
				(*client).protocol |= SYNC_CLIENT_PROTOCOL;
			}
			if(inc current < wall){
				jmp storeProtocolLoop;
			}
			ret true;
		}
	}
	if(property == atom.WM_COLORMAP_WINDOWS){
		const xcb_window_t *current;
		const xcb_window_t *wall;
		struct{
			uint32 /*-*/ eventMask;
		} valueList;
		if(!length or !value){
			ret false;
		}
		if(!reallocateProperty(sizeof(xcb_window_t), length, value, "client WM_COLORMAP_WINDOWS pointer", &(*client).colormapWindowSize, (uint8 **)&(*client).colormapWindowStart, &(*client).colormapWindowToken)){
			ret false;
		}
		current = (*client).colormapWindowStart;
		wall = current + (*client).colormapWindowSize;
		valueList.eventMask = XCB_EVENT_MASK_COLOR_MAP_CHANGE;
		jmp selectInputColormapLoop;
		selectInputColormapLoop:{
			if(!findClientWindow(&clientSystem, *current)){
				xcb_discard_reply(connection, xcb_change_window_attributes_checked(connection, *current, XCB_CW_EVENT_MASK, &valueList));
			}
			if(inc current < wall){
				jmp selectInputColormapLoop;
			}
			ret true;
		}
	}
	if(property == atom.WM_CLIENT_MACHINE){
		if(!length or !value){
			ret false;
		}
		if(!*((uint8 *)value + length / sizeof(uint8) - 1)){
			dec length;
		}
		if(!reallocateProperty(sizeof(uint8), length, value, "client WM_CLIENT_MACHINE pointer", &(*client).clientMachineSize, &(*client).clientMachineStart, &(*client).clientMachineToken)){
			ret false;
		}
		ret true;
	}
	if(property == atom.SM_CLIENT_ID){
		if(!length or !value){
			ret false;
		}
		if(!*((uint8 *)value + length / sizeof(uint8) - 1)){
			dec length;
		}
		if(!reallocateProperty(sizeof(uint8), length, value, "client SM_CLIENT_ID pointer", &(*client).clientIDSize, &(*client).clientIDStart, &(*client).clientIDToken)){
			ret false;
		}
		ret true;
	}
	if(property == atom.WM_CLIENT_LEADER){
		if(length != sizeof(xcb_window_t) or !value){
			ret false;
		}
		(*client).clientLeader = *(xcb_window_t *)value;
		ret true;
	}
	if(property == atom.WM_WINDOW_ROLE){
		if(!length or !value){
			ret false;
		}
		if(!*((uint8 *)value + length / sizeof(uint8) - 1)){
			dec length;
		}
		if(!reallocateProperty(sizeof(uint8), length, value, "client WM_WINDOW_ROLE pointer", &(*client).windowRoleSize, &(*client).windowRoleStart, &(*client).windowRoleToken)){
			ret false;
		}
		ret true;
	}
	if(property == atom.WM_STATE){
		resetProperty((*client).window, property, property, sizeof(uint32), 2, &(*client).stateState);
		ret true;
	}
	if(property == atom._NET_WM_NAME){
		if(!length or !value){
			ret false;
		}
		if(!*((uint8 *)value + length / sizeof(uint8) - 1)){
			dec length;
		}
		if(!reallocateProperty(sizeof(uint8), length, value, "client _NET_WM_NAME pointer", &(*client).nameSize, &(*client).nameStart, &(*client).nameToken)){
			ret false;
		}
		(*client).propertyPreference |= NAME_PROPERTY_PREFERENCE;
		if(reallocateProperty(sizeof(uint8), length, value, "client _NET_WM_VISIBLE_NAME pointer", &(*client).visibleNameSize, &(*client).visibleNameStart, &(*client).visibleNameToken)){
			xcb_discard_reply(connection, xcb_change_property_checked(connection, XCB_PROP_MODE_REPLACE, (*client).window, atom._NET_WM_VISIBLE_NAME, atom.UTF8_STRING, bitsof(uint8), (*client).visibleNameSize, (*client).visibleNameStart));
		}
		ret true;
	}
	if(property == atom._NET_WM_VISIBLE_NAME){
		if(!(*client).visibleNameStart){
			xcb_discard_reply(connection, xcb_delete_property_checked(connection, (*client).window, property));
			ret true;
		}
		resetProperty((*client).window, property, atom.UTF8_STRING, sizeof(uint8), (*client).visibleNameSize, (*client).visibleNameStart);
		ret true;
	}
	if(property == atom._NET_WM_ICON_NAME){
		if(!length or !value){
			ret false;
		}
		if(!*((uint8 *)value + length / sizeof(uint8) - 1)){
			dec length;
		}
		if(!reallocateProperty(sizeof(uint8), length, value, "client _NET_WM_ICON_NAME pointer", &(*client).iconNameSize, &(*client).iconNameStart, &(*client).iconNameToken)){
			ret false;
		}
		(*client).propertyPreference |= ICON_NAME_PROPERTY_PREFERENCE;
		if(reallocateProperty(sizeof(uint8), length, value, "client _NET_WM_VISIBLE_ICON_NAME pointer", &(*client).visibleIconNameSize, &(*client).visibleIconNameStart, &(*client).visibleIconNameToken)){
			xcb_discard_reply(connection, xcb_change_property_checked(connection, XCB_PROP_MODE_REPLACE, (*client).window, atom._NET_WM_VISIBLE_ICON_NAME, atom.UTF8_STRING, bitsof(uint8), (*client).visibleIconNameSize, (*client).visibleIconNameStart));
		}
		ret true;
	}
	if(property == atom._NET_WM_VISIBLE_ICON_NAME){
		if(!(*client).visibleIconNameStart){
			xcb_discard_reply(connection, xcb_delete_property_checked(connection, (*client).window, property));
			ret true;
		}
		resetProperty((*client).window, property, atom.UTF8_STRING, sizeof(uint8), (*client).visibleIconNameSize, (*client).visibleIconNameStart);
		ret true;
	}
	if(property == atom._NET_WM_DESKTOP){
		if((*client).stateState != WITHDRAWN_STATE or length != sizeof(uint32) or !value){
			ret false;
		}
		moveClientToVirtualRoot(&virtualRootSystem, &monitorSystem, &clientSystem, client, *(uint32 *)value, true);
		ret true;
	}
	if(property == atom._NET_WM_WINDOW_TYPE){
		const xcb_atom_t *current;
		const xcb_atom_t *wall;
		xcb_atom_t desktop;
		xcb_atom_t dock;
		xcb_atom_t toolbar;
		xcb_atom_t menu;
		xcb_atom_t utility;
		xcb_atom_t splash;
		xcb_atom_t dialog;
		xcb_atom_t normal;
		uint8 windowType;
		if((*client).stateState != WITHDRAWN_STATE or !length or !value){
			ret false;
		}
		current = value;
		wall = current + length / sizeof(xcb_atom_t);
		desktop = atom._NET_WM_WINDOW_TYPE_DESKTOP;
		dock = atom._NET_WM_WINDOW_TYPE_DOCK;
		toolbar = atom._NET_WM_WINDOW_TYPE_TOOLBAR;
		menu = atom._NET_WM_WINDOW_TYPE_MENU;
		utility = atom._NET_WM_WINDOW_TYPE_UTILITY;
		splash = atom._NET_WM_WINDOW_TYPE_SPLASH;
		dialog = atom._NET_WM_WINDOW_TYPE_DIALOG;
		normal = atom._NET_WM_WINDOW_TYPE_NORMAL;
		windowType = NONE_WINDOW_TYPE;
		jmp createWindowTypeLoop;
		createWindowTypeLoop:{
			if(current < wall){
				const xcb_atom_t a = *current;
				windowType |= (a == desktop) * DESKTOP_WINDOW_TYPE + (a == dock) * DOCK_WINDOW_TYPE + (a == toolbar) * TOOLBAR_WINDOW_TYPE + (a == menu) * MENU_WINDOW_TYPE + (a == utility) * UTILITY_WINDOW_TYPE + (a == splash) * SPLASH_WINDOW_TYPE + (a == dialog) * DIALOG_WINDOW_TYPE + (a == normal) * NORMAL_WINDOW_TYPE;
				inc current;
				jmp createWindowTypeLoop;
			}
		}
		if(windowType == (*client).windowType){
			ret false;
		}
		if(!reallocateProperty(sizeof(xcb_atom_t), length, value, "client _NET_WM_WINDOW_TYPE pointer", &(*client).windowTypeSize, (uint8 **)&(*client).windowTypeStart, &(*client).windowTypeToken)){
			ret false;
		}
		(*client).windowType = windowType;
		setDefaultClientWindowType(&clientSystem, client);
		if(setClientAllowedActions(&clientSystem, client)){
			changeClientAllowedActions(&clientSystem, client);
		}
		if(setClientOrderType(&clientSystem, client)){
			if(restackClient(&clientSystem, client, XCB_STACK_MODE_ABOVE, XCB_NONE)){
				configureClient(&clientSystem, client);
				configureVirtualRootClient(&virtualRootSystem, &clientSystem, client);
				if(configureClientListClient(&clientListStackingSystem, &clientSystem, client)){
					changeClientListProperty(&clientListStackingSystem);
				}
			}
		}
		ret true;
	}
	if(property == atom._NET_WM_STATE){
		const xcb_atom_t *current;
		const xcb_atom_t *wall;
		xcb_atom_t modal;
		xcb_atom_t sticky;
		xcb_atom_t maximizedVert;
		xcb_atom_t maximizedHorz;
		xcb_atom_t shaded;
		xcb_atom_t skipTaskbar;
		xcb_atom_t skipPager;
		xcb_atom_t hidden;
		xcb_atom_t fullscreen;
		xcb_atom_t above;
		xcb_atom_t below;
		xcb_atom_t demandsAttention;
		uint16 state;
		if((*client).stateState != WITHDRAWN_STATE or !length or !value){
			ret false;
		}
		current = value;
		wall = current + length / sizeof(xcb_atom_t);
		modal = atom._NET_WM_STATE_MODAL;
		sticky = atom._NET_WM_STATE_STICKY;
		maximizedHorz = atom._NET_WM_STATE_MAXIMIZED_HORZ;
		maximizedVert = atom._NET_WM_STATE_MAXIMIZED_VERT;
		shaded = atom._NET_WM_STATE_SHADED;
		skipTaskbar = atom._NET_WM_STATE_SKIP_TASKBAR;
		skipPager = atom._NET_WM_STATE_SKIP_PAGER;
		hidden = atom._NET_WM_STATE_HIDDEN;
		fullscreen = atom._NET_WM_STATE_FULLSCREEN;
		above = atom._NET_WM_STATE_ABOVE;
		below = atom._NET_WM_STATE_BELOW;
		demandsAttention = atom._NET_WM_STATE_DEMANDS_ATTENTION;
		state = NONE_STATE;
		jmp createaStateLoop;
		createaStateLoop:{
			if(current < wall){
				const xcb_atom_t a = *current;
				state |= (a == modal) * MODAL_STATE + (a == sticky) * STICKY_STATE + (a == maximizedHorz) * MAXIMIZED_HORZ_STATE + (a == maximizedVert) * MAXIMIZED_VERT_STATE + (a == shaded) * SHADED_STATE + (a == skipTaskbar) * SKIP_TASKBAR_STATE + (a == skipPager) * SKIP_PAGER_STATE + (a == hidden) * HIDDEN_STATE + (a == fullscreen) * FULLSCREEN_STATE + (a == above) * ABOVE_STATE + (a == below) * BELOW_STATE + (a == demandsAttention) * DEMANDS_ATTENTION_STATE;
				inc current;
				jmp createaStateLoop;
			}
		}
		if(state == (*client).state){
			ret false;
		}
		if(!reallocateProperty(sizeof(xcb_atom_t), length, value, "client _NET_WM_STATE pointer", &(*client).stateSize, (uint8 **)&(*client).stateStart, &(*client).stateToken)){
			ret false;
		}
		(*client).state = state;
		if(setClientAllowedActions(&clientSystem, client)){
			changeClientAllowedActions(&clientSystem, client);
		}
		if(setClientOrderType(&clientSystem, client)){
			if(restackClient(&clientSystem, client, XCB_STACK_MODE_ABOVE, XCB_NONE)){
				configureClient(&clientSystem, client);
				configureVirtualRootClient(&virtualRootSystem, &clientSystem, client);
				if(configureClientListClient(&clientListStackingSystem, &clientSystem, client)){
					changeClientListProperty(&clientListStackingSystem);
				}
			}
		}
		ret true;
	}
	if(property == atom._NET_WM_ALLOWED_ACTIONS){
		resetProperty((*client).window, property, XCB_ATOM_ATOM, sizeof(xcb_atom_t), (*client).allowedActionSize, (*client).allowedActionStart);
		ret true;
	}
	if(property == atom._NET_WM_STRUT){
		bool flag;
		if((*client).propertyPreference & STRUT_PROPERTY_PREFERENCE or length != 4 * sizeof(uint32) or !value){
			ret false;
		}
		(*client).strutLeft = *((uint32 *)value + 0);
		(*client).strutRight = *((uint32 *)value + 1);
		(*client).strutTop = *((uint32 *)value + 2);
		(*client).strutBottom = *((uint32 *)value + 3);
		(*client).strutLeftStartY = 0;
		(*client).strutLeftEndY = 0;
		(*client).strutRightStartY = 0;
		(*client).strutRightEndY = 0;
		(*client).strutTopStartX = 0;
		(*client).strutTopEndX = 0;
		(*client).strutBottomStartX = 0;
		(*client).strutBottomEndX = 0;
		flag = false;
		if(removeVirtualRootClientWorkarea(&virtualRootSystem, &monitorSystem, &clientSystem, client)){
			updateVirtualRootStrutedClients(&virtualRootSystem, &monitorSystem, &clientSystem, client, REMOVE_UPDATE_WORKAREA_ACTION);
			updateVirtualRootWorkareaClients(&virtualRootSystem, &monitorSystem, &clientSystem);
			flag = true;
		}
		if(assignClientStrut(&clientSystem, &monitorSystem, client)){
			if(addVirtualRootClientWorkarea(&virtualRootSystem, &monitorSystem, &clientSystem, client)){
				updateVirtualRootStrutedClients(&virtualRootSystem, &monitorSystem, &clientSystem, client, ADD_UPDATE_WORKAREA_ACTION);
				updateVirtualRootWorkareaClients(&virtualRootSystem, &monitorSystem, &clientSystem);
				flag = true;
			}
		}
		if(flag){
			if(setVirtualRootWorkarea(&virtualRootSystem, &monitorSystem)){
				changeVirtualRootWorkarea(&virtualRootSystem);
			}
		}
		ret true;
	}
	if(property == atom._NET_WM_STRUT_PARTIAL){
		bool flag;
		if(length != 12 * sizeof(uint32) or !value){
			ret false;
		}
		(*client).strutLeft = *((uint32 *)value + 0);
		(*client).strutRight = *((uint32 *)value + 1);
		(*client).strutTop = *((uint32 *)value + 2);
		(*client).strutBottom = *((uint32 *)value + 3);
		(*client).strutLeftStartY = *((uint32 *)value + 4);
		(*client).strutLeftEndY = *((uint32 *)value + 5);
		(*client).strutRightStartY = *((uint32 *)value + 6);
		(*client).strutRightEndY = *((uint32 *)value + 7);
		(*client).strutTopStartX = *((uint32 *)value + 8);
		(*client).strutTopEndX = *((uint32 *)value + 9);
		(*client).strutBottomStartX = *((uint32 *)value + 10);
		(*client).strutBottomEndX = *((uint32 *)value + 11);
		(*client).propertyPreference |= STRUT_PROPERTY_PREFERENCE;
		flag = false;
		if(removeVirtualRootClientWorkarea(&virtualRootSystem, &monitorSystem, &clientSystem, client)){
			updateVirtualRootStrutedClients(&virtualRootSystem, &monitorSystem, &clientSystem, client, REMOVE_UPDATE_WORKAREA_ACTION);
			updateVirtualRootWorkareaClients(&virtualRootSystem, &monitorSystem, &clientSystem);
			flag = true;
		}
		if(assignClientStrut(&clientSystem, &monitorSystem, client)){
			if(addVirtualRootClientWorkarea(&virtualRootSystem, &monitorSystem, &clientSystem, client)){
				updateVirtualRootStrutedClients(&virtualRootSystem, &monitorSystem, &clientSystem, client, ADD_UPDATE_WORKAREA_ACTION);
				updateVirtualRootWorkareaClients(&virtualRootSystem, &monitorSystem, &clientSystem);
				flag = true;
			}
		}
		if(flag){
			if(setVirtualRootWorkarea(&virtualRootSystem, &monitorSystem)){
				changeVirtualRootWorkarea(&virtualRootSystem);
			}
		}
		ret true;
	}
	if(property == atom._NET_WM_ICON_GEOMETRY){
		if(length != 4 * sizeof(uint32) or !value){
			ret false;
		}
		(*client).iconGeometryX = *((uint32 *)value + 0);
		(*client).iconGeometryY = *((uint32 *)value + 1);
		(*client).iconGeometryWidth = *((uint32 *)value + 2);
		(*client).iconGeometryHeight = *((uint32 *)value + 3);
		ret true;
	}
	if(property == atom._NET_WM_ICON){
		if(!length or !value){
			ret false;
		}
		if(!reallocateProperty(sizeof(uint32), length, value, "client _NET_WM_ICON pointer", &(*client).iconSize, (uint8 **)&(*client).iconStart, &(*client).iconToken)){
			ret false;
		}
		ret true;
	}
	if(property == atom._NET_WM_PID){
		if(length != sizeof(uint32) or !value){
			ret false;
		}
		(*client).pid = *(uint32 *)value;
		ret true;
	}
	if(property == atom._NET_WM_HANDLED_ICONS){
		(*client).handledIcons = true;
		ret true;
	}
	if(property == atom._NET_WM_USER_TIME){
		if(length != sizeof(uint32) or !value){
			ret false;
		}
		(*client).userTime = *(uint32 *)value;
		ret true;
	}
	if(property == atom._NET_FRAME_EXTENTS){
		resetProperty((*client).window, property, XCB_ATOM_CARDINAL, sizeof(uint32), 4, &(*client).frameExtentsLeft);
		ret true;
	}
	ret false;
}
REALLOCATEPROPERTY(){
	void *temp;
	uint32 tempToken;
	if(!length or !value or !sizeReturn or !startReturn or !tokenReturn){
		ret false;
	}
	temp = malloc(length * sizeof(uint8));
	tempToken = pushPointer(temp, label, iFree);
	if(!temp){
		ret false;
	}
	copyMemory(value, temp, length * sizeof(uint8));
	free(*startReturn);
	popPointer(*tokenReturn);
	*sizeReturn = length / itemSize;
	*startReturn = temp;
	*tokenReturn = tempToken;
	ret true;
}
UNSTORECLIENTPROPERTY(){
	if(!client or !property){
		ret false;
	}
	if(property == atom.WM_NAME){
		if((*client).propertyPreference & NAME_PROPERTY_PREFERENCE){
			ret false;
		}
		free((*client).nameStart);
		popPointer((*client).nameToken);
		(*client).nameStart = NULL;
		(*client).nameToken = 0;
		free((*client).visibleNameStart);
		popPointer((*client).visibleNameToken);
		(*client).visibleNameStart = NULL;
		(*client).visibleNameToken = 0;
		xcb_discard_reply(connection, xcb_delete_property_checked(connection, (*client).window, atom._NET_WM_VISIBLE_NAME));
		ret true;
	}
	if(property == atom.WM_ICON_NAME){
		if((*client).propertyPreference & ICON_NAME_PROPERTY_PREFERENCE){
			ret false;
		}
		free((*client).iconNameStart);
		popPointer((*client).iconNameToken);
		(*client).iconNameStart = NULL;
		(*client).iconNameToken = 0;
		free((*client).visibleIconNameStart);
		popPointer((*client).visibleIconNameToken);
		(*client).visibleIconNameStart = NULL;
		(*client).visibleIconNameToken = 0;
		xcb_discard_reply(connection, xcb_delete_property_checked(connection, (*client).window, atom._NET_WM_VISIBLE_ICON_NAME));
		ret true;
	}
	if(property == atom.WM_NORMAL_HINTS){
		(*client).normalHintsFlags = NONE_NORMAL_HINT;
		ret true;
	}
	if(property == atom.WM_HINTS){
		(*client).hintsInput = false;
		(*client).hintsInitialState = NORMAL_STATE;
		(*client).hintsIconPixmap = XCB_NONE;
		(*client).hintsIconWindow = XCB_NONE;
		(*client).hintsIconX = 0;
		(*client).hintsIconY = 0;
		(*client).hintsIconMask = XCB_NONE;
		(*client).hintsWindowGroup = XCB_NONE;
		(*client).hintsUrgency = false;
		ret true;
	}
	if(property == atom.WM_CLASS){
		free((*client).classStart);
		popPointer((*client).classToken);
		(*client).classStart = NULL;
		(*client).classToken = 0;
		ret true;
	}
	if(property == atom.WM_TRANSIENT_FOR){
		(*client).transientFor = XCB_NONE;
		if(((*client).windowType & (DIALOG_WINDOW_TYPE | NORMAL_WINDOW_TYPE)) == DIALOG_WINDOW_TYPE){
			/*! update window type. */
		}
		ret true;
	}
	if(property == atom.WM_PROTOCOLS){
		free((*client).protocolStart);
		popPointer((*client).protocolToken);
		(*client).protocol = NONE_CLIENT_PROTOCOL;
		(*client).protocolStart = NULL;
		(*client).protocolToken = 0;
		ret true;
	}
	if(property == atom.WM_COLORMAP_WINDOWS){
		free((*client).colormapWindowStart);
		popPointer((*client).colormapWindowToken);
		(*client).colormapWindowStart = NULL;
		(*client).colormapWindowToken = 0;
		ret true;
	}
	if(property == atom.WM_CLIENT_MACHINE){
		free((*client).clientMachineStart);
		popPointer((*client).clientMachineToken);
		(*client).clientMachineStart = NULL;
		(*client).clientMachineToken = 0;
		ret true;
	}
	if(property == atom.SM_CLIENT_ID){
		free((*client).clientIDStart);
		popPointer((*client).clientIDToken);
		(*client).clientIDStart = NULL;
		(*client).clientIDToken = 0;
		ret true;
	}
	if(property == atom.WM_CLIENT_LEADER){
		(*client).clientLeader = XCB_NONE;
		ret true;
	}
	if(property == atom.WM_WINDOW_ROLE){
		free((*client).windowRoleStart);
		popPointer((*client).windowRoleToken);
		(*client).windowRoleStart = NULL;
		(*client).windowRoleToken = 0;
		ret true;
	}
	if(property == atom.WM_STATE){
		if((*client).stateState != WITHDRAWN_STATE){
			resetProperty((*client).window, property, property, sizeof(uint32), 2, &(*client).stateState);
			ret false;
		}
		ret true;
	}
	if(property == atom._NET_WM_NAME){
		if(!((*client).propertyPreference & NAME_PROPERTY_PREFERENCE)){
			ret false;
		}
		free((*client).nameStart);
		popPointer((*client).nameToken);
		(*client).nameStart = NULL;
		(*client).nameToken = 0;
		free((*client).visibleNameStart);
		popPointer((*client).visibleNameToken);
		(*client).visibleNameStart = NULL;
		(*client).visibleNameToken = 0;
		xcb_discard_reply(connection, xcb_delete_property_checked(connection, (*client).window, atom._NET_WM_VISIBLE_NAME));
		ret true;
	}
	if(property == atom._NET_WM_VISIBLE_NAME){
		if((*client).visibleNameStart){
			resetProperty((*client).window, property, atom.UTF8_STRING, sizeof(uint8), (*client).visibleNameSize, (*client).visibleNameStart);
			ret false;
		}
		ret true;
	}
	if(property == atom._NET_WM_ICON_NAME){
		if(!((*client).propertyPreference & ICON_NAME_PROPERTY_PREFERENCE)){
			ret false;
		}
		free((*client).iconNameStart);
		popPointer((*client).iconNameToken);
		(*client).iconNameStart = NULL;
		(*client).iconNameToken = 0;
		free((*client).visibleIconNameStart);
		popPointer((*client).visibleIconNameToken);
		(*client).visibleIconNameStart = NULL;
		(*client).visibleIconNameToken = 0;
		xcb_discard_reply(connection, xcb_delete_property_checked(connection, (*client).window, atom._NET_WM_VISIBLE_ICON_NAME));
		ret true;
	}
	if(property == atom._NET_WM_VISIBLE_ICON_NAME){
		if((*client).visibleIconNameStart){
			resetProperty((*client).window, property, atom.UTF8_STRING, sizeof(uint8), (*client).visibleIconNameSize, (*client).visibleIconNameStart);
			ret false;
		}
		ret true;
	}
	if(property == atom._NET_WM_DESKTOP){
		if((*client).stateState != WITHDRAWN_STATE){
			resetProperty((*client).window, property, XCB_ATOM_CARDINAL, sizeof(uint32), 1, &(*client).desktop);
			ret false;
		}
		moveClientToVirtualRoot(&virtualRootSystem, &monitorSystem, &clientSystem, client, NONE_DESKTOP, true);
		ret true;
	}
	if(property == atom._NET_WM_WINDOW_TYPE){
		free((*client).windowTypeStart);
		popPointer((*client).windowTypeToken);
		(*client).windowType = NONE_WINDOW_TYPE;
		(*client).windowTypeStart = NULL;
		(*client).windowTypeToken = 0;
		if((*client).stateState != WITHDRAWN_STATE){
			setDefaultClientWindowType(&clientSystem, client);
			if(setClientAllowedActions(&clientSystem, client)){
				changeClientAllowedActions(&clientSystem, client);
			}
			if(setClientOrderType(&clientSystem, client)){
				if(restackClient(&clientSystem, client, XCB_STACK_MODE_ABOVE, XCB_NONE)){
					configureClient(&clientSystem, client);
					configureVirtualRootClient(&virtualRootSystem, &clientSystem, client);
					if(configureClientListClient(&clientListStackingSystem, &clientSystem, client)){
						changeClientListProperty(&clientListStackingSystem);
					}
				}
			}
		}
		ret true;
	}
	if(property == atom._NET_WM_STATE){
		if((*client).stateState != WITHDRAWN_STATE){
			resetProperty((*client).window, property, XCB_ATOM_ATOM, bitsof(xcb_atom_t), (*client).stateSize, (*client).stateStart);
			ret false;
		}
		free((*client).stateStart);
		popPointer((*client).stateToken);
		(*client).state = NONE_STATE;
		(*client).stateStart = NULL;
		(*client).stateToken = 0;
		ret true;
	}
	if(property == atom._NET_WM_ALLOWED_ACTIONS){
		if((*client).stateState != WITHDRAWN_STATE){
			resetProperty((*client).window, property, XCB_ATOM_ATOM, sizeof(xcb_atom_t), (*client).allowedActionSize, (*client).allowedActionStart);
			ret false;
		}
		free((*client).allowedActionStart);
		popPointer((*client).allowedActionToken);
		(*client).allowedAction = NONE_ALLOWED_ACTION;
		(*client).allowedActionStart = NULL;
		(*client).allowedActionToken = 0;
		ret true;
	}
	if(property == atom._NET_WM_STRUT){
		if(!((*client).propertyPreference & STRUT_PROPERTY_PREFERENCE)){
			if(removeVirtualRootClientWorkarea(&virtualRootSystem, &monitorSystem, &clientSystem, client)){
				updateVirtualRootStrutedClients(&virtualRootSystem, &monitorSystem, &clientSystem, client, REMOVE_UPDATE_WORKAREA_ACTION);
				updateVirtualRootWorkareaClients(&virtualRootSystem, &monitorSystem, &clientSystem);
				if(setVirtualRootWorkarea(&virtualRootSystem, &monitorSystem)){
					xcb_change_property(connection, XCB_PROP_MODE_REPLACE, (*screen).root, atom._NET_WORKAREA, XCB_ATOM_CARDINAL, bitsof(uint32), virtualRootSystem.virtualRootAllocated * 4, virtualRootSystem.workareaStart);
				}
			}
			(*client).strut = NONE_STRUT;
		}
		ret true;
	}
	if(property == atom._NET_WM_STRUT_PARTIAL){
		if((*client).propertyPreference & STRUT_PROPERTY_PREFERENCE){
			if(removeVirtualRootClientWorkarea(&virtualRootSystem, &monitorSystem, &clientSystem, client)){
				updateVirtualRootStrutedClients(&virtualRootSystem, &monitorSystem, &clientSystem, client, REMOVE_UPDATE_WORKAREA_ACTION);
				updateVirtualRootWorkareaClients(&virtualRootSystem, &monitorSystem, &clientSystem);
				if(setVirtualRootWorkarea(&virtualRootSystem, &monitorSystem)){
					xcb_change_property(connection, XCB_PROP_MODE_REPLACE, (*screen).root, atom._NET_WORKAREA, XCB_ATOM_CARDINAL, bitsof(uint32), virtualRootSystem.virtualRootAllocated * 4, virtualRootSystem.workareaStart);
				}
			}
			(*client).strut = NONE_STRUT;
		}
		ret true;
	}
	if(property == atom._NET_WM_ICON_GEOMETRY){
		(*client).iconGeometryX = 0;
		(*client).iconGeometryY = 0;
		(*client).iconGeometryWidth = 0;
		(*client).iconGeometryHeight = 0;
		ret true;
	}
	if(property == atom._NET_WM_ICON){
		free((*client).iconStart);
		popPointer((*client).iconToken);
		(*client).iconStart = NULL;
		(*client).iconToken = 0;
		ret true;
	}
	if(property == atom._NET_WM_PID){
		(*client).pid = 0;
		ret true;
	}
	if(property == atom._NET_WM_HANDLED_ICONS){
		(*client).handledIcons = false;
		ret true;
	}
	if(property == atom._NET_WM_USER_TIME){
		(*client).userTime = NONE_USER_TIME;
		ret true;
	}
	if(property == atom._NET_FRAME_EXTENTS){
		if((*client).stateState != WITHDRAWN_STATE){
			resetProperty((*client).window, property, XCB_ATOM_CARDINAL, sizeof(uint32), 4, &(*client).frameExtentsLeft);
			ret false;
		}
		(*client).frameExtentsLeft = 0;
		(*client).frameExtentsRight = 0;
		(*client).frameExtentsTop = 0;
		(*client).frameExtentsBottom = 0;
		ret true;
	}
	ret false;
}
FINDOWNEDWINDOW(){
	ret window == wmSelectionWindow or window == wmCheckWindow or window == defaultFocusWindow or window == glassWindow;
}
FINIWINDOWMANAGERSYSTEM(){
	ret true;
}
SETELEMENTPREFERENCES(){
	if(!elementPreferences){
		ret false;
	}
	(*elementPreferences).x = 0;
	(*elementPreferences).y = 0;
	(*elementPreferences).xOffset = 0;
	(*elementPreferences).yOffset = 0;
	(*elementPreferences).width = 0;
	(*elementPreferences).height = 0;
	(*elementPreferences).padding = 0;
	(*elementPreferences).margin = 0;
	(*elementPreferences).xType = NONE_NUMBER_TYPE;
	(*elementPreferences).yType = NONE_NUMBER_TYPE;
	(*elementPreferences).xOffsetType = NONE_NUMBER_TYPE;
	(*elementPreferences).yOffsetType = NONE_NUMBER_TYPE;
	(*elementPreferences).widthType = NONE_NUMBER_TYPE;
	(*elementPreferences).heightType = NONE_NUMBER_TYPE;
	(*elementPreferences).paddingType = NONE_NUMBER_TYPE;
	(*elementPreferences).marginType = NONE_NUMBER_TYPE;
	(*elementPreferences).position = NONE_POSITION;
	(*elementPreferences).horizontalAlignment = NONE_HORIZONTAL_ALIGNMENT;
	(*elementPreferences).verticalAlignment = NONE_VERTICAL_ALIGNMENT;
	(*elementPreferences).clipChildren = false;
	(*elementPreferences).cornerUsed = NONE_CORNER;
	(*elementPreferences).cornerRadius = 0;
	(*elementPreferences).foreground = 0x00000000;
	(*elementPreferences).background = 0x00000000;
	(*elementPreferences).selectedForeground = 0x00000000;
	(*elementPreferences).selectedBackground = 0x00000000;
	ret true;
}
INITWINDOWSYSTEM(){
	if(!windowSystem){
		ret false;
	}
	(*windowSystem).circlePixmap = XCB_NONE;
	(*windowSystem).windowInfoSize = 0;
	(*windowSystem).windowInfoStart = NULL;
	(*windowSystem).windowInfoToken = 0;
	(*windowSystem).mapped = false;
	ret true;
}
CREATEWINDOWCIRCLEPIXMAP(){
	Image image;
	xcb_gcontext_t gc;
	struct{
		uint32 /*-*/ generateExpose;
	} valueList;
	if(!windowSystem){
		ret false;
	}
	if(!radius){
		if((*windowSystem).circlePixmap){
			xcb_free_pixmap(connection, (*windowSystem).circlePixmap);
			(*windowSystem).circlePixmap = XCB_NONE;
		}
		ret true;
	}
	if(!createCircle(radius, foreground, background, &image)){
		ret false;
	}
	if((*windowSystem).circlePixmap){
		xcb_free_pixmap(connection, (*windowSystem).circlePixmap);
		(*windowSystem).circlePixmap = XCB_NONE;
	}
	gc = xcb_generate_id(connection);
	valueList.generateExpose = false;
	(*windowSystem).circlePixmap = xcb_generate_id(connection);
	xcb_create_pixmap(connection, depth, (*windowSystem).circlePixmap, (*screen).root, image.width, image.height);
	xcb_create_gc(connection, gc, (*windowSystem).circlePixmap, XCB_GC_GRAPHICS_EXPOSURES, &valueList);
	xcb_put_image(connection, XCB_IMAGE_FORMAT_Z_PIXMAP, (*windowSystem).circlePixmap, gc, image.width, image.height, 0, 0, 0, depth, image.dataSize, image.dataStart);
	xcb_free_gc(connection, gc);
	free(image.dataStart);
	popPointer(image.dataToken);
	ret true;
}
CREATEWINDOWS(){
	WindowInfo *current;
	WindowInfo *wall;
	struct{
		uint32 /*---------*/ backgroundColor;
		uint32 /*---------*/ borderColor;
		uint32 /*---------*/ overrideRedirect;
		uint32 /*---------*/ eventMask;
		xcb_colormap_t /*-*/ colormap;
	} windowValueList;
	struct{
		uint32 /*---------*/ generateExpose;
	} gcValueList;
	if(!windowSystem or !amount){
		ret false;
	}
	destroyWindows(windowSystem);
	free((*windowSystem).windowInfoStart);
	popPointer((*windowSystem).windowInfoToken);
	(*windowSystem).windowInfoSize = amount;
	(*windowSystem).windowInfoStart = malloc((*windowSystem).windowInfoSize * sizeof(WindowInfo));
	(*windowSystem).windowInfoToken = pushPointer((*windowSystem).windowInfoStart, "window info pointer", iFree);
	if(!(*windowSystem).windowInfoStart){
		printTitledError("memory allocation error", "could not allocate memory for windows");
		(*windowSystem).windowInfoSize = 0;
		ret false;
	}
	current = (*windowSystem).windowInfoStart;
	wall = current + (*windowSystem).windowInfoSize;
	windowValueList.backgroundColor = 0x00000000;
	windowValueList.borderColor = 0x00000000;
	windowValueList.overrideRedirect = overrideRedirect;
	windowValueList.eventMask = eventMask;
	windowValueList.colormap = colormap;
	gcValueList.generateExpose = false;
	jmp createWindowLoop;
	createWindowLoop:{
		if(current < wall){
			(*current).window = xcb_generate_id(connection);
			(*current).bufferPixmap = xcb_generate_id(connection);
			(*current).pixmap = xcb_generate_id(connection);
			(*current).gc = xcb_generate_id(connection);
			(*current).x = 0;
			(*current).y = 0;
			(*current).width = 0;
			(*current).height = 0;
			(*current).mapped = false;
			xcb_create_window(connection, depth, (*current).window, (*screen).root, 0, 0, 1, 1, 0, XCB_WINDOW_CLASS_INPUT_OUTPUT, visual, XCB_CW_BACK_PIXEL | XCB_CW_BORDER_PIXEL | XCB_CW_OVERRIDE_REDIRECT | XCB_CW_EVENT_MASK | XCB_CW_COLORMAP, &windowValueList);
			xcb_create_pixmap(connection, depth, (*current).bufferPixmap, (*current).window, screenWidthInPixels, screenHeightInPixels);
			xcb_create_pixmap(connection, depth, (*current).pixmap, (*current).window, screenWidthInPixels, screenHeightInPixels);
			xcb_create_gc(connection, (*current).gc, (*current).pixmap, XCB_GC_GRAPHICS_EXPOSURES, &gcValueList);
			xcb_change_window_attributes(connection, (*current).window, XCB_CW_BACK_PIXMAP, &(*current).pixmap);
			inc current;
			jmp createWindowLoop;
		}
		ret true;
	}
}
MAPWINDOWS(){
	WindowInfo *current;
	WindowInfo *wall;
	Monitor *previousMonitor;
	Monitor *monitorCurrent;
	Monitor *monitorWall;
	xcb_timestamp_t userTime;
	struct{
		int32 /*--*/ x;
		int32 /*--*/ y;
		uint32 /*-*/ width;
		uint32 /*-*/ height;
		uint32 /*-*/ stackMode;
	} valueList;
	if(!windowSystem or !(*windowSystem).windowInfoSize or (*windowSystem).mapped or !monitorSystem or !(*monitorSystem).size or !windowPreferences or !whichMonitor or whichMonitor > ALL_WHICH_MONITOR){
		ret false;
	}
	current = (*windowSystem).windowInfoStart;
	wall = current + (*windowSystem).windowInfoSize;
	previousMonitor = NULL;
	monitorCurrent = (*monitorSystem).start;
	monitorWall = monitorCurrent + (*monitorSystem).size - 1;
	valueList.stackMode = XCB_STACK_MODE_ABOVE;
	userTime = getTimestamp();
	jmp configureWindowLoop;
	configureWindowLoop:{
		if(current < wall){
			Monitor *monitor;
			ElementRectangle rectangle;
			if(!(monitor = getWhichMonitor(monitorSystem, whichMonitor))){
				monitor = monitorCurrent;
			}
			(*current).mapped = false;
			if(monitor != previousMonitor and getRectangle(monitor, NULL, windowPreferences, &rectangle) and rectangle.width and rectangle.height){
				valueList.x = rectangle.x;
				valueList.y = rectangle.y;
				valueList.width = rectangle.width;
				valueList.height = rectangle.height;
				if(rectangle.x != (*current).x or rectangle.y != (*current).y or rectangle.width != (*current).width or rectangle.height != (*current).height){
					(*current).x = rectangle.x;
					(*current).y = rectangle.y;
					(*current).width = rectangle.width;
					(*current).height = rectangle.height;
					xcb_configure_window(connection, (*current).window, XCB_CONFIG_WINDOW_X | XCB_CONFIG_WINDOW_Y | XCB_CONFIG_WINDOW_WIDTH | XCB_CONFIG_WINDOW_HEIGHT | XCB_CONFIG_WINDOW_STACK_MODE, &valueList);
					setWindowProperties(current, windowPreferences, valueList.x, valueList.y, valueList.width, valueList.height);
				}
				drawWindow(windowSystem, current, windowPreferences, NULL, &rectangle);
				xcb_change_property(connection, XCB_PROP_MODE_REPLACE, (*current).window, atom._NET_WM_USER_TIME, XCB_ATOM_CARDINAL, bitsof(uint32), 1, &userTime);
				(*current).mapped = true;
			}
			previousMonitor = monitor;
			if(monitorCurrent < monitorWall){
				inc monitorCurrent;
			}
			inc current;
			jmp configureWindowLoop;
		}
		current = (*windowSystem).windowInfoStart;
		jmp mapWindowLoop;
	}
	mapWindowLoop:{
		if(current < wall){
			if((*current).mapped){
				xcb_map_window(connection, (*current).window);
			}
			inc current;
			jmp mapWindowLoop;
		}
		(*windowSystem).mapped = true;
		ret true;
	}
}
CONFIGUREWINDOWS(){
	WindowInfo *current;
	WindowInfo *wall;
	Monitor *previousMonitor;
	Monitor *monitorCurrent;
	Monitor *monitorWall;
	struct{
		int32 /*--*/ x;
		int32 /*--*/ y;
		uint32 /*-*/ width;
		uint32 /*-*/ height;
	} valueList;
	if(!windowSystem or !(*windowSystem).windowInfoSize or !(*windowSystem).mapped or !monitorSystem or !(*monitorSystem).size or !windowPreferences or !whichMonitor or whichMonitor > ALL_WHICH_MONITOR){
		ret false;
	}
	current = (*windowSystem).windowInfoStart;
	wall = current + (*windowSystem).windowInfoSize;
	previousMonitor = NULL;
	monitorCurrent = (*monitorSystem).start;
	monitorWall = monitorCurrent + (*monitorSystem).size - 1;
	jmp configureWindowLoop;
	configureWindowLoop:{
		if(current < wall){
			Monitor *monitor;
			ElementRectangle rectangle;
			if(!(monitor = getWhichMonitor(monitorSystem, whichMonitor))){
				monitor = monitorCurrent;
			}
			if(monitor != previousMonitor and getRectangle(monitor, NULL, windowPreferences, &rectangle) and rectangle.width and rectangle.height){
				valueList.x = rectangle.x;
				valueList.y = rectangle.y;
				valueList.width = rectangle.width;
				valueList.height = rectangle.height;
				if(rectangle.x != (*current).x or rectangle.y != (*current).y or rectangle.width != (*current).width or rectangle.height != (*current).height){
					(*current).x = rectangle.x;
					(*current).y = rectangle.y;
					(*current).width = rectangle.width;
					(*current).height = rectangle.height;
					xcb_configure_window(connection, (*current).window, XCB_CONFIG_WINDOW_X | XCB_CONFIG_WINDOW_Y | XCB_CONFIG_WINDOW_WIDTH | XCB_CONFIG_WINDOW_HEIGHT, &valueList);
					setWindowProperties(current, windowPreferences, valueList.x, valueList.y, valueList.width, valueList.height);
				}
				drawWindow(windowSystem, current, windowPreferences, NULL, &rectangle);
			}
			previousMonitor = monitor;
			if(monitorCurrent < monitorWall){
				inc monitorCurrent;
			}
			inc current;
			jmp configureWindowLoop;
		}
		current = (*windowSystem).windowInfoStart;
		jmp mapWindowLoop;
	}
	mapWindowLoop:{
		if(current < wall){
			if((*current).mapped){
				xcb_map_window(connection, (*current).window);
			}
			inc current;
			jmp mapWindowLoop;
		}
		(*windowSystem).mapped = true;
		ret true;
	}
}
DRAWWINDOWS(){
	WindowInfo *current;
	WindowInfo *wall;
	if(!windowSystem or !(*windowSystem).windowInfoSize or !monitorSystem or !windowPreferences){
		ret false;
	}
	current = (*windowSystem).windowInfoStart;
	wall = current + (*windowSystem).windowInfoSize;
	jmp drawWindowLoop;
	drawWindowLoop:{
		if(current < wall){
			if((*current).mapped){
				drawWindow(windowSystem, current, windowPreferences, findWindowMonitor(monitorSystem, (*current).window), NULL);
			}
			inc current;
			jmp drawWindowLoop;
		}
		ret true;
	}
}
SETWINDOWPROPERTIES(){
	xcb_window_t window;
	uint32 desktop;
	pid_t pid;
	char hostname[256];
	xcb_atom_t type[1];
	xcb_atom_t state[1];
	struct{
		uint32 /*-*/ flags;
		int32 /*--*/ x;
		int32 /*--*/ y;
		int32 /*--*/ width;
		int32 /*--*/ height;
		int32 /*--*/ minWidth;
		int32 /*--*/ minHeight;
		int32 /*--*/ maxWidth;
		int32 /*--*/ maxHeight;
		int32 /*--*/ widthInc;
		int32 /*--*/ heightInc;
		int32 /*--*/ minAspectNumerator;
		int32 /*--*/ minAspectDenominarator;
		int32 /*--*/ maxAspectNumerator;
		int32 /*--*/ maxAspectDenominarator;
		int32 /*--*/ baseWidth;
		int32 /*--*/ baseHeight;
		int32 /*--*/ winGravity;
	} normalHints;
	struct{
		uint32 /*-*/ flags;
		uint32 /*-*/ input;
		uint32 /*-*/ initialState;
	} hints;
	struct{
		uint32 /*-*/ left;
		uint32 /*-*/ right;
		uint32 /*-*/ top;
		uint32 /*-*/ bottom;
		uint32 /*-*/ leftStartY;
		uint32 /*-*/ leftEndY;
		uint32 /*-*/ rightStartY;
		uint32 /*-*/ rightEndY;
		uint32 /*-*/ topStartX;
		uint32 /*-*/ topEndX;
		uint32 /*-*/ bottomStartX;
		uint32 /*-*/ bottomEndX;
	} strut;
	if(!windowInfo or !(*windowInfo).window){
		ret false;
	}
	window = (*windowInfo).window;
	desktop = 0xFFFFFFFF;
	pid = getpid();
	*hostname = '\0';
	if(gethostname(hostname, countof(hostname)) != GETHOSTNAME_SUCCESS){
		printTitledError("get hostname error", "could not get hostname");
	}
	*(type + 0) = atom._NET_WM_WINDOW_TYPE_NORMAL;
	*(state + 0) = XCB_NONE;
	normalHints.flags = USER_POSITION_NORMAL_HINT | USER_SIZE_NORMAL_HINT | PROGRAM_MINIMUM_SIZE_NORMAL_HINT | PROGRAM_MAXIMUM_SIZE_NORMAL_HINT | PROGRAM_RESIZE_INCREMENT_NORMAL_HINT | PROGRAM_ASPECT_NORMAL_HINT | PROGRAM_BASE_SIZE_NORMAL_HINT | PROGRAM_WINDOW_GRAVITY_NORMAL_HINT;
	normalHints.x = x;
	normalHints.y = y;
	normalHints.width = width;
	normalHints.height = height;
	normalHints.minWidth = width;
	normalHints.minHeight = height;
	normalHints.maxWidth = width;
	normalHints.maxHeight = height;
	normalHints.baseWidth = width;
	normalHints.baseHeight = height;
	normalHints.widthInc = 0;
	normalHints.heightInc = 0;
	normalHints.minAspectNumerator = 1;
	normalHints.minAspectDenominarator = 1;
	normalHints.maxAspectNumerator = 1;
	normalHints.maxAspectDenominarator = 1;
	normalHints.winGravity = XCB_GRAVITY_NORTH_WEST;
	hints.flags = INPUT_HINT | STATE_HINT;
	hints.input = false;
	hints.initialState = NORMAL_STATE;
	if((*windowPreferences).position){
		strut.left = 0;
		strut.right = 0;
		strut.top = 0;
		strut.bottom = 0;
		strut.leftStartY = 0;
		strut.leftEndY = 0;
		strut.rightStartY = 0;
		strut.rightEndY = 0;
		strut.topStartX = 0;
		strut.topEndX = 0;
		strut.bottomStartX = 0;
		strut.bottomEndX = 0;
		switch((*windowPreferences).position){
			to TOP_POSITION:{
				strut.top = height;
				strut.topStartX = x;
				strut.topEndX = x + width;
				brk;
			}
			to BOTTOM_POSITION:{
				strut.bottom = height;
				strut.bottomStartX = x;
				strut.bottomEndX = x + width;
				brk;
			}
			to LEFT_POSITION:{
				strut.left = width;
				strut.leftStartY = y;
				strut.leftEndY = y + height;
				brk;
			}
			to RIGHT_POSITION:{
				strut.right = width;
				strut.rightStartY = y;
				strut.rightEndY = y + height;
				brk;
			}
			off:{
				brk;
			}
		}
	}
	xcb_change_property(connection, XCB_PROP_MODE_REPLACE, window, atom.WM_NAME, XCB_ATOM_STRING, bitsof(uint8), lengthof(PROGRAM_NAME), PROGRAM_NAME);
	xcb_change_property(connection, XCB_PROP_MODE_REPLACE, window, atom.WM_ICON_NAME, XCB_ATOM_STRING, bitsof(uint8), lengthof(PROGRAM_NAME), PROGRAM_NAME);
	xcb_change_property(connection, XCB_PROP_MODE_REPLACE, window, atom.WM_NORMAL_HINTS, atom.WM_SIZE_HINTS, bitsof(uint32), sizeof(normalHints) / sizeof(uint32), &normalHints);
	xcb_change_property(connection, XCB_PROP_MODE_REPLACE, window, atom.WM_HINTS, atom.WM_HINTS, bitsof(uint32), sizeof(hints) / sizeof(uint32), &hints);
	xcb_change_property(connection, XCB_PROP_MODE_REPLACE, window, atom.WM_CLASS, XCB_ATOM_STRING, bitsof(uint8), lengthof(PROGRAM_NAME "\0" PROGRAM_NAME "\0"), PROGRAM_NAME "\0" PROGRAM_NAME "\0");
	xcb_change_property(connection, XCB_PROP_MODE_REPLACE, window, atom.WM_CLIENT_MACHINE, XCB_ATOM_STRING, bitsof(uint8), findStringLength(hostname), hostname);
	if(localeName){
		xcb_change_property(connection, XCB_PROP_MODE_REPLACE, window, atom.WM_LOCALE_NAME, XCB_ATOM_STRING, bitsof(uint8), findStringLength(localeName), localeName);
	}
	xcb_change_property(connection, XCB_PROP_MODE_REPLACE, window, atom._NET_WM_NAME, atom.UTF8_STRING, bitsof(uint8), lengthof(PROGRAM_NAME), PROGRAM_NAME);
	xcb_change_property(connection, XCB_PROP_MODE_REPLACE, window, atom._NET_WM_ICON_NAME, atom.UTF8_STRING, bitsof(uint8), lengthof(PROGRAM_NAME), PROGRAM_NAME);
	if(desktop == 0xFFFFFFFF){
		xcb_change_property(connection, XCB_PROP_MODE_REPLACE, window, atom._NET_WM_DESKTOP, XCB_ATOM_CARDINAL, bitsof(uint32), 1, &desktop);
	}
	xcb_change_property(connection, XCB_PROP_MODE_REPLACE, window, atom._NET_WM_WINDOW_TYPE, XCB_ATOM_ATOM, bitsof(uint32), countof(type), type);
	if(*state){
		xcb_change_property(connection, XCB_PROP_MODE_REPLACE, window, atom._NET_WM_STATE, XCB_ATOM_ATOM, bitsof(uint32), countof(state), state);
	}
	if((*windowPreferences).position){
		xcb_change_property(connection, XCB_PROP_MODE_REPLACE, window, atom._NET_WM_STRUT, XCB_ATOM_CARDINAL, bitsof(uint32), 4, &strut);
		xcb_change_property(connection, XCB_PROP_MODE_REPLACE, window, atom._NET_WM_STRUT_PARTIAL, XCB_ATOM_CARDINAL, bitsof(uint32), 12, &strut);
	}
	/*! xcb_change_property(connection, XCB_PROP_MODE_REPLACE, window, atom._NET_WM_ICON, , , , ); */
	xcb_change_property(connection, XCB_PROP_MODE_REPLACE, window, atom._NET_WM_PID, XCB_ATOM_CARDINAL, bitsof(uint32), 1, &pid);
	ret true;
}
DRAWWINDOW(){
	ElementRectangle _windowRectangle;
	if(!windowSystem or !windowInfo or !windowPreferences or (!monitor and !windowRectangle)){
		ret false;
	}
	jmp getRectangles;
	getRectangles:{
		if(!windowRectangle){
			windowRectangle = &_windowRectangle;
			if(!getRectangle(monitor, NULL, windowPreferences, windowRectangle) or !(*windowRectangle).width or !(*windowRectangle).height){
				ret false;
			}
		}
		jmp drawWindow;
	}
	drawWindow:{
		const xcb_pixmap_t circlePixmap = (*windowSystem).circlePixmap;
		const xcb_pixmap_t pixmap = (*windowInfo).bufferPixmap;
		const xcb_gcontext_t gc = (*windowInfo).gc;
		const uint width = (*windowRectangle).width;
		const uint height = (*windowRectangle).height;
		fillDrawable(pixmap, gc, 0, 0, width, height, (*windowPreferences).background);
		if(circlePixmap){
			const uint8 cornerUsed = (*windowPreferences).cornerUsed;
			const uint radius = (*windowPreferences).cornerRadius;
			const uint size = radius + 1;
			if(cornerUsed & TOP_LEFT_CORNER) /*-----*/ xcb_copy_area(connection, circlePixmap, pixmap, gc, 0     , 0     , 0           , 0            , size, size);
			if(cornerUsed & TOP_RIGHT_CORNER) /*----*/ xcb_copy_area(connection, circlePixmap, pixmap, gc, radius, 0     , width - size, 0            , size, size);
			if(cornerUsed & BOTTOM_LEFT_CORNER) /*--*/ xcb_copy_area(connection, circlePixmap, pixmap, gc, 0     , radius, 0           , height - size, size, size);
			if(cornerUsed & BOTTOM_RIGHT_CORNER) /*-*/ xcb_copy_area(connection, circlePixmap, pixmap, gc, radius, radius, width - size, height - size, size, size);
		}
		jmp drawWindowElements;
	}
	drawWindowElements:{
		jmp clearArea;
	}
	clearArea:{
		xcb_copy_area(connection, (*windowInfo).bufferPixmap, (*windowInfo).pixmap, (*windowInfo).gc, 0, 0, 0, 0, (*windowInfo).width, (*windowInfo).height);
		if((*windowSystem).mapped){
			xcb_clear_area(connection, false, (*windowInfo).window, 0, 0, 0, 0);
		}
		ret true;
	}
}
UNMAPWINDOWS(){
	WindowInfo *current;
	WindowInfo *wall;
	if(!windowSystem or !(*windowSystem).windowInfoSize or !(*windowSystem).mapped){
		ret false;
	}
	current = (*windowSystem).windowInfoStart;
	wall = current + (*windowSystem).windowInfoSize;
	jmp unmapWindowLoop;
	unmapWindowLoop:{
		if(current < wall){
			if((*current).mapped){
				xcb_unmap_window(connection, (*current).window);
				(*current).mapped = false;
			}
			inc current;
			jmp unmapWindowLoop;
		}
		(*windowSystem).mapped = false;
		ret true;
	}
}
DESTROYWINDOWS(){
	WindowInfo *current;
	WindowInfo *wall;
	if(!windowSystem or !(*windowSystem).windowInfoSize){
		ret false;
	}
	unmapWindows(windowSystem);
	current = (*windowSystem).windowInfoStart;
	wall = current + (*windowSystem).windowInfoSize;
	jmp destroyWindowLoop;
	destroyWindowLoop:{
		if(current < wall){
			xcb_free_gc(connection, (*current).gc);
			xcb_free_pixmap(connection, (*current).pixmap);
			xcb_free_pixmap(connection, (*current).bufferPixmap);
			xcb_destroy_window(connection, (*current).window);
			inc current;
			jmp destroyWindowLoop;
		}
		ret true;
	}
}
GETRECTANGLE(){
	Monitor *monitor;
	int x;
	int y;
	int xOffset;
	int yOffset;
	uint width;
	uint height;
	uint horizontalPadding;
	uint verticalPadding;
	uint horizontalMargin;
	uint verticalMargin;
	int parentX;
	int parentY;
	uint parentWidth;
	uint parentHeight;
	if(_monitor){
		monitor = _monitor;
		parentX = (*monitor).leftX;
		parentY = (*monitor).topY;
		parentWidth = (*monitor).width;
		parentHeight = (*monitor).height;
	}elif(parentRectangle){
		monitor = (*parentRectangle).monitor;
		parentX = 0;
		parentY = 0;
		parentWidth = (*parentRectangle).width;
		parentHeight = (*parentRectangle).height;
		if(!monitor){
			ret false;
		}
	}else{
		ret false;
	}
	x = getTypedNumber((*preferences).x, (*preferences).xType, HORIZONTAL_AXIS, parentWidth, monitor);
	y = getTypedNumber((*preferences).y, (*preferences).yType, VERTICAL_AXIS, parentHeight, monitor);
	xOffset = getTypedNumber((*preferences).xOffset, (*preferences).xOffsetType, HORIZONTAL_AXIS, parentWidth, monitor);
	yOffset = getTypedNumber((*preferences).yOffset, (*preferences).yOffsetType, VERTICAL_AXIS, parentHeight, monitor);
	width = getTypedNumber((*preferences).width, (*preferences).widthType, HORIZONTAL_AXIS, parentWidth, monitor);
	height = getTypedNumber((*preferences).height, (*preferences).heightType, VERTICAL_AXIS, parentHeight, monitor);
	horizontalPadding = getTypedNumber((*preferences).padding, (*preferences).paddingType, HORIZONTAL_AXIS, parentWidth, monitor);
	verticalPadding = getTypedNumber((*preferences).padding, (*preferences).paddingType, VERTICAL_AXIS, parentHeight, monitor);
	horizontalMargin = getTypedNumber((*preferences).margin, (*preferences).marginType, HORIZONTAL_AXIS, parentWidth, monitor);
	verticalMargin = getTypedNumber((*preferences).margin, (*preferences).marginType, VERTICAL_AXIS, parentHeight, monitor);
	if((*preferences).position){
		if((*preferences).position < LEFT_POSITION){
			width = (*monitor).width;
		}
		if((*preferences).position >= LEFT_POSITION){
			height = (*monitor).height;
		}
	}
	if((*preferences).position == LEFT_POSITION){
		x = parentX + 0 * (parentWidth - width) / 2;
	}elif((*preferences).position == RIGHT_POSITION){
		x = parentX + 2 * (parentWidth - width) / 2;
	}elif((*preferences).horizontalAlignment){
		x = parentX + ((*preferences).horizontalAlignment - 1) * (parentWidth - width) / 2;
	}
	if((*preferences).position == TOP_POSITION){
		y = parentY + 0 * (parentHeight - height) / 2;
	}elif((*preferences).position == BOTTOM_POSITION){
		y = parentY + 2 * (parentHeight - height) / 2;
	}elif((*preferences).verticalAlignment){
		y = parentY + ((*preferences).verticalAlignment - 1) * (parentHeight - height) / 2;
	}
	(*rectangle).monitor = monitor;
	(*rectangle).x = x + xOffset;
	(*rectangle).y = y + yOffset;
	(*rectangle).width = width;
	(*rectangle).height = height;
	(*rectangle).horizontalPadding = horizontalPadding;
	(*rectangle).verticalPadding = verticalPadding;
	(*rectangle).horizontalMargin = horizontalMargin;
	(*rectangle).verticalMargin = verticalMargin;
	ret true;
}
GETTYPEDNUMBER(){
	switch(type){
		to INTEGER_NUMBER_TYPE: /*----*/ ret number;
		to PERCENTAGE_NUMBER_TYPE: /*-*/ ret size * number / 100;
		to MILLIMETER_NUMBER_TYPE: /*-*/ jmp matchMillimeterType;
		off: /*-----------------------*/ ret 0;
	}
	matchMillimeterType: switch(axis){
		to HORIZONTAL_AXIS: /*--------*/ ret (*monitor).width * number / (*monitor).millimeterWidth;
		to VERTICAL_AXIS: /*----------*/ ret (*monitor).height * number / (*monitor).millimeterHeight;
		off: /*-----------------------*/ ret 0;
	}
}
FINDWINDOW(){
	WindowInfo *current;
	WindowInfo *wall;
	if(!windowSystem or !(*windowSystem).windowInfoSize or !window){
		ret false;
	}
	current = (*windowSystem).windowInfoStart;
	wall = current + (*windowSystem).windowInfoSize;
	jmp findWindowLoop;
	findWindowLoop:{
		if(current < wall){
			if((*current).window == window){
				ret true;
			}
			inc current;
			jmp findWindowLoop;
		}
		ret false;
	}
}
FINIWINDOWSYSTEM(){
	if(!windowSystem){
		ret false;
	}
	destroyWindows(windowSystem);
	free((*windowSystem).windowInfoStart);
	popPointer((*windowSystem).windowInfoToken);
	(*windowSystem).windowInfoSize = 0;
	(*windowSystem).windowInfoStart = NULL;
	(*windowSystem).windowInfoToken = 0;
	(*windowSystem).mapped = false;
	if((*windowSystem).circlePixmap){
		xcb_free_pixmap(connection, (*windowSystem).circlePixmap);
		(*windowSystem).circlePixmap = XCB_NONE;
	}
	ret true;
}
INITSLEEPTHREADSYSTEM(){
	if(!sleepThreadSystem){
		ret false;
	}
	(*sleepThreadSystem).risingOperation = NULL;
	(*sleepThreadSystem).risingOperationArgument = NULL;
	(*sleepThreadSystem).fallingOperation = NULL;
	(*sleepThreadSystem).fallingOperationArgument = NULL;
	(*sleepThreadSystem).seconds = 0;
	(*sleepThreadSystem).nanoseconds = 0;
	(*sleepThreadSystem).loopOperation = false;
	(*sleepThreadSystem).restartTimer = false;
	(*sleepThreadSystem).running = false;
	(*sleepThreadSystem).quittingThread = false;
	(*sleepThreadSystem).mutexCreated = false;
	(*sleepThreadSystem).condCreated = false;
	(*sleepThreadSystem).threadCreated = false;
	ret true;
}
SETSLEEPTHREADOPERATION(){
	if(!sleepThreadSystem){
		ret false;
	}
	(*sleepThreadSystem).risingOperation = risingOperation;
	(*sleepThreadSystem).risingOperationArgument = risingOperationArgument;
	(*sleepThreadSystem).fallingOperation = fallingOperation;
	(*sleepThreadSystem).fallingOperationArgument = fallingOperationArgument;
	(*sleepThreadSystem).loopOperation = loopOperation;
	(*sleepThreadSystem).restartTimer = restartTimer;
	ret true;
}
SETSLEEPTHREADSLEEPTIME(){
	if(!sleepThreadSystem){
		ret false;
	}
	(*sleepThreadSystem).seconds = milliseconds / 1000;
	(*sleepThreadSystem).nanoseconds = (milliseconds - (*sleepThreadSystem).seconds * 1000) * 1000000;
	ret true;
}
BOOTSLEEPTHREAD(){
	if(!sleepThreadSystem or (*sleepThreadSystem).threadCreated or (!(*sleepThreadSystem).risingOperation and !(*sleepThreadSystem).fallingOperation)){
		ret false;
	}
	if(!(*sleepThreadSystem).mutexCreated){
		(*sleepThreadSystem).mutexCreated = pthread_mutex_init(&(*sleepThreadSystem).mutex, NULL) == PTHREAD_MUTEX_INIT_SUCCESS;
		if(!(*sleepThreadSystem).mutexCreated){
			printTitledError("pthread error", "could not init sleep operation mutex");
			ret false;
		}
	}
	if(!(*sleepThreadSystem).condCreated){
		(*sleepThreadSystem).condCreated = pthread_cond_init(&(*sleepThreadSystem).cond, NULL) == PTHREAD_COND_INIT_SUCCESS;
		if(!(*sleepThreadSystem).condCreated){
			printTitledError("pthread error", "could not init sleep operation cond");
			ret false;
		}
	}
	(*sleepThreadSystem).threadCreated = pthread_create(&(*sleepThreadSystem).thread, NULL, &sleepThreadMain, sleepThreadSystem) == PTHREAD_CREATE_SUCCESS;
	if(!(*sleepThreadSystem).threadCreated){
		printTitledError("pthread error", "could not create sleep operation thread");
		ret false;
	}
	ret true;
}
SIGNALSLEEPTHREAD(){
	if(!sleepThreadSystem or !(*sleepThreadSystem).mutexCreated or !(*sleepThreadSystem).condCreated or !(*sleepThreadSystem).threadCreated or !(*sleepThreadSystem).running){
		ret false;
	}
	if(pthread_mutex_lock(&(*sleepThreadSystem).mutex) != PTHREAD_MUTEX_LOCK_SUCCESS){
		printTitledError("pthread error", "could not lock sleep operation mutex");
	}
	if(pthread_cond_signal(&(*sleepThreadSystem).cond) != PTHREAD_COND_SIGNAL_SUCCESS){
		printTitledError("pthread error", "could not signal sleep operation thread");
	}
	if(pthread_mutex_unlock(&(*sleepThreadSystem).mutex) != PTHREAD_MUTEX_UNLOCK_SUCCESS){
		printTitledError("pthread error", "could not unlock sleep operation mutex");
	}
	ret true;
}
SLEEPTHREADMAIN(){
	SleepThreadSystem *const sleepThreadSystem = arg;
	struct timespec ts;
	int waitReturn;
	bool error;
	if(!sleepThreadSystem){
		ret NULL;
	}
	error = false;
	if(pthread_mutex_lock(&(*sleepThreadSystem).mutex) != PTHREAD_MUTEX_LOCK_SUCCESS){
		printTitledError("pthread error", "could not lock sleep operation mutex");
	}
	(*sleepThreadSystem).running = true;
	jmp waitIndefinitely;
	waitIndefinitely:{
		if(pthread_cond_wait(&(*sleepThreadSystem).cond, &(*sleepThreadSystem).mutex) != PTHREAD_COND_WAIT_SUCCESS){
			printTitledError("pthread error", "could not wait sleep operation mutex");
		}
		if((*sleepThreadSystem).quittingThread){
			jmp emergencyExit;
		}
		jmp conductRisingOperation;
	}
	conductRisingOperation:{
		if(globalsLockCreated and pthread_rwlock_rdlock(&globalsLock) != PTHREAD_RWLOCK_RDLOCK_SUCCESS){
			printTitledError("pthread error", "could not lock globals read lock");
		}
		clock_gettime(CLOCK_REALTIME, &ts);
		ts.tv_sec += (*sleepThreadSystem).seconds;
		ts.tv_nsec += (*sleepThreadSystem).nanoseconds;
		if((*sleepThreadSystem).risingOperation){
			error = !(*(*sleepThreadSystem).risingOperation)((*sleepThreadSystem).risingOperationArgument);
		}
		if(globalsLockCreated and pthread_rwlock_unlock(&globalsLock) != PTHREAD_RWLOCK_UNLOCK_SUCCESS){
			printTitledError("pthread error", "could not unlock globals read lock");
		}
		if(error){
			error = false;
			jmp waitIndefinitely;
		}
		jmp waitUntilTimedOut;
	}
	waitUntilTimedOut:{
		if((*sleepThreadSystem).quittingThread){
			jmp emergencyExit;
		}
		waitReturn = pthread_cond_timedwait(&(*sleepThreadSystem).cond, &(*sleepThreadSystem).mutex, &ts);
		if((*sleepThreadSystem).quittingThread){
			jmp emergencyExit;
		}
		if(waitReturn != ETIMEDOUT){
			if(waitReturn != PTHREAD_COND_TIMEDWAIT_SUCCESS){
				printTitledError("pthread error", "could not wait sleep operation mutex");
			}
			if((*sleepThreadSystem).restartTimer){
				if(globalsLockCreated and pthread_rwlock_rdlock(&globalsLock) != PTHREAD_RWLOCK_RDLOCK_SUCCESS){
					printTitledError("pthread error", "could not lock globals read lock");
				}
				clock_gettime(CLOCK_REALTIME, &ts);
				ts.tv_sec += (*sleepThreadSystem).seconds;
				ts.tv_nsec += (*sleepThreadSystem).nanoseconds;
				if(globalsLockCreated and pthread_rwlock_unlock(&globalsLock) != PTHREAD_RWLOCK_UNLOCK_SUCCESS){
					printTitledError("pthread error", "could not unlock globals read lock");
				}
			}
			jmp waitUntilTimedOut;
		}
		jmp conductFallingOperation;
	}
	conductFallingOperation:{
		if(globalsLockCreated and pthread_rwlock_rdlock(&globalsLock) != PTHREAD_RWLOCK_RDLOCK_SUCCESS){
			printTitledError("pthread error", "could not lock globals read lock");
		}
		if((*sleepThreadSystem).fallingOperation){
			error = !(*(*sleepThreadSystem).fallingOperation)((*sleepThreadSystem).fallingOperationArgument);
		}
		if(globalsLockCreated and pthread_rwlock_unlock(&globalsLock) != PTHREAD_RWLOCK_UNLOCK_SUCCESS){
			printTitledError("pthread error", "could not unlock globals read lock");
		}
		if(error){
			error = false;
			jmp waitIndefinitely;
		}
		jmp checkMode;
	}
	checkMode:{
		if((*sleepThreadSystem).loopOperation){
			jmp conductRisingOperation;
		}
		jmp waitIndefinitely;
	}
	emergencyExit:{
		(*sleepThreadSystem).threadCreated = false;
		(*sleepThreadSystem).running = false;
		if(pthread_mutex_unlock(&(*sleepThreadSystem).mutex) != PTHREAD_MUTEX_UNLOCK_SUCCESS){
			printTitledError("pthread error", "could not unlock sleep operation mutex");
		}
		ret NULL;
	}
}
QUITSLEEPTHREAD(){
	if(!sleepThreadSystem or (!(*sleepThreadSystem).threadCreated and !(*sleepThreadSystem).condCreated and !(*sleepThreadSystem).mutexCreated)){
		ret false;
	}
	(*sleepThreadSystem).quittingThread = true;
	if((*sleepThreadSystem).threadCreated){
		if((*sleepThreadSystem).mutexCreated and (*sleepThreadSystem).condCreated){
			if(pthread_mutex_lock(&(*sleepThreadSystem).mutex) != PTHREAD_MUTEX_LOCK_SUCCESS){
				printTitledError("pthread error", "could not lock sleep operation mutex");
			}
			if(pthread_cond_signal(&(*sleepThreadSystem).cond) != PTHREAD_COND_SIGNAL_SUCCESS){
				printTitledError("pthread error", "could not signal sleep operation thread");
			}
			if(pthread_mutex_unlock(&(*sleepThreadSystem).mutex) != PTHREAD_MUTEX_UNLOCK_SUCCESS){
				printTitledError("pthread error", "could not unlock sleep operation mutex");
			}
		}
		if(pthread_join((*sleepThreadSystem).thread, NULL) != PTHREAD_JOIN_SUCCESS){
			printTitledError("pthread error", "could not join sleep operation thread");
		}
		(*sleepThreadSystem).threadCreated = false;
	}
	if((*sleepThreadSystem).condCreated){
		if(pthread_cond_destroy(&(*sleepThreadSystem).cond) != PTHREAD_COND_DESTROY_SUCCESS){
			printTitledError("pthread error", "could not destroy sleep operation cond");
		}
		(*sleepThreadSystem).condCreated = false;
	}
	if((*sleepThreadSystem).mutexCreated){
		if(pthread_mutex_destroy(&(*sleepThreadSystem).mutex) != PTHREAD_MUTEX_DESTROY_SUCCESS){
			printTitledError("pthread error", "could not destroy sleep operation mutex");
		}
		(*sleepThreadSystem).mutexCreated = false;
	}
	(*sleepThreadSystem).quittingThread = false;
	ret true;
}
FINISLEEPTHREADSYSTEM(){
	if(!sleepThreadSystem){
		ret false;
	}
	quitSleepThread(sleepThreadSystem);
	(*sleepThreadSystem).risingOperation = NULL;
	(*sleepThreadSystem).risingOperationArgument = NULL;
	(*sleepThreadSystem).fallingOperation = NULL;
	(*sleepThreadSystem).fallingOperationArgument = NULL;
	(*sleepThreadSystem).seconds = 0;
	(*sleepThreadSystem).nanoseconds = 0;
	(*sleepThreadSystem).loopOperation = false;
	(*sleepThreadSystem).restartTimer = false;
	(*sleepThreadSystem).running = false;
	(*sleepThreadSystem).quittingThread = false;
	(*sleepThreadSystem).mutexCreated = false;
	(*sleepThreadSystem).condCreated = false;
	(*sleepThreadSystem).threadCreated = false;
	ret true;
}
INITSTRINGTREESYSTEM(){
	#define DATA_BLOCK_SIZE /*-*/ (256)
	if(!stringTreeSystem){
		ret false;
	}
	(*stringTreeSystem).stringArray = NULL;
	(*stringTreeSystem).dataSize = 0;
	(*stringTreeSystem).dataAllocated = 0;
	(*stringTreeSystem).dataStart = NULL;
	(*stringTreeSystem).dataToken = 0;
	(*stringTreeSystem).counter = 1;
	(*stringTreeSystem).returnedCounter = 0;
	ret true;
}
BULKINSERTSTRING(){
	const char *const *stringCurrent;
	if(!stringTreeSystem or !stringArray){
		ret false;
	}
	(*stringTreeSystem).stringArray = stringArray;
	stringCurrent = stringArray;
	jmp insertStringLoop;
	insertStringLoop:{
		insertString(stringTreeSystem, *stringCurrent);
		if(*(inc stringCurrent)){
			jmp insertStringLoop;
		}
		jmp trimMemory;
	}
	trimMemory:{
		if((*stringTreeSystem).dataAllocated){
			void *temp;
			(*stringTreeSystem).dataSize = (*stringTreeSystem).dataAllocated;
			temp = realloc((*stringTreeSystem).dataStart, (*stringTreeSystem).dataSize * sizeof(StringTreeNode));
			updatePointer((*stringTreeSystem).dataToken, temp);
			if(temp){
				(*stringTreeSystem).dataStart = temp;
			}
		}
		ret true;
	}
}
INSERTSTRING(){
	uint size;
	uint allocated;
	StringTreeNode *data;
	StringTreeNode *node;
	bool returnValue;
	if(!stringTreeSystem or !string){
		ret false;
	}
	size = (*stringTreeSystem).dataSize;
	allocated = (*stringTreeSystem).dataAllocated;
	data = (*stringTreeSystem).dataStart;
	jmp findString;
	findString:{
		node = getStringTreeNode(stringTreeSystem, &string);
		if(data and (!node or (*node).letter & b(10000000))){
			ret false;
		}
		jmp addLetterLoop;
	}
	addLetterLoop:{
		if(allocated == size){
			const uint nodeOffset = node - data;
			void *temp;
			size += DATA_BLOCK_SIZE;
			temp = realloc(data, size * sizeof(StringTreeNode));
			if(!(*stringTreeSystem).dataToken){
				(*stringTreeSystem).dataToken = pushPointer(temp, "string tree pointer", iFree);
			}else{
				updatePointer((*stringTreeSystem).dataToken, temp);
			}
			if(!temp){
				printTitledError("memory allocation error", "could not allocate memory for string tree nodes");
				size -= DATA_BLOCK_SIZE;
				returnValue = false;
				jmp completeString;
			}
			data = temp;
			node = data + nodeOffset;
			if(!allocated){
				(*node).letter = '\0';
				(*node).childrenAmount = 0;
				inc allocated;
			}
		}
		if((*node).childrenAmount >= STRING_TREE_NODE_CHILDREN_AMOUNT){
			printTitledError("insert string error", "out of space for new children in string node");
			ret false;
		}
		*((*node).offset + (*node).childrenAmount) = allocated;
		inc (*node).childrenAmount;
		node = data + allocated;
		(*node).childrenAmount = 0;
		inc allocated;
		if(*string){
			(*node).letter = *string;
			inc string;
			jmp addLetterLoop;
		}
		returnValue = true;
		jmp completeString;
	}
	completeString:{
		if(node){
			(*node).letter = b(10000000) | (*stringTreeSystem).counter;
			inc (*stringTreeSystem).counter;
			(*stringTreeSystem).dataSize = size;
			(*stringTreeSystem).dataAllocated = allocated;
			(*stringTreeSystem).dataStart = data;
		}
		ret returnValue;
	}
}
GETSTRINGTREENODE(){
	const uint16 *offsetCurrent;
	const uint16 *offsetWall;
	const char *string;
	StringTreeNode *data;
	StringTreeNode *node;
	char c;
	if(!stringTreeSystem or !(*stringTreeSystem).dataStart or !stringReturn){
		ret NULL;
	}
	data = (*stringTreeSystem).dataStart;
	node = data;
	string = *stringReturn;
	jmp findLetterLoop;
	findLetterLoop:{
		offsetCurrent = (*node).offset;
		offsetWall = offsetCurrent + (*node).childrenAmount;
		c = *string;
		c += (c >= 'A' and c <= 'Z') * 32 - (c == '_') * 50;
		jmp nextLetterLoop;
	}
	nextLetterLoop:{
		if(offsetCurrent < offsetWall){
			StringTreeNode *const child = data + *offsetCurrent;
			if((*child).letter == c and c){
				inc string;
				node = child;
				jmp findLetterLoop;
			}
			if((*child).letter & b(10000000) and !c){
				(*stringTreeSystem).returnedCounter = ((*child).letter & ~b(10000000)) - 1;
				*stringReturn = string;
				ret child;
			}
			inc offsetCurrent;
			jmp nextLetterLoop;
		}
		*stringReturn = string;
		ret node;
	}
}
FINDSTRINGTREESTRING(){
	StringTreeNode *const node = getStringTreeNode(stringTreeSystem, (void *)string);
	if(!node or !((*node).letter & b(10000000))){
		ret false;
	}
	ret true;
}
FINISTRINGTREESYSTEM(){
	if(!stringTreeSystem){
		ret false;
	}
	free((*stringTreeSystem).dataStart);
	popPointer((*stringTreeSystem).dataToken);
	(*stringTreeSystem).stringArray = NULL;
	(*stringTreeSystem).dataSize = 0;
	(*stringTreeSystem).dataAllocated = 0;
	(*stringTreeSystem).dataStart = NULL;
	(*stringTreeSystem).dataToken = 0;
	(*stringTreeSystem).counter = 1;
	(*stringTreeSystem).returnedCounter = 0;
	ret true;
	#undef  DATA_BLOCK_SIZE
}
INITSTDINSYSTEM(){
	#define STDIN_BLOCK_SIZE /*-*/ (1024)
	if(!stdinSystem){
		ret false;
	}
	(*stdinSystem).size = 0;
	(*stdinSystem).allocated = 0;
	(*stdinSystem).start = NULL;
	(*stdinSystem).current = NULL;
	(*stdinSystem).token = 0;
	(*stdinSystem).threadCreated = false;
	(*stdinSystem).operating = false;
	(*stdinSystem).quittingThread = false;
	ret true;
}
CONNECTSTDIN(){
	if(!stdinSystem or (*stdinSystem).threadCreated){
		ret false;
	}
	(*stdinSystem).threadCreated = pthread_create(&(*stdinSystem).thread, NULL, &stdinMain, stdinSystem) == PTHREAD_CREATE_SUCCESS;
	if(!(*stdinSystem).threadCreated){
		printTitledError("pthread error", "could not create stdin thread");
		ret false;
	}
	ret true;
}
STDINMAIN(){
	STDINSystem *const stdinSystem = arg;
	if(!stdinSystem){
		jmp emergencyExit;
	}
	jmp setupThread;
	setupThread:{
		int oldState;
		int oldType;
		if(pthread_setcancelstate(PTHREAD_CANCEL_ENABLE, &oldState) != PTHREAD_SETCANCELSTATE_SUCCESS){
			printTitledError("pthread error", "could not set stdin thread cancel state");
		}
		if(pthread_setcanceltype(PTHREAD_CANCEL_ASYNCHRONOUS, &oldType) != PTHREAD_SETCANCELTYPE_SUCCESS){
			printTitledError("pthread error", "could not set stdin thread cancel type");
		}
		jmp initializeBuffer;
	}
	initializeBuffer:{
		(*stdinSystem).size = STDIN_BLOCK_SIZE;
		(*stdinSystem).allocated = 0;
		(*stdinSystem).start = malloc((*stdinSystem).size * sizeof(char));
		(*stdinSystem).current = (*stdinSystem).start;
		(*stdinSystem).token = pushPointer((*stdinSystem).start, "stdin data pointer", iFree);
		if(!(*stdinSystem).start){
			printTitledError("memory allocation error", "could not allocate memory for stdin data");
			jmp emergencyExit;
		}
		jmp checkSTDIN;
	}
	checkSTDIN:{
		struct pollfd fds;
		fds.fd = STDIN_FILENO;
		fds.events = POLLIN;
		if(poll(&fds, 1, 10) > 0){
			jmp clearSTDINLoop;
		}
		jmp waitIndefinitely;
	}
	clearSTDINLoop:{
		if(fread((*stdinSystem).start, sizeof(char), (*stdinSystem).size, stdin) == (*stdinSystem).size){
			jmp clearSTDINLoop;
		}
		jmp waitIndefinitely;
	}
	waitIndefinitely:{
		char c;
		if((*stdinSystem).quittingThread){
			jmp emergencyExit;
		}
		c = fgetc(stdin);
		if((*stdinSystem).allocated == (*stdinSystem).size){
			const uint offset = (*stdinSystem).current - (*stdinSystem).start;
			void *temp;
			(*stdinSystem).size += STDIN_BLOCK_SIZE;
			temp = realloc((*stdinSystem).start, (*stdinSystem).size * sizeof(char));
			updatePointer((*stdinSystem).token, temp);
			if(!temp){
				printTitledError("memory allocation error", "could not allocate memory for stdin data");
				(*stdinSystem).size -= STDIN_BLOCK_SIZE;
				jmp emergencyExit;
			}
			(*stdinSystem).start = temp;
			(*stdinSystem).current = (*stdinSystem).start + offset;
		}
		*(*stdinSystem).current = c;
		if(c != '\n'){
			inc (*stdinSystem).current;
			inc (*stdinSystem).allocated;
			jmp waitIndefinitely;
		}
		*(*stdinSystem).current = EOF;
		(*stdinSystem).current = (*stdinSystem).start;
		if(globalsLockCreated and pthread_rwlock_wrlock(&globalsLock) != PTHREAD_RWLOCK_WRLOCK_SUCCESS){
			printTitledError("pthread error", "could not lock globals write lock");
		}
		(*stdinSystem).operating = true;
		readConfig(false, "stdin", &getNextSTDINCharacter, &getPreviousSTDINCharacter);
		(*stdinSystem).operating = false;
		if(globalsLockCreated and pthread_rwlock_unlock(&globalsLock) != PTHREAD_RWLOCK_UNLOCK_SUCCESS){
			printTitledError("pthread error", "could not unlock globals write lock");
		}
		(*stdinSystem).allocated = 0;
		(*stdinSystem).current = (*stdinSystem).start;
		jmp waitIndefinitely;
	}
	emergencyExit:{
		free((*stdinSystem).start);
		popPointer((*stdinSystem).token);
		(*stdinSystem).size = 0;
		(*stdinSystem).allocated = 0;
		(*stdinSystem).start = NULL;
		(*stdinSystem).current = NULL;
		(*stdinSystem).token = 0;
		(*stdinSystem).threadCreated = false;
		(*stdinSystem).quittingThread = false;
		ret NULL;
	}
}
GETNEXTSTDINCHARACTER(){
	STDINSystem *const stdinSystem = arg;
	if(!stdinSystem or !(*stdinSystem).current){
		ret EOF;
	}
	ret *(inc (*stdinSystem).current - 1);
}
GETPREVIOUSSTDINCHARACTER(){
	STDINSystem *const stdinSystem = arg;
	if(!stdinSystem or !(*stdinSystem).current){
		ret EOF;
	}
	ret *(dec (*stdinSystem).current);
}
DISCONNECTSTDIN(){
	if(!stdinSystem or !(*stdinSystem).threadCreated){
		ret false;
	}
	(*stdinSystem).quittingThread = true;
	if((*stdinSystem).threadCreated){
		if((*stdinSystem).operating){
			ret true;
		}
		if(pthread_cancel((*stdinSystem).thread) != PTHREAD_CANCEL_SUCCESS){
			printTitledError("pthread error", "could not cancel stdin thread");
		}
		if(pthread_join((*stdinSystem).thread, NULL) != PTHREAD_JOIN_SUCCESS){
			printTitledError("pthread error", "could not join stdin thread");
		}
		(*stdinSystem).threadCreated = false;
	}
	free((*stdinSystem).start);
	popPointer((*stdinSystem).token);
	(*stdinSystem).size = 0;
	(*stdinSystem).allocated = 0;
	(*stdinSystem).start = NULL;
	(*stdinSystem).current = NULL;
	(*stdinSystem).token = 0;
	(*stdinSystem).quittingThread = false;
	ret true;
}
FINISTDINSYSTEM(){
	if(!stdinSystem){
		ret false;
	}
	disconnectSTDIN(stdinSystem);
	(*stdinSystem).size = 0;
	(*stdinSystem).allocated = 0;
	(*stdinSystem).start = NULL;
	(*stdinSystem).current = NULL;
	(*stdinSystem).token = 0;
	(*stdinSystem).threadCreated = false;
	(*stdinSystem).operating = false;
	(*stdinSystem).quittingThread = false;
	ret true;
	#undef  STDIN_BLOCK_SIZE
}
INITSHAREDMEMORYSYSTEM(){
	#define STAT_FAILURE /*----*/ (-1)
	#define SHMGET_FAILURE /*--*/ (-1)
	#define SHMAT_FAILURE /*---*/ ((void *)-1)
	#define SHMCTL_FAILURE /*--*/ (-1)
	#define SHMDT_FAILURE /*---*/ (-1)
	#define STAT_PATH /*-------*/ ("/dev/shm/" PROGRAM_NAME)
	#define SHM_KEY /*---------*/ (((s.st_dev << 20) & 0xfff00000) | ((s.st_ino << 8) & 0x000fff00) | 0x00000045)
	#define SHARED_SIZE /*-----*/ (65536)
	#define SHM_HEADER_SIZE /*-*/ (sizeof(pthread_mutex_t) + sizeof(pthread_cond_t) + sizeof(uint8))
	#define SHM_FOOTER_SIZE /*-*/ (2)
	#define SHM_BODY_SIZE /*---*/ (SHM_SIZE - SHM_HEADER_SIZE - SHM_FOOTER_SIZE)
	#define SHM_NONE /*--------*/ (0)
	if(!sharedMemorySystem){
		ret false;
	}
	(*sharedMemorySystem).shmID = SHMGET_FAILURE;
	(*sharedMemorySystem).shmToken = 0;
	(*sharedMemorySystem).start = NULL;
	(*sharedMemorySystem).current = NULL;
	(*sharedMemorySystem).token = 0;
	(*sharedMemorySystem).mutexCreated = false;
	(*sharedMemorySystem).condCreated = false;
	(*sharedMemorySystem).threadCreated = false;
	(*sharedMemorySystem).operating = false;
	(*sharedMemorySystem).quittingFromInside = false;
	(*sharedMemorySystem).quittingThread = false;
	ret true;
}
CONNECTSHAREDMEMORY(){
	def struct stat Stat;
	FILE *file;
	Stat s;
	if(!sharedMemorySystem or (*sharedMemorySystem).shmID != SHMGET_FAILURE){
		ret false;
	}
	jmp createKeyFile;
	createKeyFile:{
		uint32 token;
		file = fopen(STAT_PATH, "w");
		token = pushPointer(file, "shm file", fclose);
		if(!file){
			file = fopen(STAT_PATH, "r");
			token = pushPointer(file, "shm file", fclose);
			if(!file){
				printError("%s%s: %s%s:%s %s %s %s\n", colorStart, programName, colorError, "shared memory error", colorEnd, "could neither create nor read", STAT_PATH, "file");
				ret false;
			}
		}
		fclose(file);
		popPointer(token);
		jmp getKeyFileStat;
	}
	getKeyFileStat:{
		if(stat(STAT_PATH, &s) == STAT_FAILURE){
			printTitledError("shared memory error", "could not generate shared memory key");
			ret false;
		}
		jmp createSharedMemory;
	}
	createSharedMemory:{
		(*sharedMemorySystem).shmID = shmget(SHM_KEY, SHARED_SIZE, IPC_CREAT | 0600);
		(*sharedMemorySystem).shmToken = pushPointer((void *)(int64)(*sharedMemorySystem).shmID, "shm id", ishmctl);
		if((*sharedMemorySystem).shmID == SHMGET_FAILURE){
			printTitledError("shared memory error", "could not create shared memory segment");
			ret false;
		}
		jmp attachToSharedMemory;
	}
	attachToSharedMemory:{
		(*sharedMemorySystem).start = shmat((*sharedMemorySystem).shmID, NULL, SHM_NONE);
		if((*sharedMemorySystem).start == SHMAT_FAILURE){
			printTitledError("shared memory error", "could not attach to shared memory");
			(*sharedMemorySystem).start = NULL;
			ret false;
		}
		(*sharedMemorySystem).token = pushPointer((*sharedMemorySystem).start, "shared memory pointer", shmdt);
		(*sharedMemorySystem).mutex = (void *)(*sharedMemorySystem).start;
		(*sharedMemorySystem).cond = (void *)((*sharedMemorySystem).start + sizeof(pthread_mutex_t));
		*((*sharedMemorySystem).start + SHM_HEADER_SIZE - sizeof(uint8)) = EMPTY_SHARED_STATUS;
		jmp createThreadObjects;
	}
	createThreadObjects:{
		pthread_mutexattr_t mutexAttributes;
		pthread_condattr_t condAttributes;
		if(pthread_mutexattr_init(&mutexAttributes) != PTHREAD_MUTEXATTR_INIT_SUCCESS){
			printTitledError("pthread error", "could not init shared mutex attributes");
		}
		if(pthread_mutexattr_setpshared(&mutexAttributes, PTHREAD_PROCESS_SHARED) != PTHREAD_MUTEXATTR_SETPSHARED_SUCCESS){
			printTitledError("pthread error", "could not set shared mutex shared process attribute");
		}
		(*sharedMemorySystem).mutexCreated = pthread_mutex_init((*sharedMemorySystem).mutex, &mutexAttributes) == PTHREAD_MUTEX_INIT_SUCCESS;
		if(!(*sharedMemorySystem).mutexCreated){
			printTitledError("pthread error", "could not init shared mutex");
		}
		if(pthread_mutexattr_destroy(&mutexAttributes) != PTHREAD_MUTEXATTR_DESTROY_SUCCESS){
			printTitledError("pthread error", "could not destroy shared mutex attributes");
		}
		if(pthread_condattr_init(&condAttributes) != PTHREAD_CONDATTR_INIT_SUCCESS){
			printTitledError("pthread error", "could not init shared cond attributes");
		}
		if(pthread_condattr_setpshared(&condAttributes, PTHREAD_PROCESS_SHARED) != PTHREAD_CONDATTR_SETPSHARED_SUCCESS){
			printTitledError("pthread error", "could not set shared cond shared process attribute");
		}
		(*sharedMemorySystem).condCreated = pthread_cond_init((*sharedMemorySystem).cond, &condAttributes) == PTHREAD_COND_INIT_SUCCESS;
		if(!(*sharedMemorySystem).condCreated){
			printTitledError("pthread error", "could not init shared cond");
		}
		if(pthread_condattr_destroy(&condAttributes) != PTHREAD_CONDATTR_DESTROY_SUCCESS){
			printTitledError("pthread error", "could not destroy shared cond attributes");
		}
		(*sharedMemorySystem).threadCreated = pthread_create(&(*sharedMemorySystem).thread, NULL, &sharedMemoryMain, sharedMemorySystem) == PTHREAD_CREATE_SUCCESS;
		if(!(*sharedMemorySystem).threadCreated){
			printTitledError("pthread error", "could not create shared memory thread");
			ret false;
		}
		ret true;
	}
}
SHAREDMEMORYMAIN(){
	SharedMemorySystem *const sharedMemorySystem = arg;
	uint8 *current;
	if(!sharedMemorySystem){
		ret NULL;
	}
	if(pthread_mutex_lock((*sharedMemorySystem).mutex) != PTHREAD_MUTEX_LOCK_SUCCESS){
		printTitledError("pthread error", "could not lock shared mutex");
	}
	current = (*sharedMemorySystem).start + sizeof(pthread_mutex_t) + sizeof(pthread_cond_t);
	jmp waitIndefinitely;
	waitIndefinitely:{
		if(pthread_cond_wait((*sharedMemorySystem).cond, (*sharedMemorySystem).mutex) != PTHREAD_COND_WAIT_SUCCESS){
			printTitledError("pthread error", "could not wait shared mutex");
		}
		if((*sharedMemorySystem).quittingThread){
			*current = FULL_SHARED_STATUS;
			jmp emergencyExit;
		}
		if(*current == FULL_SHARED_STATUS){
			*current = EMPTY_SHARED_STATUS;
			if(globalsLockCreated and pthread_rwlock_wrlock(&globalsLock) != PTHREAD_RWLOCK_WRLOCK_SUCCESS){
				printTitledError("pthread error", "could not lock globals write lock");
			}
			(*sharedMemorySystem).current = current + 1;
			(*sharedMemorySystem).operating = true;
			readConfig(false, "transmitter", &getNextSharedMemoryCharacter, &getPreviousSharedMemoryCharacter);
			(*sharedMemorySystem).operating = false;
			(*sharedMemorySystem).current = NULL;
			if(globalsLockCreated and pthread_rwlock_unlock(&globalsLock) != PTHREAD_RWLOCK_UNLOCK_SUCCESS){
				printTitledError("pthread error", "could not unlock globals write lock");
			}
			if(*current == FULL_SHARED_STATUS){
				(*sharedMemorySystem).quittingFromInside = true;
				jmp emergencyExit;
			}
			*current = EMPTY_SHARED_STATUS;
		}
		jmp waitIndefinitely;
	}
	emergencyExit:{
		if(pthread_mutex_unlock((*sharedMemorySystem).mutex) != PTHREAD_MUTEX_UNLOCK_SUCCESS){
			printTitledError("pthread error", "could not unlock shared mutex");
		}
		(*sharedMemorySystem).threadCreated = false;
		disconnectSharedMemory(sharedMemorySystem);
		ret NULL;
	}
}
GETNEXTSHAREDMEMORYCHARACTER(){
	SharedMemorySystem *const sharedMemorySystem = arg;
	if(!sharedMemorySystem or !(*sharedMemorySystem).current){
		ret EOF;
	}
	ret *(inc (*sharedMemorySystem).current - 1);
}
GETPREVIOUSSHAREDMEMORYCHARACTER(){
	SharedMemorySystem *const sharedMemorySystem = arg;
	if(!sharedMemorySystem or !(*sharedMemorySystem).current){
		ret EOF;
	}
	ret *(dec (*sharedMemorySystem).current);
}
DISCONNECTSHAREDMEMORY(){
	if(!sharedMemorySystem or (!(*sharedMemorySystem).threadCreated and !(*sharedMemorySystem).quittingFromInside)){
		ret false;
	}
	jmp destroyThreadObjects;
	destroyThreadObjects:{
		(*sharedMemorySystem).quittingThread = true;
		if((*sharedMemorySystem).threadCreated){
			if((*sharedMemorySystem).operating){
				*((*sharedMemorySystem).start + sizeof(pthread_mutex_t) + sizeof(pthread_cond_t)) = FULL_SHARED_STATUS;
				(*sharedMemorySystem).quittingThread = false;
				ret true;
			}
			if((*sharedMemorySystem).mutexCreated and (*sharedMemorySystem).condCreated){
				if(pthread_mutex_lock((*sharedMemorySystem).mutex) != PTHREAD_MUTEX_LOCK_SUCCESS){
					printTitledError("pthread error", "could not lock shared mutex");
				}
				if(pthread_cond_signal((*sharedMemorySystem).cond) != PTHREAD_COND_SIGNAL_SUCCESS){
					printTitledError("pthread error", "could not signal shared thread");
				}
				if(pthread_mutex_unlock((*sharedMemorySystem).mutex) != PTHREAD_MUTEX_UNLOCK_SUCCESS){
					printTitledError("pthread error", "could not unlock shared mutex");
				}
			}
			if(pthread_join((*sharedMemorySystem).thread, NULL) != PTHREAD_JOIN_SUCCESS){
				printTitledError("pthread error", "could not join shared thread");
			}
			(*sharedMemorySystem).threadCreated = false;
		}
		if((*sharedMemorySystem).cond and (*sharedMemorySystem).condCreated){
			if(pthread_cond_destroy((*sharedMemorySystem).cond) != PTHREAD_COND_DESTROY_SUCCESS){
				printTitledError("pthread error", "could not destroy shared cond");
			}
			(*sharedMemorySystem).condCreated = false;
		}
		if((*sharedMemorySystem).mutex and (*sharedMemorySystem).mutexCreated){
			if(pthread_mutex_destroy((*sharedMemorySystem).mutex) != PTHREAD_MUTEX_DESTROY_SUCCESS){
				printTitledError("pthread error", "could not destroy shared mutex");
			}
			(*sharedMemorySystem).mutexCreated = false;
		}
		jmp markForDeletion;
	}
	markForDeletion:{
		if((*sharedMemorySystem).shmID != SHMGET_FAILURE and shmctl((*sharedMemorySystem).shmID, IPC_RMID, NULL) == SHMCTL_FAILURE){
			printTitledError("shared memory error", "could not mark shared memory for deletion");
		}
		popPointer((*sharedMemorySystem).shmToken);
		(*sharedMemorySystem).shmID = SHMGET_FAILURE;
		(*sharedMemorySystem).shmToken = 0;
		jmp detach;
	}
	detach:{
		if((*sharedMemorySystem).start and shmdt((*sharedMemorySystem).start) == SHMDT_FAILURE){
			printTitledError("shared memory error", "could not detach from shared memory");
		}
		popPointer((*sharedMemorySystem).token);
		(*sharedMemorySystem).start = NULL;
		(*sharedMemorySystem).current = NULL;
		(*sharedMemorySystem).token = 0;
		(*sharedMemorySystem).quittingFromInside = false;
		(*sharedMemorySystem).quittingThread = false;
		ret true;
	}
}
FINISHAREDMEMORYSYSTEM(){
	if(!sharedMemorySystem){
		ret false;
	}
	disconnectSharedMemory(sharedMemorySystem);
	(*sharedMemorySystem).shmID = SHMGET_FAILURE;
	(*sharedMemorySystem).shmToken = 0;
	(*sharedMemorySystem).start = NULL;
	(*sharedMemorySystem).current = NULL;
	(*sharedMemorySystem).token = 0;
	(*sharedMemorySystem).mutexCreated = false;
	(*sharedMemorySystem).condCreated = false;
	(*sharedMemorySystem).threadCreated = false;
	(*sharedMemorySystem).operating = false;
	(*sharedMemorySystem).quittingFromInside = false;
	(*sharedMemorySystem).quittingThread = false;
	ret true;
	#undef  SHM_NONE
	#undef  SHM_BODY_SIZE
	#undef  SHM_FOOTER_SIZE
	#undef  SHM_HEADER_SIZE
	#undef  SHARED_SIZE
	#undef  SHM_KEY
	#undef  STAT_PATH
	#undef  SHMDT_FAILURE
	#undef  SHMCTL_FAILURE
	#undef  SHMAT_FAILURE
	#undef  SHMGET_FAILURE
	#undef  STAT_FAILURE
}
INITSHORTCUTSYSTEM(){
	#define MODIFIER_DATA_BLOCK_SIZE /*-*/ (32)
	if(!shortcutSystem){
		ret false;
	}
	(*shortcutSystem).modifierSize = 0;
	(*shortcutSystem).modifierAllocated = 0;
	(*shortcutSystem).modifierNotInUseOffset = 0;
	(*shortcutSystem).modifierStart = NULL;
	(*shortcutSystem).modifierToken = 0;
	setMemory((*shortcutSystem).codeListStart, 0, SHORTCUT_CODE_AMOUNT, sizeof(uint64));
	ret true;
}
INSERTSHORTCUT(){
	ModifierNode *node;
	if(!shortcutSystem or !onState){
		ret false;
	}
	if((*shortcutSystem).modifierAllocated == (*shortcutSystem).modifierSize){
		void *temp;
		(*shortcutSystem).modifierSize += MODIFIER_DATA_BLOCK_SIZE;
		temp = realloc((*shortcutSystem).modifierStart, (*shortcutSystem).modifierSize * sizeof(ModifierNode));
		if(!(*shortcutSystem).modifierToken){
			(*shortcutSystem).modifierToken = pushPointer((*shortcutSystem).modifierStart, "shortcut modifier list pointer", iFree);
		}else{
			updatePointer((*shortcutSystem).modifierToken, temp);
		}
		if(!temp){
			printTitledError("memory allocation error", "could not allocate memory for shortcuts");
			(*shortcutSystem).modifierSize -= MODIFIER_DATA_BLOCK_SIZE;
			ret false;
		}
		(*shortcutSystem).modifierStart = temp;
		if(!(*shortcutSystem).modifierAllocated){
			(*shortcutSystem).modifierAllocated = 1;
			(*shortcutSystem).modifierNotInUseOffset = 1;
		}
	}
	node = (*shortcutSystem).modifierStart + (*shortcutSystem).modifierNotInUseOffset;
	(*node).inUse = true;
	(*node).command = command;
	(*node).modifier = modifier;
	(*node).nextOffset = 0;
	(*node).string = string;
	(*node).stringToken = stringToken;
	(*node).field0 = field0;
	(*node).field1 = field1;
	(*node).field2 = field2;
	(*node).field3 = field3;
	(*node).field4 = field4;
	(*node).onState = onState;
	(*node).hasBeenPressed = false;
	if(!*((*shortcutSystem).codeListStart + code)){
		*((*shortcutSystem).codeListStart + code) = (*shortcutSystem).modifierNotInUseOffset;
	}else{
		const uint offset = *((*shortcutSystem).codeListWall + code);
		(*((*shortcutSystem).modifierStart + offset)).nextOffset = (*shortcutSystem).modifierNotInUseOffset - offset;
	}
	*((*shortcutSystem).codeListWall + code) = (*shortcutSystem).modifierNotInUseOffset;
	if((*shortcutSystem).modifierNotInUseOffset == (*shortcutSystem).modifierAllocated){
		inc (*shortcutSystem).modifierAllocated;
		inc (*shortcutSystem).modifierNotInUseOffset;
	}else{
		const ModifierNode *current = node + 1;
		const ModifierNode *const wall = (*shortcutSystem).modifierStart + (*shortcutSystem).modifierAllocated;
		jmp findNextAvailableModifierNodeSlotLoop;
		findNextAvailableModifierNodeSlotLoop:{
			if(current < wall and (*current).inUse){
				inc current;
				jmp findNextAvailableModifierNodeSlotLoop;
			}
			(*shortcutSystem).modifierNotInUseOffset = current - (*shortcutSystem).modifierStart;
		}
	}
	ret true;
}
GETNEXTSHORTCUT(){
	ModifierNode *current;
	int offset;
	if(!shortcutSystem or !nextOffset){
		ret false;
	}
	current = (*shortcutSystem).modifierStart;
	if(!*nextOffset){
		offset = *((*shortcutSystem).codeListStart + code);
		jmp findShortcutModifierLoop;
	}
	code = shortcutCode;
	modifier = shortcutModifier;
	offset = *nextOffset;
	jmp findShortcutModifierLoop;
	findShortcutModifierLoop:{
		if(offset){
			current += offset;
			if((*current).modifier == modifier){
				if(isRelease and !(*current).hasBeenPressed){
					jmp findShortcutModifierLoopControl;
				}
				shortcutCode = code;
				shortcutModifier = modifier;
				eventModifierNode = current;
				(*current).hasBeenPressed = !isRelease;
				if((*current).nextOffset){
					*nextOffset = current - (*shortcutSystem).modifierStart + (*current).nextOffset;
					ret true;
				}
				*nextOffset = 0;
				ret true;
			}
			jmp findShortcutModifierLoopControl;
		}
		*nextOffset = 0;
		ret false;
	}
	findShortcutModifierLoopControl:{
		offset = (*current).nextOffset;
		jmp findShortcutModifierLoop;
	}
}
REMOVESHORTCUT(){
	ModifierNode *modifierStart;
	ModifierNode *node;
	bool hasRemovedShortcut;
	if(!shortcutSystem){
		ret false;
	}
	modifierStart = (*shortcutSystem).modifierStart;
	node = modifierStart + *((*shortcutSystem).codeListStart + code);
	hasRemovedShortcut = false;
	if(node > modifierStart){
		ModifierNode *previousNode = NULL;
		uint modifierAllocated = (*shortcutSystem).modifierAllocated;
		uint modifierNotInUseOffset = (*shortcutSystem).modifierNotInUseOffset;
		jmp removeModifierLoop;
		removeModifierLoop:{
			const int nextOffset = (*node).nextOffset;
			if(modifier == (*node).modifier){
				(*node).inUse = false;
				free((*node).string);
				popPointer((*node).stringToken);
				if(!previousNode){
					*((*shortcutSystem).codeListStart + code) = !!nextOffset * *((*shortcutSystem).codeListStart + code) + nextOffset;
				}else{
					(*previousNode).nextOffset = !!nextOffset * (*previousNode).nextOffset + nextOffset;
				}
				if(node == modifierStart + modifierAllocated - 1){
					if(dec modifierAllocated < modifierNotInUseOffset){
						dec modifierNotInUseOffset;
					}
				}elif(node - modifierStart < modifierNotInUseOffset){
					modifierNotInUseOffset = node - modifierStart;
				}
				hasRemovedShortcut = true;
			}
			if(nextOffset){
				previousNode = node;
				node += nextOffset;
				jmp removeModifierLoop;
			}
			(*shortcutSystem).modifierAllocated = modifierAllocated;
			(*shortcutSystem).modifierNotInUseOffset = modifierNotInUseOffset;
		}
	}
	ret hasRemovedShortcut;
}
FINISHORTCUTSYSTEM(){
	const ModifierNode *current;
	const ModifierNode *wall;
	if(!shortcutSystem){
		ret false;
	}
	current = (*shortcutSystem).modifierStart;
	wall = current + (*shortcutSystem).modifierAllocated;
	jmp freeShortcutStringLoop;
	freeShortcutStringLoop:{
		if(inc current < wall){
			if((*current).inUse){
				free((*current).string);
				popPointer((*current).stringToken);
			}
			jmp freeShortcutStringLoop;
		}
		setMemory((*shortcutSystem).codeListStart, 0, SHORTCUT_CODE_AMOUNT, sizeof(uint64));
		free((*shortcutSystem).modifierStart);
		popPointer((*shortcutSystem).modifierToken);
		(*shortcutSystem).modifierSize = 0;
		(*shortcutSystem).modifierAllocated = 0;
		(*shortcutSystem).modifierNotInUseOffset = 0;
		(*shortcutSystem).modifierStart = NULL;
		(*shortcutSystem).modifierToken = 0;
		ret true;
	}
	#undef  MODIFIER_DATA_BLOCK_SIZE
}
SETCONFIGVARIABLES(){
	focusOnClick = false;
	focusOnHover = false;
	focusOnClick = true;
	ret;
}
READCONFIG(){
	#define STATEMENT_BLOCK_SIZE /*-*/ (256)
	#define DEFAULT_CONFIG_PATH /*--*/ ("/etc/" PROGRAM_NAME "/" PROGRAM_NAME ".conf")
	const Instruction *const *currentScopeInstruction = globalScopeInstruction;
	const char *const *currentScopeInstructionList = globalInstructionList;
	const Instruction *instructionStart;
	const Instruction *instructionStartCopy;
	const Instruction *instructionCurrent;
	const Instruction *name0Instruction;
	const Instruction *name1Instruction;
	const Instruction *name2Instruction;
	const Instruction *name3Instruction;
	const Instruction *name4Instruction;
	const Instruction *nameList0Instruction;
	const Instruction *nameList1Instruction;
	const Instruction *nameList2Instruction;
	const Instruction *nameList3Instruction;
	const Instruction *nameList4Instruction;
	const Instruction *integer0Instruction;
	const Instruction *integer1Instruction;
	const Instruction *integer2Instruction;
	const Instruction *integer3Instruction;
	const Instruction *integer4Instruction;
	const Instruction *string0Instruction;
	const Instruction *string1Instruction;
	const Instruction *string2Instruction;
	const Instruction *string3Instruction;
	const Instruction *string4Instruction;
	const Instruction *image0Instruction;
	const Instruction *image1Instruction;
	const Instruction *image2Instruction;
	const Instruction *image3Instruction;
	const Instruction *image4Instruction;
	const char *imageErrorMessage;
	FILE *configFile = NULL;
	uint32 configFileToken;
	void *system = NULL;
	uint statementSize = STATEMENT_BLOCK_SIZE;
	char *statementStart = NULL;
	uint32 statementToken = 0;
	char *statementCurrent;
	char *statementWall = NULL;
	char *statementConcreteWall;
	uint8 name0Return;
	uint8 name1Return;
	uint8 name2Return;
	uint8 name3Return;
	uint8 name4Return;
	uint8 nameList0Return;
	uint8 nameList1Return;
	uint8 nameList2Return;
	uint8 nameList3Return;
	uint8 nameList4Return;
	int64 integer0Return;
	int64 integer1Return;
	int64 integer2Return;
	int64 integer3Return;
	int64 integer4Return;
	char *string0Return = NULL;
	uint32 string0Token = 0;
	char *string1Return = NULL;
	uint32 string1Token = 0;
	char *string2Return = NULL;
	uint32 string2Token = 0;
	char *string3Return = NULL;
	uint32 string3Token = 0;
	char *string4Return = NULL;
	uint32 string4Token = 0;
	Image image0Return;
	Image image1Return;
	Image image2Return;
	Image image3Return;
	Image image4Return;
	JmpPoint jmpPoint;
	uint fileLine = 1;
	uint statementLine = 0;
	char fileChar;
	uint itemAmount;
	char quote = '\0';
	uint currentScopeInstructionListSize = countof(globalInstructionList) - 1;
	StringTreeSystem *const *const *currentScopeInstructionData = globalScopeInstructionData;
	StringTreeSystem *const *instructionDataStart;
	StringTreeSystem *const *instructionDataStartCopy;
	StringTreeSystem *const *instructionDataCurrent;
	StringTreeSystem *currentScopeInstructionStringTreeSystem = &globalInstructionStringTreeSystem;
	image0Return.dataStart = NULL;
	image0Return.dataToken = 0;
	image1Return.dataStart = NULL;
	image1Return.dataToken = 0;
	image2Return.dataStart = NULL;
	image2Return.dataToken = 0;
	image3Return.dataStart = NULL;
	image3Return.dataToken = 0;
	image4Return.dataStart = NULL;
	image4Return.dataToken = 0;
	jmp setupPointers;
	setupPointers:{
		if(getNextConfigChar == &ifgetc){
			if(!createConfigFile){
				DIR *const dir = opendir(configPath);
				uint32 token = pushPointer(dir, "config directory argument", closedir);
				if(dir){
					closedir(dir);
					popPointer(token);
					printConfigError("config error", "config file is directory", '\0', false, false, false, false, configPath, 1, statementStart, statementWall, NULL, NULL, NULL, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
					jmp configEmergencyExit;
				}
			}
			configFile = fopen(configPath, "r");
			configFileToken = pushPointer(configFile, "config file", fclose);
			if(!configFile){
				#define BUFFER_SIZE /*-*/ (4096)
				FILE *defaultConfigFile;
				uint32 defaultConfigFileToken;
				if(!createConfigFile){
					printConfigError("config error", "could not open config file", '\0', false, false, false, false, configPath, 1, statementStart, statementWall, NULL, NULL, NULL, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
					jmp configEmergencyExit;
				}
				configFile = fopen(configPath, "w");
				configFileToken = pushPointer(configFile, "config file", fclose);
				if(!configFile){
					printConfigError("config error", "could not create config file", '\0', false, false, false, false, configPath, 1, statementStart, statementWall, NULL, NULL, NULL, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
					jmp configEmergencyExit;
				}
				defaultConfigFile = fopen(DEFAULT_CONFIG_PATH, "r");
				defaultConfigFileToken = pushPointer(defaultConfigFile, "default config file", fclose);
				if(!defaultConfigFile){
					remove(configPath);
					printTitledNamedError("config file error", "could not copy default configuration file from", DEFAULT_CONFIG_PATH);
					jmp configEmergencyExit;
				}
				copyConfigFileLoop:{
					char buffer[BUFFER_SIZE];
					size_t bytesRead;
					if((bytesRead = fread(buffer, sizeof(*buffer), sizeof(buffer), defaultConfigFile))){
						if(fwrite(buffer, sizeof(*buffer), bytesRead, configFile) != bytesRead){
							fclose(defaultConfigFile);
							popPointer(defaultConfigFileToken);
							remove(configPath);
							printTitledError("config copying error", "could not copy default config file correctly");
							jmp configEmergencyExit;
						}
						jmp copyConfigFileLoop;
					}
				}
				fclose(defaultConfigFile);
				popPointer(defaultConfigFileToken);
				fclose(configFile);
				popPointer(configFileToken);
				if(!(configFile = fopen(configPath, "r"))){
					printTitledError("config error", "could not open newly written file");
					jmp configEmergencyExit;
				}
				#undef  BUFFER_SIZE
			}
		}
		statementStart = malloc(statementSize * sizeof(char));
		statementToken = pushPointer(statementStart, "statement pointer", iFree);
		if(!statementStart){
			printTitledError("config error", "could not store user data");
			jmp configEmergencyExit;
		}
		if(getNextConfigChar == &ifgetc){
			system = configFile;
		}elif(getNextConfigChar == &getNextSTDINCharacter){
			system = &stdinSystem;
		}elif(getNextConfigChar == &getNextSharedMemoryCharacter){
			system = &sharedMemorySystem;
		}
		jmp getStatementStart;
	}
	getStatementStart:{
		#define EOF_N1 /*----------------------------*/ (EOF)
		#define ZER_00 /*----------------------------*/ ('\0')
		#define EOT_04 /*----------------------------*/ (0x04)
		#define ALR_07 /*----------------------------*/ ('\a')
		#define BSP_08 /*----------------------------*/ ('\b')
		#define TAB_09 /*----------------------------*/ ('\t')
		#define NLN_10 /*----------------------------*/ ('\n')
		#define VTB_11 /*----------------------------*/ ('\v')
		#define FFD_12 /*----------------------------*/ ('\f')
		#define CRE_13 /*----------------------------*/ ('\r')
		#define ESC_27 /*----------------------------*/ ('\e')
		#define SPC_32 /*----------------------------*/ (' ')
		#define DQT_34 /*----------------------------*/ ('\"')
		#define SQT_39 /*----------------------------*/ ('\'')
		#define AST_42 /*----------------------------*/ ('*')
		#define FSL_47 /*----------------------------*/ ('/')
		#define ZER_48 /*----------------------------*/ ('0')
		#define SCL_59 /*----------------------------*/ (';')
		#define QMK_63 /*----------------------------*/ ('?')
		#define BSL_92 /*----------------------------*/ ('\\')
		#define LOA_97 /*----------------------------*/ ('a')
		#define LOB_98 /*----------------------------*/ ('b')
		#define LOF_102 /*---------------------------*/ ('f')
		#define LON_110 /*---------------------------*/ ('n')
		#define LOR_114 /*---------------------------*/ ('r')
		#define LOT_116 /*---------------------------*/ ('t')
		#define LOV_118 /*---------------------------*/ ('v')
		#define OCB_123 /*---------------------------*/ ('{')
		#define BAR_124 /*---------------------------*/ ('|')
		#define CCB_125 /*---------------------------*/ ('}')
		#define GET_STATEMENT_JMP_POINT /*-----------*/ (0)
		#define STORE_WHITESPACE_JMP_POINT /*--------*/ (1)
		#define CHECK_COMMENT_JMP_POINT /*-----------*/ (2)
		#define STORE_BAR_JMP_POINT /*---------------*/ (3)
		#define GET_DOUBLE_QUOTATION_JMP_POINT /*----*/ (4)
		#define GET_SINGLE_QUOTATION_JMP_POINT /*----*/ (5)
		#define HANDLE_ESCAPE_CHARACTER_JMP_POINT /*-*/ (6)
		#define ENTER_SCOPE_JMP_POINT /*-------------*/ (7)
		#define GET_STATEMENT_END_JMP_POINT /*-------*/ (8)
		statementCurrent = statementStart;
		statementConcreteWall = statementStart + statementSize * sizeof(char);
		statementLine = 0;
		itemAmount = 0;
		free(string0Return);
		popPointer(string0Token);
		free(string1Return);
		popPointer(string1Token);
		free(string2Return);
		popPointer(string2Token);
		free(string3Return);
		popPointer(string3Token);
		free(string4Return);
		popPointer(string4Token);
		free(image0Return.dataStart);
		popPointer(image0Return.dataToken);
		free(image1Return.dataStart);
		popPointer(image1Return.dataToken);
		free(image2Return.dataStart);
		popPointer(image2Return.dataToken);
		free(image3Return.dataStart);
		popPointer(image3Return.dataToken);
		free(image4Return.dataStart);
		popPointer(image4Return.dataToken);
		name0Instruction = NULL;
		name1Instruction = NULL;
		name2Instruction = NULL;
		name3Instruction = NULL;
		name4Instruction = NULL;
		nameList0Instruction = NULL;
		nameList1Instruction = NULL;
		nameList2Instruction = NULL;
		nameList3Instruction = NULL;
		nameList4Instruction = NULL;
		integer0Instruction = NULL;
		integer1Instruction = NULL;
		integer2Instruction = NULL;
		integer3Instruction = NULL;
		integer4Instruction = NULL;
		string0Instruction = NULL;
		string1Instruction = NULL;
		string2Instruction = NULL;
		string3Instruction = NULL;
		string4Instruction = NULL;
		image0Instruction = NULL;
		image1Instruction = NULL;
		image2Instruction = NULL;
		image3Instruction = NULL;
		image4Instruction = NULL;
		string0Return = NULL;
		string0Token = 0;
		string1Return = NULL;
		string1Token = 0;
		string2Return = NULL;
		string2Token = 0;
		string3Return = NULL;
		string3Token = 0;
		string4Return = NULL;
		string4Token = 0;
		image0Return.dataStart = NULL;
		image0Return.dataToken = 0;
		image1Return.dataStart = NULL;
		image1Return.dataToken = 0;
		image2Return.dataStart = NULL;
		image2Return.dataToken = 0;
		image3Return.dataStart = NULL;
		image3Return.dataToken = 0;
		image4Return.dataStart = NULL;
		image4Return.dataToken = 0;
		jmp getStatement;
	}
	getStatement: switch(fileChar = getNextConfigChar(system)){
		to EOF_N1: /*--*/ /*----------------------------------*/ jmp endOfFile;
		to EOT_04: /*--*/ /*----------------------------------*/ jmp endOfFile;
		to ZER_00: /*--*/ /*----------------------------------*/ jmp storeWhitespace;
		to TAB_09: /*--*/ /*----------------------------------*/ jmp storeWhitespace;
		to NLN_10: /*--*/ inc fileLine; /*--------------------*/ jmp storeWhitespace;
		to VTB_11: /*--*/ /*----------------------------------*/ jmp storeWhitespace;
		to FFD_12: /*--*/ /*----------------------------------*/ jmp storeWhitespace;
		to CRE_13: /*--*/ /*----------------------------------*/ jmp storeWhitespace;
		to SPC_32: /*--*/ /*----------------------------------*/ jmp storeWhitespace;
		to DQT_34: /*--*/ quote = '\"'; /*--------------------*/ jmp getDoubleQuotation;
		to SQT_39: /*--*/ quote = '\''; /*--------------------*/ jmp getSingleQuotation;
		to FSL_47: /*--*/ /*----------------------------------*/ jmp checkCommentStoreCharacter;
		to SCL_59: /*--*/ /*----------------------------------*/ jmp completeStatement;
		to OCB_123: /*-*/ /*----------------------------------*/ jmp handleOpeningBracket;
		to BAR_124: /*-*/ /*----------------------------------*/ jmp attemptStoreBar;
		to CCB_125: /*-*/ /*----------------------------------*/ jmp handleClosingBracket;
		off: /*--------*/ /*----------------------------------*/ jmp getStatementStoreCharacter;
	}
	getDoubleQuotation: switch(fileChar = getNextConfigChar(system)){
		to EOF_N1: /*--*/ /*----------------------------------*/ jmp endOfFile;
		to ZER_00: /*--*/ fileChar = ' '; /*------------------*/ jmp getDoubleQuotationStoreCharacter;
		to EOT_04: /*--*/ /*----------------------------------*/ jmp endOfFile;
		to NLN_10: /*--*/ inc fileLine; /*--------------------*/ jmp getDoubleQuotationStoreCharacter;
		to DQT_34: /*--*/ fileChar = '\0'; inc itemAmount; /*-*/ jmp getStatementStoreCharacter;
		to BSL_92: /*--*/ /*----------------------------------*/ jmp handleEscapeCharacterStoreCharacter;
		off: /*--------*/ /*----------------------------------*/ jmp getDoubleQuotationStoreCharacter;
	}
	getSingleQuotation: switch(fileChar = getNextConfigChar(system)){
		to EOF_N1: /*--*/ /*----------------------------------*/ jmp endOfFile;
		to ZER_00: /*--*/ fileChar = ' '; /*------------------*/ jmp getSingleQuotationStoreCharacter;
		to EOT_04: /*--*/ /*----------------------------------*/ jmp endOfFile;
		to NLN_10: /*--*/ inc fileLine; /*--------------------*/ jmp getSingleQuotationStoreCharacter;
		to SQT_39: /*--*/ fileChar = '\0'; inc itemAmount; /*-*/ jmp getStatementStoreCharacter;
		to BSL_92: /*--*/ /*----------------------------------*/ jmp handleEscapeCharacterStoreCharacter;
		off: /*--------*/ /*----------------------------------*/ jmp getSingleQuotationStoreCharacter;
	}
	handleEscapeCharacter: switch(fileChar = getNextConfigChar(system)){
		to EOF_N1: /*--*/ /*----------------------------------*/ jmp endOfFile;
		to EOT_04: /*--*/ /*----------------------------------*/ jmp endOfFile;
		to DQT_34: /*--*/ fileChar = '\"'; /*-----------------*/ jmp storeEscapedCharacter;
		to SQT_39: /*--*/ fileChar = '\''; /*-----------------*/ jmp storeEscapedCharacter;
		to ZER_48: /*--*/ fileChar = '\0'; /*-----------------*/ jmp storeEscapedCharacter;
		to QMK_63: /*--*/ fileChar = '\?'; /*-----------------*/ jmp storeEscapedCharacter;
		to BSL_92: /*--*/ fileChar = '\\'; /*-----------------*/ jmp storeEscapedCharacter;
		to LOA_97: /*--*/ fileChar = '\a'; /*-----------------*/ jmp storeEscapedCharacter;
		to LOB_98: /*--*/ fileChar = '\b'; /*-----------------*/ jmp storeEscapedCharacter;
		to LOF_102: /*-*/ fileChar = '\f'; /*-----------------*/ jmp storeEscapedCharacter;
		to LON_110: /*-*/ fileChar = '\n'; /*-----------------*/ jmp storeEscapedCharacter;
		to LOR_114: /*-*/ fileChar = '\r'; /*-----------------*/ jmp storeEscapedCharacter;
		to LOT_116: /*-*/ fileChar = '\t'; /*-----------------*/ jmp storeEscapedCharacter;
		to LOV_118: /*-*/ fileChar = '\v'; /*-----------------*/ jmp storeEscapedCharacter;
		off: /*--------*/ /*----------------------------------*/ jmp getStatementStoreCharacter;
	}
	checkComment: switch(fileChar = getNextConfigChar(system)){
		to EOF_N1: /*--*/ /*----------------------------------*/ jmp endOfFile;
		to EOT_04: /*--*/ /*----------------------------------*/ jmp endOfFile;
		to ZER_00: /*--*/ /*----------------------------------*/ jmp storeWhitespace;
		to TAB_09: /*--*/ /*----------------------------------*/ jmp storeWhitespace;
		to NLN_10: /*--*/ inc fileLine; /*--------------------*/ jmp storeWhitespace;
		to VTB_11: /*--*/ /*----------------------------------*/ jmp storeWhitespace;
		to FFD_12: /*--*/ /*----------------------------------*/ jmp storeWhitespace;
		to CRE_13: /*--*/ /*----------------------------------*/ jmp storeWhitespace;
		to SPC_32: /*--*/ /*----------------------------------*/ jmp storeWhitespace;
		to DQT_34: /*--*/ quote = '\"'; /*--------------------*/ jmp getDoubleQuotation;
		to SQT_39: /*--*/ quote = '\''; /*--------------------*/ jmp getSingleQuotation;
		to AST_42: /*--*/ dec statementCurrent; /*------------*/ jmp ignoreMultipleLineComment;
		to FSL_47: /*--*/ dec statementCurrent; /*------------*/ jmp ignoreSingleLineComment;
		to SCL_59: /*--*/ /*----------------------------------*/ jmp completeStatement;
		to OCB_123: /*-*/ /*----------------------------------*/ jmp handleOpeningBracket;
		to BAR_124: /*-*/ /*----------------------------------*/ jmp attemptStoreBar;
		to CCB_125: /*-*/ /*----------------------------------*/ jmp handleClosingBracket;
		off: /*--------*/ /*----------------------------------*/ jmp getStatementStoreCharacter;
	}
	ignoreMultipleLineComment: switch(fileChar = getNextConfigChar(system)){
		to EOF_N1: /*--*/ /*----------------------------------*/ jmp endOfFile;
		to EOT_04: /*--*/ /*----------------------------------*/ jmp endOfFile;
		to NLN_10: /*--*/ inc fileLine; /*--------------------*/ jmp ignoreMultipleLineComment;
		to AST_42: /*--*/ /*----------------------------------*/ jmp checkMultipleLineCommentEnd;
		off: /*--------*/ /*----------------------------------*/ jmp ignoreMultipleLineComment;
	}
	checkMultipleLineCommentEnd: switch(fileChar = getNextConfigChar(system)){
		to EOF_N1: /*--*/ /*----------------------------------*/ jmp endOfFile;
		to EOT_04: /*--*/ /*----------------------------------*/ jmp endOfFile;
		to NLN_10: /*--*/ inc fileLine; /*--------------------*/ jmp ignoreMultipleLineComment;
		to FSL_47: /*--*/ /*----------------------------------*/ jmp storeWhitespace;
		off: /*--------*/ /*----------------------------------*/ jmp ignoreMultipleLineComment;
	}
	ignoreSingleLineComment: switch(fileChar = getNextConfigChar(system)){
		to EOF_N1: /*--*/ /*----------------------------------*/ jmp endOfFile;
		to EOT_04: /*--*/ /*----------------------------------*/ jmp endOfFile;
		to NLN_10: /*--*/ inc fileLine; /*--------------------*/ jmp storeWhitespace;
		off: /*--------*/ /*----------------------------------*/ jmp ignoreSingleLineComment;
	}
	endOfFile:{
		if(statementCurrent == statementStart){
			jmp successfulConfig;
		}
		if(getPreviousConfigChar){
			getPreviousConfigChar(system);
		}
		jmp completeStatement;
	}
	storeWhitespace:{
		if(statementCurrent <= statementStart or !*(statementCurrent - 1)){
			jmp getStatement;
		}
		inc itemAmount;
		fileChar = '\0';
		jmp getStatementStoreCharacter;
	}
	completeStatement:{
		if(statementCurrent <= statementStart){
			jmp getStatement;
		}
		if(!*(statementCurrent - 1)){
			jmp getStatementEnd;
		}
		inc itemAmount;
		fileChar = '\0';
		jmpPoint = GET_STATEMENT_END_JMP_POINT;
		jmp storeCharacter;
	}
	handleOpeningBracket:{
		if(statementCurrent <= statementStart){
			*statementCurrent = '\0';
			statementLine = fileLine;
			statementWall = statementCurrent;
			printConfigError("stray opening bracket error", "could not enter nameless scope", '{', true, true, true, false, configPath, statementLine, statementStart, statementWall, NULL, NULL, NULL, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
			jmp getStatementStart;
		}
		if(*(statementCurrent - 1)){
			inc itemAmount;
			fileChar = '\0';
			jmpPoint = ENTER_SCOPE_JMP_POINT;
			jmp storeCharacter;
		}
		jmp enterScope;
	}
	enterScope:{
		StringTreeSystem *stringTreeSystem;
		statementWall = statementCurrent - 1;
		statementCurrent = statementStart;
		if(currentScopeInstruction == globalScopeInstruction){
			stringTreeSystem = &globalScopesInstructionStringTreeSystem;
		}else{
			printConfigError("invalid scope error", "no scopes inside current scope", '{', true, true, true, false, configPath, statementLine, statementStart, statementWall, NULL, NULL, NULL, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
			jmp getStatementStart;
		}
		if(!findStringTreeString(stringTreeSystem, &statementCurrent)){
			printConfigError("invalid scope error", "invalid scope name", '{', true, true, true, false, configPath, statementLine, statementStart, statementWall, NULL, NULL, NULL, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
			jmp getStatementStart;
		}
		if(itemAmount > 1){
			/*! missing space between final argument and scope imminent */
			printConfigError("scope argument error", "too many arguments", '{', true, true, true, false, configPath, statementLine, statementStart, statementWall, (void *)1, (void *)1, NULL, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
			jmp getStatementStart;
		}
		currentScopeInstruction = scope1ScopeInstruction;
		currentScopeInstructionData = scope1ScopeInstructionData;
		currentScopeInstructionList = scope1ScopeInstructionList;
		currentScopeInstructionStringTreeSystem = &scope1ScopeInstructionStringTreeSystem;
		currentScopeInstructionListSize = countof(scope1ScopeInstructionList) - 1;
		jmp getStatementStart;
	}
	attemptStoreBar:{
		if(statementCurrent <= statementStart or !*(statementCurrent - 1)){
			jmp storeBar;
		}
		inc itemAmount;
		fileChar = '\0';
		jmpPoint = STORE_BAR_JMP_POINT;
		jmp storeCharacter;
	}
	storeBar:{
		fileChar = '|';
		jmpPoint = STORE_WHITESPACE_JMP_POINT;
		jmp storeCharacter;
	}
	handleClosingBracket:{
		if(statementCurrent > statementStart){
			if(getNextConfigChar != &ifgetc){
				getPreviousConfigChar(system);
				jmp completeStatement;
			}
			fseek(configFile, -1, SEEK_CUR);
			jmp completeStatement;
		}
		if(currentScopeInstruction == globalScopeInstruction){
			*statementCurrent = '\0';
			statementLine = fileLine;
			statementWall = statementCurrent;
			printConfigError("stray closing bracket error", "could not drop to previous config scope", '}', true, true, true, false, configPath, statementLine, statementStart, statementWall, NULL, NULL, NULL, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
			jmp getStatementStart;
		}
		if(currentScopeInstruction == scope1ScopeInstruction){
			currentScopeInstruction = globalScopeInstruction;
			currentScopeInstructionData = globalScopeInstructionData;
			currentScopeInstructionList = globalInstructionList;
			currentScopeInstructionStringTreeSystem = &globalInstructionStringTreeSystem;
			currentScopeInstructionListSize = countof(globalInstructionList) - 1;
		}
		jmp getStatementStart;
	}
	storeEscapedCharacter:{
		*(statementCurrent - 1) = fileChar;
		if(quote == '\"'){
			jmp getDoubleQuotation;
		}
		jmp getSingleQuotation;
	}
	getStatementStoreCharacter:{
		jmpPoint = GET_STATEMENT_JMP_POINT;
		jmp storeCharacter;
	}
	getDoubleQuotationStoreCharacter:{
		jmpPoint = GET_DOUBLE_QUOTATION_JMP_POINT;
		jmp storeCharacter;
	}
	getSingleQuotationStoreCharacter:{
		jmpPoint = GET_SINGLE_QUOTATION_JMP_POINT;
		jmp storeCharacter;
	}
	handleEscapeCharacterStoreCharacter:{
		jmpPoint = HANDLE_ESCAPE_CHARACTER_JMP_POINT;
		jmp storeCharacter;
	}
	checkCommentStoreCharacter:{
		jmpPoint = CHECK_COMMENT_JMP_POINT;
		jmp storeCharacter;
	}
	storeCharacter:{
		if(statementCurrent >= statementConcreteWall){
			const uint offset = statementCurrent - statementStart;
			void *temp;
			statementSize += STATEMENT_BLOCK_SIZE;
			temp = realloc(statementStart, statementSize * sizeof(char));
			updatePointer(statementToken, temp);
			if(!temp){
				printConfigError("memory allocation error", "could not allocate memory for config statement", ';', true, false, false, false, configPath, statementLine, statementStart, statementWall, NULL, NULL, NULL, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
				statementSize -= STATEMENT_BLOCK_SIZE;
				jmp getStatementStart;
			}
			statementStart = temp;
			statementCurrent = statementStart + offset;
			statementConcreteWall = statementStart + statementSize * sizeof(char);
		}
		if(jmpPoint != CHECK_COMMENT_JMP_POINT and !statementLine){
			statementLine = fileLine;
		}
		*statementCurrent = fileChar;
		inc statementCurrent;
		switch(jmpPoint){
			to GET_STATEMENT_JMP_POINT: /*-----------*/ jmp getStatement;
			to STORE_WHITESPACE_JMP_POINT: /*--------*/ jmp storeWhitespace;
			to CHECK_COMMENT_JMP_POINT: /*-----------*/ jmp checkComment;
			to STORE_BAR_JMP_POINT: /*---------------*/ jmp storeBar;
			to GET_DOUBLE_QUOTATION_JMP_POINT: /*----*/ jmp getDoubleQuotation;
			to GET_SINGLE_QUOTATION_JMP_POINT: /*----*/ jmp getSingleQuotation;
			to HANDLE_ESCAPE_CHARACTER_JMP_POINT: /*-*/ jmp handleEscapeCharacter;
			to ENTER_SCOPE_JMP_POINT: /*-------------*/ jmp enterScope;
			off: /*----------------------------------*/ jmp getStatementEnd;
		}
	}
	getStatementEnd:{
		if(statementCurrent > statementStart) /*-*/ jmp findStatement;
		if(!feof(configFile)) /*-----------------*/ jmp getStatementStart;
		/*---------------------------------------*/ jmp successfulConfig;
		#undef  GET_STATEMENT_END_JMP_POINT
		#undef  ENTER_SCOPE_JMP_POINT
		#undef  HANDLE_ESCAPE_CHARACTER_JMP_POINT
		#undef  GET_SINGLE_QUOTATION_JMP_POINT
		#undef  GET_DOUBLE_QUOTATION_JMPPOINT
		#undef  STORE_BAR_JMP_POINT
		#undef  CHECK_COMMENT_JMP_POINT
		#undef  STORE_WHITESPACE_JMP_POINT
		#undef  GET_STATEMENT_JMP_POINT
		#undef  CCB_125
		#undef  BAR_124
		#undef  OCB_123
		#undef  LOV_118
		#undef  LOT_116
		#undef  LOR_114
		#undef  LON_110
		#undef  LOF_102
		#undef  LOB_98
		#undef  LOA_97
		#undef  BSL_92
		#undef  QMK_63
		#undef  SCL_59
		#undef  ZER_48
		#undef  FSL_47
		#undef  AST_42
		#undef  SQT_39
		#undef  DQT_34
		#undef  SPC_32
		#undef  ESC_27
		#undef  CRE_13
		#undef  FFD_12
		#undef  VTB_11
		#undef  NLN_10
		#undef  TAB_09
		#undef  BSP_08
		#undef  ALR_07
		#undef  EOT_04
		#undef  ZER_00
		#undef  EOF_N1
	}
	findStatement:{
		statementWall = statementCurrent - 1;
		statementCurrent = statementStart;
		if(!findStringTreeString(currentScopeInstructionStringTreeSystem, &statementCurrent)){
			printConfigError("config error", "unrecognized instruction", ';', true, true, true, true, configPath, statementLine, statementStart, statementWall, NULL, NULL, NULL, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
			jmp printAllInstructionPatterns;
		}
		instructionStart = *(currentScopeInstruction + (*currentScopeInstructionStringTreeSystem).returnedCounter);
		instructionStartCopy = instructionStart;
		instructionCurrent = instructionStart;
		instructionDataStart = *(currentScopeInstructionData + (*currentScopeInstructionStringTreeSystem).returnedCounter);
		instructionDataStartCopy = instructionDataStart;
		instructionDataCurrent = instructionDataStart;
		if(*instructionCurrent == NONE_INSTRUCTION_TYPE){
			jmp unimplementedInstruction;
		}
		if(statementCurrent >= statementWall and *instructionCurrent != END_INSTRUCTION_TYPE){
			printConfigError("config error", "missing instruction body", ';', true, true, true, true, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
			jmp getStatementStart;
		}
		inc statementCurrent;
		jmp switchInstructionLoop;
	}
	switchInstructionLoop: switch(*instructionCurrent){
		to NONE_INSTRUCTION_TYPE: /*------*/ jmp unimplementedInstruction;
		to NAME_INSTRUCTION_TYPE: /*------*/ jmp matchName;
		to NAME_LIST_INSTRUCTION_TYPE: /*-*/ jmp matchNameList;
		to NUMBER_INSTRUCTION_TYPE: /*----*/ jmp matchInteger;
		to STRING_INSTRUCTION_TYPE: /*----*/ jmp matchString;
		to IMAGE_INSTRUCTION_TYPE: /*-----*/ jmp matchImageString;
		off: /*---------------------------*/ jmp endOfInstruction;
	}
	unimplementedInstruction:{
		printConfigError("implementation error", "using unimplemented instruction", ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, NULL, NULL, NULL, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
		jmp getStatementStart;
	}
	matchName:{
		char *s;
		uint8 *namePointer;
		if(statementCurrent >= statementWall){
			jmp printMissingArgumentError;
		}
		if(!name0Instruction){
			namePointer = &name0Return;
			name0Instruction = instructionCurrent;
		}elif(!name1Instruction){
			namePointer = &name1Return;
			name1Instruction = instructionCurrent;
		}elif(!name2Instruction){
			namePointer = &name2Return;
			name2Instruction = instructionCurrent;
		}elif(!name3Instruction){
			namePointer = &name3Return;
			name3Instruction = instructionCurrent;
		}else{
			namePointer = &name4Return;
			name4Instruction = instructionCurrent;
		}
		s = statementCurrent;
		if(!findStringTreeString(*instructionDataCurrent, &s)){
			printConfigError("match string error", "invalid name", ';', true, true, true, true, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
			jmp getStatementStart;
		}
		statementCurrent = s;
		inc statementCurrent;
		*namePointer = (**instructionDataCurrent).returnedCounter;
		jmp advanceDataInstruction;
	}
	matchNameList:{
		uint8 *nameListPointer;
		if(statementCurrent >= statementWall){
			jmp printMissingArgumentError;
		}
		if(!nameList0Instruction){
			nameListPointer = &nameList0Return;
			nameList0Instruction = instructionCurrent;
		}elif(!nameList1Instruction){
			nameListPointer = &nameList1Return;
			nameList1Instruction = instructionCurrent;
		}elif(!nameList2Instruction){
			nameListPointer = &nameList2Return;
			nameList2Instruction = instructionCurrent;
		}elif(!nameList3Instruction){
			nameListPointer = &nameList3Return;
			nameList3Instruction = instructionCurrent;
		}else{
			nameListPointer = &nameList4Return;
			nameList4Instruction = instructionCurrent;
		}
		switch(matchNameList(*instructionDataCurrent, statementWall, &statementCurrent, nameListPointer)){
			to INVALID_NAME_NAME_LIST: /*--*/ jmp invalidNameNameList;
			to PREMATURE_END_NAME_LIST: /*-*/ jmp prematureEndNameList;
			off: /*------------------------*/ jmp advanceDataInstruction;
		}
	}
	invalidNameNameList:{
		printConfigError("bar list error", "invalid name", ';', true, true, true, true, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
		jmp getStatementStart;
	}
	prematureEndNameList:{
		printConfigError("bar list error", "missing final name", ';', true, true, true, true, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
		jmp getStatementStart;
	}
	matchInteger:{
		int64 *integerPointer;
		if(statementCurrent >= statementWall){
			jmp printMissingArgumentError;
		}
		if(!integer0Instruction){
			integerPointer = &integer0Return;
			integer0Instruction = instructionCurrent;
		}elif(!integer1Instruction){
			integerPointer = &integer1Return;
			integer1Instruction = instructionCurrent;
		}elif(!integer2Instruction){
			integerPointer = &integer2Return;
			integer2Instruction = instructionCurrent;
		}elif(!integer3Instruction){
			integerPointer = &integer3Return;
			integer3Instruction = instructionCurrent;
		}else{
			integerPointer = &integer4Return;
			integer4Instruction = instructionCurrent;
		}
		switch(matchInteger(&statementCurrent, statementWall, integerPointer)){
			to NON_NUMBER_NUMBER: /*-------*/ jmp printNonNumberError;
			to OVERFLOWN_NUMBER_NUMBER: /*-*/ jmp printOverflownNumberError;
			to DIVIDED_BY_ZERO_NUMBER: /*--*/ jmp printDividedByZeroNumberError;
			off: /*------------------------*/ jmp advanceInstruction;
		}
	}
	printNonNumberError:{
		printConfigError("match integer error", "not a number", ';', true, true, true, true, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
		jmp getStatementStart;
	}
	printOverflownNumberError:{
		printConfigError("match integer error", "integer overflow", ';', true, true, true, true, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
		jmp getStatementStart;
	}
	printDividedByZeroNumberError:{
		printConfigError("match integer error", "integer divided by zero", ';', true, true, true, true, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
		jmp getStatementStart;
	}
	matchString:{
		char **stringPointer;
		uint32 *stringTokenPointer;
		if(statementCurrent >= statementWall){
			jmp printMissingArgumentError;
		}
		if(!string0Instruction){
			stringPointer = &string0Return;
			stringTokenPointer = &string0Token;
			string0Instruction = instructionCurrent;
		}elif(!string1Instruction){
			stringPointer = &string1Return;
			stringTokenPointer = &string1Token;
			string1Instruction = instructionCurrent;
		}elif(!string2Instruction){
			stringPointer = &string2Return;
			stringTokenPointer = &string2Token;
			string2Instruction = instructionCurrent;
		}elif(!string3Instruction){
			stringPointer = &string3Return;
			stringTokenPointer = &string3Token;
			string3Instruction = instructionCurrent;
		}else{
			stringPointer = &string4Return;
			stringTokenPointer = &string4Token;
			string4Instruction = instructionCurrent;
		}
		if(!matchString(&statementCurrent, stringPointer, stringTokenPointer)){
			printConfigError("match string error", "could not allocate string data", ';', true, true, false, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
			jmp getStatementStart;
		}
		jmp advanceInstruction;
	}
	matchImageString:{
		char *string = NULL;
		uint32 token = 0;
		Image *imagePointer;
		uint8 matchImageReturn;
		if(statementCurrent >= statementWall){
			jmp printMissingArgumentError;
		}
		if(!image0Instruction){
			imagePointer = &image0Return;
			image0Instruction = instructionCurrent;
		}elif(!image1Instruction){
			imagePointer = &image1Return;
			image1Instruction = instructionCurrent;
		}elif(!image2Instruction){
			imagePointer = &image2Return;
			image2Instruction = instructionCurrent;
		}elif(!image3Instruction){
			imagePointer = &image3Return;
			image3Instruction = instructionCurrent;
		}else{
			imagePointer = &image4Return;
			image4Instruction = instructionCurrent;
		}
		if(!matchString(&statementCurrent, &string, &token)){
			printConfigError("match image error", "could not allocate image string data", ';', true, true, false, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
			jmp getStatementStart;
		}
		matchImageReturn = matchImage(string, &imageErrorMessage, &image0Return);
		free(string);
		popPointer(token);
		switch(matchImageReturn){
			to CANNOT_OPEN_MATCH_IMAGE: /*--------*/ jmp printCannotOpenReadConfig;
			to CANNOT_READ_MATCH_IMAGE: /*--------*/ jmp printCannotReadReadConfig;
			to UNSUPPORTED_FORMAT_MATCH_IMAGE: /*-*/ jmp printUnsupportedFormatReadConfig;
			to BAD_HEADER_MATCH_IMAGE: /*---------*/ jmp printBadHeaderReadConfig;
			to BAD_DEPTH_MATCH_IMAGE: /*----------*/ jmp printBadDepthReadConfig;
			to BAD_COMPRESSION_MATCH_IMAGE: /*----*/ jmp printBadCompressionReadConfig;
			to UNSUPPORTED_HEIGHT_MATCH_IMAGE: /*-*/ jmp printUnsupportedHeightReadConfig;
			to BAD_SIZE_MATCH_IMAGE: /*-----------*/ jmp printBadSizeReadConfig;
			to FAILED_MATCH_IMAGE: /*-------------*/ jmp printFailedReadConfig;
			to BAD_PIXELS_MATCH_IMAGE: /*---------*/ jmp printBadPixelsReadConfig;
			to BAD_IMAGE_MATCH_IMAGE: /*----------*/ jmp printBadImageReadConfig;
			off: /*-------------------------------*/ jmp advanceInstruction;
		}
	}
	printCannotOpenReadConfig:{
		printConfigError("match image error", "could not open image file", ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
		jmp getStatementStart;
	}
	printCannotReadReadConfig:{
		printConfigError("match image error", "could not read image file", ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
		jmp getStatementStart;
	}
	printUnsupportedFormatReadConfig:{
		printConfigError("match image error", "image file not bmp", ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
		jmp getStatementStart;
	}
	printBadHeaderReadConfig:{
		printConfigError("match image error", imageErrorMessage, ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
		jmp getStatementStart;
	}
	printBadDepthReadConfig:{
		printConfigError("match image error", imageErrorMessage, ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
		jmp getStatementStart;
	}
	printBadCompressionReadConfig:{
		printConfigError("match image error", imageErrorMessage, ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
		jmp getStatementStart;
	}
	printUnsupportedHeightReadConfig:{
		printConfigError("match image error", "negative height is not supported", ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
		jmp getStatementStart;
	}
	printBadSizeReadConfig:{
		printConfigError("match image error", "could not traverse image past the header", ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
		jmp getStatementStart;
	}
	printFailedReadConfig:{
		printConfigError("match image error", "could not allocate pixels", ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
		jmp getStatementStart;
	}
	printBadPixelsReadConfig:{
		printConfigError("match image error", "could not read pixels", ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
		jmp getStatementStart;
	}
	printBadImageReadConfig:{
		printConfigError("match image error", "image is broken", ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
		jmp getStatementStart;
	}
	endOfInstruction:{
		if(instructionStart == setInstruction){
			#define applySubinstruction(s, i) /*-*/ instructionStart = s##i##Subinstruction; instructionDataStart = s##i##SubinstructionData
			switch(name0Return){
				off: /*-*/ brk;
			}
		}
		if(instructionStart == doInstruction){
			switch(name0Return){
				to EXECUTE_COMMAND: /*---------------------*/ applySubinstruction(execute, Do); /*-----------------*/ jmp assessSubinstruction;
				to PLACE_TOP_COMMAND: /*-------------------*/ applySubinstruction(placeTop, Do); /*----------------*/ jmp assessSubinstruction;
				to PLACE_BOTTOM_COMMAND: /*----------------*/ applySubinstruction(placeBottom, Do); /*-------------*/ jmp assessSubinstruction;
				to PLACE_LEFT_COMMAND: /*------------------*/ applySubinstruction(placeLeft, Do); /*---------------*/ jmp assessSubinstruction;
				to PLACE_RIGHT_COMMAND: /*-----------------*/ applySubinstruction(placeRight, Do); /*--------------*/ jmp assessSubinstruction;
				to PLACE_TOP_LEFT_COMMAND: /*--------------*/ applySubinstruction(placeTopLeft, Do); /*------------*/ jmp assessSubinstruction;
				to PLACE_TOP_RIGHT_COMMAND: /*-------------*/ applySubinstruction(placeTopRight, Do); /*-----------*/ jmp assessSubinstruction;
				to PLACE_BOTTOM_LEFT_COMMAND: /*-----------*/ applySubinstruction(placeBottomLeft, Do); /*---------*/ jmp assessSubinstruction;
				to PLACE_BOTTOM_RIGHT_COMMAND: /*----------*/ applySubinstruction(placeBottomRight, Do); /*--------*/ jmp assessSubinstruction;
				to PLACE_CENTER_COMMAND: /*----------------*/ applySubinstruction(placeCenter, Do); /*-------------*/ jmp assessSubinstruction;
				to PLACE_FULL_COMMAND: /*------------------*/ applySubinstruction(placeFull, Do); /*---------------*/ jmp assessSubinstruction;
				to MOVE_COMMAND: /*------------------------*/ applySubinstruction(move, Do); /*--------------------*/ jmp assessSubinstruction;
				to RESIZE_COMMAND: /*----------------------*/ applySubinstruction(resize, Do); /*------------------*/ jmp assessSubinstruction;
				to ENTER_MAXIMIZED_COMMAND: /*-------------*/ applySubinstruction(enterMaximized, Do); /*----------*/ jmp assessSubinstruction;
				to TOGGLE_MAXIMIZED_COMMAND: /*------------*/ applySubinstruction(toggleMaximized, Do); /*---------*/ jmp assessSubinstruction;
				to ENTER_FULLSCREEN_COMMAND: /*------------*/ applySubinstruction(enterFullscreen, Do); /*---------*/ jmp assessSubinstruction;
				to TOGGLE_FULLSCREEN_COMMAND: /*-----------*/ applySubinstruction(toggleFullscreen, Do); /*--------*/ jmp assessSubinstruction;
				to GO_TO_WORKSPACE_COMMAND: /*-------------*/ applySubinstruction(goToWorkspace, Do); /*-----------*/ jmp assessSubinstruction;
				to MOVE_WINDOW_TO_WORKSPACE_COMMAND: /*----*/ applySubinstruction(moveWindowToWorkspace, Do); /*---*/ jmp assessSubinstruction;
				to GO_TO_WORKSPACE_WITH_WINDOW_COMMAND: /*-*/ applySubinstruction(goToWorkspaceWithWindow, Do); /*-*/ jmp assessSubinstruction;
				off: /*------------------------------------*/ /*---------------------------------------------------*/ brk;
			}
		}
		if(instructionStart == grabKeycodeInstruction){
			switch(name0Return){
				to EXECUTE_COMMAND: /*---------------------*/ applySubinstruction(execute, GrabKeycode); /*-----------------*/ jmp assessSubinstruction;
				to PLACE_TOP_COMMAND: /*-------------------*/ applySubinstruction(placeTop, GrabKeycode); /*----------------*/ jmp assessSubinstruction;
				to PLACE_BOTTOM_COMMAND: /*----------------*/ applySubinstruction(placeBottom, GrabKeycode); /*-------------*/ jmp assessSubinstruction;
				to PLACE_LEFT_COMMAND: /*------------------*/ applySubinstruction(placeLeft, GrabKeycode); /*---------------*/ jmp assessSubinstruction;
				to PLACE_RIGHT_COMMAND: /*-----------------*/ applySubinstruction(placeRight, GrabKeycode); /*--------------*/ jmp assessSubinstruction;
				to PLACE_TOP_LEFT_COMMAND: /*--------------*/ applySubinstruction(placeTopLeft, GrabKeycode); /*------------*/ jmp assessSubinstruction;
				to PLACE_TOP_RIGHT_COMMAND: /*-------------*/ applySubinstruction(placeTopRight, GrabKeycode); /*-----------*/ jmp assessSubinstruction;
				to PLACE_BOTTOM_LEFT_COMMAND: /*-----------*/ applySubinstruction(placeBottomLeft, GrabKeycode); /*---------*/ jmp assessSubinstruction;
				to PLACE_BOTTOM_RIGHT_COMMAND: /*----------*/ applySubinstruction(placeBottomRight, GrabKeycode); /*--------*/ jmp assessSubinstruction;
				to PLACE_CENTER_COMMAND: /*----------------*/ applySubinstruction(placeCenter, GrabKeycode); /*-------------*/ jmp assessSubinstruction;
				to PLACE_FULL_COMMAND: /*------------------*/ applySubinstruction(placeFull, GrabKeycode); /*---------------*/ jmp assessSubinstruction;
				to MOVE_COMMAND: /*------------------------*/ applySubinstruction(move, GrabKeycode); /*--------------------*/ jmp assessSubinstruction;
				to RESIZE_COMMAND: /*----------------------*/ applySubinstruction(resize, GrabKeycode); /*------------------*/ jmp assessSubinstruction;
				to ENTER_MAXIMIZED_COMMAND: /*-------------*/ applySubinstruction(enterMaximized, GrabKeycode); /*----------*/ jmp assessSubinstruction;
				to TOGGLE_MAXIMIZED_COMMAND: /*------------*/ applySubinstruction(toggleMaximized, GrabKeycode); /*---------*/ jmp assessSubinstruction;
				to ENTER_FULLSCREEN_COMMAND: /*------------*/ applySubinstruction(enterFullscreen, GrabKeycode); /*---------*/ jmp assessSubinstruction;
				to TOGGLE_FULLSCREEN_COMMAND: /*-----------*/ applySubinstruction(toggleFullscreen, GrabKeycode); /*--------*/ jmp assessSubinstruction;
				to GO_TO_WORKSPACE_COMMAND: /*-------------*/ applySubinstruction(goToWorkspace, GrabKeycode); /*-----------*/ jmp assessSubinstruction;
				to MOVE_WINDOW_TO_WORKSPACE_COMMAND: /*----*/ applySubinstruction(moveWindowToWorkspace, GrabKeycode); /*---*/ jmp assessSubinstruction;
				to GO_TO_WORKSPACE_WITH_WINDOW_COMMAND: /*-*/ applySubinstruction(goToWorkspaceWithWindow, GrabKeycode); /*-*/ jmp assessSubinstruction;
				off: /*------------------------------------*/ /*------------------------------------------------------------*/ brk;
			}
		}
		if(instructionStart == grabButtonInstruction){
			switch(name0Return){
				to EXECUTE_COMMAND: /*---------------------*/ applySubinstruction(execute, GrabButton); /*-----------------*/ jmp assessSubinstruction;
				to PLACE_TOP_COMMAND: /*-------------------*/ applySubinstruction(placeTop, GrabButton); /*----------------*/ jmp assessSubinstruction;
				to PLACE_BOTTOM_COMMAND: /*----------------*/ applySubinstruction(placeBottom, GrabButton); /*-------------*/ jmp assessSubinstruction;
				to PLACE_LEFT_COMMAND: /*------------------*/ applySubinstruction(placeLeft, GrabButton); /*---------------*/ jmp assessSubinstruction;
				to PLACE_RIGHT_COMMAND: /*-----------------*/ applySubinstruction(placeRight, GrabButton); /*--------------*/ jmp assessSubinstruction;
				to PLACE_TOP_LEFT_COMMAND: /*--------------*/ applySubinstruction(placeTopLeft, GrabButton); /*------------*/ jmp assessSubinstruction;
				to PLACE_TOP_RIGHT_COMMAND: /*-------------*/ applySubinstruction(placeTopRight, GrabButton); /*-----------*/ jmp assessSubinstruction;
				to PLACE_BOTTOM_LEFT_COMMAND: /*-----------*/ applySubinstruction(placeBottomLeft, GrabButton); /*---------*/ jmp assessSubinstruction;
				to PLACE_BOTTOM_RIGHT_COMMAND: /*----------*/ applySubinstruction(placeBottomRight, GrabButton); /*--------*/ jmp assessSubinstruction;
				to PLACE_CENTER_COMMAND: /*----------------*/ applySubinstruction(placeCenter, GrabButton); /*-------------*/ jmp assessSubinstruction;
				to PLACE_FULL_COMMAND: /*------------------*/ applySubinstruction(placeFull, GrabButton); /*---------------*/ jmp assessSubinstruction;
				to MOVE_COMMAND: /*------------------------*/ applySubinstruction(move, GrabButton); /*--------------------*/ jmp assessSubinstruction;
				to RESIZE_COMMAND: /*----------------------*/ applySubinstruction(resize, GrabButton); /*------------------*/ jmp assessSubinstruction;
				to ENTER_MAXIMIZED_COMMAND: /*-------------*/ applySubinstruction(enterMaximized, GrabButton); /*----------*/ jmp assessSubinstruction;
				to TOGGLE_MAXIMIZED_COMMAND: /*------------*/ applySubinstruction(toggleMaximized, GrabButton); /*---------*/ jmp assessSubinstruction;
				to ENTER_FULLSCREEN_COMMAND: /*------------*/ applySubinstruction(enterFullscreen, GrabButton); /*---------*/ jmp assessSubinstruction;
				to TOGGLE_FULLSCREEN_COMMAND: /*-----------*/ applySubinstruction(toggleFullscreen, GrabButton); /*--------*/ jmp assessSubinstruction;
				to GO_TO_WORKSPACE_COMMAND: /*-------------*/ applySubinstruction(goToWorkspace, GrabButton); /*-----------*/ jmp assessSubinstruction;
				to MOVE_WINDOW_TO_WORKSPACE_COMMAND: /*----*/ applySubinstruction(moveWindowToWorkspace, GrabButton); /*---*/ jmp assessSubinstruction;
				to GO_TO_WORKSPACE_WITH_WINDOW_COMMAND: /*-*/ applySubinstruction(goToWorkspaceWithWindow, GrabButton); /*-*/ jmp assessSubinstruction;
				off: /*------------------------------------*/ /*-----------------------------------------------------------*/ brk;
			}
			#undef  applySubinstruction
		}
		if(statementCurrent < statementWall){
			printConfigError("config error", "extra parameters error", ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
			jmp getStatementStart;
		}
		if(instructionStartCopy == helpInstruction){
			printError("%s%s: %s: line %u: %s%s:%s %s:\n", colorStart, programName, configPath, statementLine, colorError, "config help menu", colorEnd, displaySimpleConfigErrors? "contracted" : "expanded");
			jmp printAllInstructionPatterns;
		}
		if(instructionStartCopy == expandInstruction){
			displaySimpleConfigErrors = false;
			jmp getStatementStart;
		}
		if(instructionStartCopy == contractInstruction){
			displaySimpleConfigErrors = true;
			jmp getStatementStart;
		}
		if(instructionStartCopy == readConfigInstruction){
			readConfig(false, string0Return, &ifgetc, NULL);
			jmp getStatementStart;
		}
		if(instructionStartCopy == useTerminalInstruction){
			switch(name0Return){
				to TRUE_BOOLEAN:{
					if(!connectSTDIN(&stdinSystem)){
						printConfigError("config error", "terminal messaging already enabled", ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
					}
					jmp getStatementStart;
				}
				to FALSE_BOOLEAN:{
					if(!disconnectSTDIN(&stdinSystem)){
						printConfigError("config error", "terminal messaging not enabled", ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
						jmp getStatementStart;
					}
					jmp getStatementStart;
				}
				off:{
					jmp getStatementStart;
				}
			}
		}
		if(instructionStartCopy == useMessengerInstruction){
			switch(name0Return){
				to TRUE_BOOLEAN:{
					if(!connectSharedMemory(&sharedMemorySystem)){
						printConfigError("config error", "shared memory messaging already enabled", ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
					}
					jmp getStatementStart;
				}
				to FALSE_BOOLEAN:{
					if(!disconnectSharedMemory(&sharedMemorySystem)){
						printConfigError("config error", "shared memory messaging not enabled", ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
					}
					jmp getStatementStart;
				}
				off:{
					jmp getStatementStart;
				}
			}
		}
		if(instructionStartCopy == setInstruction){
			switch(name0Return){
				off:{
					jmp getStatementStart;
				}
			}
		}
		if(instructionStartCopy == doInstruction){
			int32 field0 = 0;
			int32 field1 = 0;
			int32 field2 = 0;
			int32 field3 = 0;
			int32 field4 = 0;
			switch(name0Return){
				to EXECUTE_COMMAND: /*---------------------*/ /*---------------------------*/ /*--------------------*/ brk;
				to PLACE_TOP_COMMAND: /*-------------------*/ field0 = name1Return; /*-----*/ /*--------------------*/ brk;
				to PLACE_BOTTOM_COMMAND: /*----------------*/ field0 = name1Return; /*-----*/ /*--------------------*/ brk;
				to PLACE_LEFT_COMMAND: /*------------------*/ field0 = name1Return; /*-----*/ /*--------------------*/ brk;
				to PLACE_RIGHT_COMMAND: /*-----------------*/ field0 = name1Return; /*-----*/ /*--------------------*/ brk;
				to PLACE_TOP_LEFT_COMMAND: /*--------------*/ field0 = name1Return; /*-----*/ /*--------------------*/ brk;
				to PLACE_TOP_RIGHT_COMMAND: /*-------------*/ field0 = name1Return; /*-----*/ /*--------------------*/ brk;
				to PLACE_BOTTOM_LEFT_COMMAND: /*-----------*/ field0 = name1Return; /*-----*/ /*--------------------*/ brk;
				to PLACE_BOTTOM_RIGHT_COMMAND: /*----------*/ field0 = name1Return; /*-----*/ /*--------------------*/ brk;
				to PLACE_CENTER_COMMAND: /*----------------*/ field0 = name1Return; /*-----*/ /*--------------------*/ brk;
				to PLACE_FULL_COMMAND: /*------------------*/ field0 = name1Return; /*-----*/ /*--------------------*/ brk;
				to MOVE_COMMAND: /*------------------------*/ field0 = nameList0Return; /*-*/ field1 = integer0Return; brk;
				to RESIZE_COMMAND: /*----------------------*/ field0 = nameList0Return; /*-*/ field1 = integer0Return; brk;
				to ENTER_MAXIMIZED_COMMAND: /*-------------*/ field0 = name1Return; /*-----*/ /*--------------------*/ brk;
				to TOGGLE_MAXIMIZED_COMMAND: /*------------*/ field0 = name1Return; /*-----*/ /*--------------------*/ brk;
				to ENTER_FULLSCREEN_COMMAND: /*------------*/ field0 = name1Return; /*-----*/ /*--------------------*/ brk;
				to TOGGLE_FULLSCREEN_COMMAND: /*-----------*/ field0 = name1Return; /*-----*/ /*--------------------*/ brk;
				to GO_TO_WORKSPACE_COMMAND: /*-------------*/ field0 = integer0Return; /*--*/ /*--------------------*/ brk;
				to MOVE_WINDOW_TO_WORKSPACE_COMMAND: /*----*/ field0 = integer0Return; /*--*/ /*--------------------*/ brk;
				to GO_TO_WORKSPACE_WITH_WINDOW_COMMAND: /*-*/ field0 = integer0Return; /*--*/ /*--------------------*/ brk;
				off: /*------------------------------------*/ /*---------------------------*/ /*--------------------*/ brk;
			}
			switch(matchCommand(name0Return, string0Return, getNextConfigChar == &ifgetc? CONFIG_MATCH_COMMAND_ORIGIN : getNextConfigChar == &getNextSTDINCharacter? STDIN_MATCH_COMMAND_ORIGIN : TRANSMITTER_MATCH_COMMAND_ORIGIN, field0, field1, field2, field3, field4)){
				to TYPICAL_MATCH_COMMAND_TYPE:{
					jmp getStatementStart;
				}
				to RESTART_MATCH_COMMAND_TYPE:{
					jmp getStatementStart;
				}
				to EXIT_MATCH_COMMAND_TYPE:{
					jmp getStatementStart;
				}
				off:{
					printConfigError("config error", "do subinstruction not implemented yet", ';', true, true, true, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionStart, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
					jmp getStatementStart;
				}
			}
		}
		if(instructionStartCopy == grabKeycodeInstruction){
			int32 field0 = 0;
			int32 field1 = 0;
			int32 field2 = 0;
			int32 field3 = 0;
			int32 field4 = 0;
			switch(name0Return){
				to EXECUTE_COMMAND: /*---------------------*/ /*---------------------------*/ /*--------------------*/ brk;
				to PLACE_TOP_COMMAND: /*-------------------*/ field0 = name1Return; /*-----*/ /*--------------------*/ brk;
				to PLACE_BOTTOM_COMMAND: /*----------------*/ field0 = name1Return; /*-----*/ /*--------------------*/ brk;
				to PLACE_LEFT_COMMAND: /*------------------*/ field0 = name1Return; /*-----*/ /*--------------------*/ brk;
				to PLACE_RIGHT_COMMAND: /*-----------------*/ field0 = name1Return; /*-----*/ /*--------------------*/ brk;
				to PLACE_TOP_LEFT_COMMAND: /*--------------*/ field0 = name1Return; /*-----*/ /*--------------------*/ brk;
				to PLACE_TOP_RIGHT_COMMAND: /*-------------*/ field0 = name1Return; /*-----*/ /*--------------------*/ brk;
				to PLACE_BOTTOM_LEFT_COMMAND: /*-----------*/ field0 = name1Return; /*-----*/ /*--------------------*/ brk;
				to PLACE_BOTTOM_RIGHT_COMMAND: /*----------*/ field0 = name1Return; /*-----*/ /*--------------------*/ brk;
				to PLACE_CENTER_COMMAND: /*----------------*/ field0 = name1Return; /*-----*/ /*--------------------*/ brk;
				to PLACE_FULL_COMMAND: /*------------------*/ field0 = name1Return; /*-----*/ /*--------------------*/ brk;
				to MOVE_COMMAND: /*------------------------*/ field0 = nameList2Return; /*-*/ field1 = integer1Return; brk;
				to RESIZE_COMMAND: /*----------------------*/ field0 = nameList2Return; /*-*/ field1 = integer1Return; brk;
				to ENTER_MAXIMIZED_COMMAND: /*-------------*/ field0 = name1Return; /*-----*/ /*--------------------*/ brk;
				to TOGGLE_MAXIMIZED_COMMAND: /*------------*/ field0 = name1Return; /*-----*/ /*--------------------*/ brk;
				to ENTER_FULLSCREEN_COMMAND: /*------------*/ field0 = name1Return; /*-----*/ /*--------------------*/ brk;
				to TOGGLE_FULLSCREEN_COMMAND: /*-----------*/ field0 = name1Return; /*-----*/ /*--------------------*/ brk;
				to GO_TO_WORKSPACE_COMMAND: /*-------------*/ field0 = integer1Return; /*--*/ /*--------------------*/ brk;
				to MOVE_WINDOW_TO_WORKSPACE_COMMAND: /*----*/ field0 = integer1Return; /*--*/ /*--------------------*/ brk;
				to GO_TO_WORKSPACE_WITH_WINDOW_COMMAND: /*-*/ field0 = integer1Return; /*--*/ /*--------------------*/ brk;
				off: /*------------------------------------*/ /*---------------------------*/ /*--------------------*/ brk;
			}
			if(!insertShortcut(&keycodeShortcutSystem, integer0Return, nameList0Return, nameList1Return, name0Return, string0Return, string0Token, field0, field1, field2, field3, field4)){
				printConfigError("shortcut error", "could not insert shortcut", ';', true, true, false, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
				jmp getStatementStart;
			}
			string0Return = NULL;
			string0Token = 0;
			{
				const xcb_void_cookie_t cookie = xcb_grab_key_checked(connection, true, (*screen).root, nameList0Return, integer0Return, XCB_GRAB_MODE_ASYNC, XCB_GRAB_MODE_ASYNC);
				xcb_generic_error_t *const error = xcb_request_check(connection, cookie);
				uint32 token = pushPointer(error, "grab key check pointer", iFree);
				if(error){
					printConfigError("shortcut error", "could not grab key on root", ';', true, true, false, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
					free(error);
					popPointer(token);
				}
			}
			jmp getStatementStart;
		}
		if(instructionStartCopy == grabButtonInstruction){
			int32 field0 = 0;
			int32 field1 = 0;
			int32 field2 = 0;
			int32 field3 = 0;
			int32 field4 = 0;
			switch(name0Return){
				to EXECUTE_COMMAND: /*---------------------*/ /*---------------------------*/ /*--------------------*/ brk;
				to PLACE_TOP_COMMAND: /*-------------------*/ field0 = name1Return; /*-----*/ /*--------------------*/ brk;
				to PLACE_BOTTOM_COMMAND: /*----------------*/ field0 = name1Return; /*-----*/ /*--------------------*/ brk;
				to PLACE_LEFT_COMMAND: /*------------------*/ field0 = name1Return; /*-----*/ /*--------------------*/ brk;
				to PLACE_RIGHT_COMMAND: /*-----------------*/ field0 = name1Return; /*-----*/ /*--------------------*/ brk;
				to PLACE_TOP_LEFT_COMMAND: /*--------------*/ field0 = name1Return; /*-----*/ /*--------------------*/ brk;
				to PLACE_TOP_RIGHT_COMMAND: /*-------------*/ field0 = name1Return; /*-----*/ /*--------------------*/ brk;
				to PLACE_BOTTOM_LEFT_COMMAND: /*-----------*/ field0 = name1Return; /*-----*/ /*--------------------*/ brk;
				to PLACE_BOTTOM_RIGHT_COMMAND: /*----------*/ field0 = name1Return; /*-----*/ /*--------------------*/ brk;
				to PLACE_CENTER_COMMAND: /*----------------*/ field0 = name1Return; /*-----*/ /*--------------------*/ brk;
				to PLACE_FULL_COMMAND: /*------------------*/ field0 = name1Return; /*-----*/ /*--------------------*/ brk;
				to MOVE_COMMAND: /*------------------------*/ field0 = nameList2Return; /*-*/ field1 = integer1Return; brk;
				to RESIZE_COMMAND: /*----------------------*/ field0 = nameList2Return; /*-*/ field1 = integer1Return; brk;
				to ENTER_MAXIMIZED_COMMAND: /*-------------*/ field0 = name1Return; /*-----*/ /*--------------------*/ brk;
				to TOGGLE_MAXIMIZED_COMMAND: /*------------*/ field0 = name1Return; /*-----*/ /*--------------------*/ brk;
				to ENTER_FULLSCREEN_COMMAND: /*------------*/ field0 = name1Return; /*-----*/ /*--------------------*/ brk;
				to TOGGLE_FULLSCREEN_COMMAND: /*-----------*/ field0 = name1Return; /*-----*/ /*--------------------*/ brk;
				to GO_TO_WORKSPACE_COMMAND: /*-------------*/ field0 = integer1Return; /*--*/ /*--------------------*/ brk;
				to MOVE_WINDOW_TO_WORKSPACE_COMMAND: /*----*/ field0 = integer1Return; /*--*/ /*--------------------*/ brk;
				to GO_TO_WORKSPACE_WITH_WINDOW_COMMAND: /*-*/ field0 = integer1Return; /*--*/ /*--------------------*/ brk;
				off: /*------------------------------------*/ /*---------------------------*/ /*--------------------*/ brk;
			}
			if(!insertShortcut(&buttonShortcutSystem, integer0Return, nameList0Return, nameList1Return, name0Return, string0Return, string0Token, field0, field1, field2, field3, field4)){
				printConfigError("shortcut error", "could not insert shortcut", ';', true, true, false, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
				jmp getStatementStart;
			}
			string0Return = NULL;
			string0Token = 0;
			{
				const xcb_void_cookie_t cookie = xcb_grab_button_checked(connection, true, (*screen).root, XCB_EVENT_MASK_NO_EVENT, XCB_GRAB_MODE_ASYNC, XCB_GRAB_MODE_ASYNC, XCB_NONE, XCB_NONE, integer0Return, nameList0Return);
				xcb_generic_error_t *const error = xcb_request_check(connection, cookie);
				uint32 token = pushPointer(error, "grab button check pointer", iFree);
				if(error){
					printConfigError("shortcut error", "could not grab button on root", ';', true, true, false, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
					free(error);
					popPointer(token);
				}
			}
			jmp getStatementStart;
		}
		if(instructionStartCopy == ungrabKeycodeInstruction){
			if(!removeShortcut(&keycodeShortcutSystem, integer0Return, nameList0Return)){
				printConfigError("shortcut error", "could not find key to ungrab", ';', true, true, false, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
				jmp getStatementStart;
			}
			{
				const xcb_void_cookie_t cookie = xcb_ungrab_key_checked(connection, integer0Return, (*screen).root, nameList0Return);
				xcb_generic_error_t *const error = xcb_request_check(connection, cookie);
				uint32 token = pushPointer(error, "ungrab key check pointer", iFree);
				if(error){
					printConfigError("shortcut error", "could not ungrab key from root", ';', true, true, false, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
					free(error);
					popPointer(token);
				}
			}
			jmp getStatementStart;
		}
		if(instructionStartCopy == ungrabButtonInstruction){
			if(!removeShortcut(&buttonShortcutSystem, integer0Return, nameList0Return)){
				printConfigError("shortcut error", "could not find button to ungrab", ';', true, true, false, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
				jmp getStatementStart;
			}
			{
				const xcb_void_cookie_t cookie = xcb_ungrab_button_checked(connection, integer0Return, (*screen).root, nameList0Return);
				xcb_generic_error_t *const error = xcb_request_check(connection, cookie);
				uint32 token = pushPointer(error, "ungrab button check pointer", iFree);
				if(error){
					printConfigError("shortcut error", "could not ungrab button from root", ';', true, true, false, false, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
					free(error);
					popPointer(token);
				}
			}
			jmp getStatementStart;
		}
		if(instructionStartCopy == stopInstruction){
			jmp successfulConfig;
		}
		jmp getStatementStart;
	}
	advanceInstruction:{
		inc instructionCurrent;
		jmp switchInstructionLoop;
	}
	advanceDataInstruction:{
		inc instructionCurrent;
		inc instructionDataCurrent;
		jmp switchInstructionLoop;
	}
	assessSubinstruction:{
		instructionCurrent = instructionStart + (instructionCurrent - instructionStartCopy);
		instructionDataCurrent = instructionDataStart + (instructionDataCurrent - instructionDataStartCopy);
		if(statementCurrent < statementWall){
			jmp switchInstructionLoop;
		}
		jmp printMissingArgumentError;
	}
	printMissingArgumentError:{
		printConfigError("config error", "missing argument error", ';', true, true, true, true, configPath, statementLine, statementStart, statementWall, instructionStart, instructionCurrent, instructionDataStart, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
		jmp getStatementStart;
	}
	printAllInstructionPatterns:{
		const char *const *const wall = currentScopeInstructionList + currentScopeInstructionListSize;
		const char *const *current = currentScopeInstructionList;
		const Instruction *const *in = currentScopeInstruction;
		StringTreeSystem *const *const *da = currentScopeInstructionData;
		jmp printExpandedHelpInstructions;
		printExpandedHelpInstructions:{
			const Instruction *n = *in - 1;
			StringTreeSystem *const *d = *da;
			printError("\tpattern | %s", *current);
			jmp printHelpInstructionParametersLoop;
			printHelpInstructionParametersLoop: switch(*(inc n)){
				to NONE_INSTRUCTION_TYPE: /*------*/ jmp noneInstruction;
				to NAME_INSTRUCTION_TYPE: /*------*/ jmp nameInstruction;
				to NAME_LIST_INSTRUCTION_TYPE: /*-*/ jmp nameListInstruction;
				to NUMBER_INSTRUCTION_TYPE: /*----*/ jmp numberInstruction;
				to STRING_INSTRUCTION_TYPE: /*----*/ jmp stringInstruction;
				to IMAGE_INSTRUCTION_TYPE: /*-----*/ jmp imageInstruction;
				off: /*---------------------------*/ jmp printHelpInstructionParametersLoopExit;
			}
			noneInstruction:{
				printError(" <unimplemented>");
				jmp printHelpInstructionParametersLoopExit;
			}
			nameInstruction:{
				if(displaySimpleConfigErrors){
					printError(" name");
					jmp printHelpInstructionParametersLoop;
				}
				if((**d).stringArray){
					const char *const *stringArray = (**d).stringArray;
					printError(" (%s", *stringArray);
					inc stringArray;
					jmp printNameLoop;
					printNameLoop:{
						if(*stringArray){
							printError("|%s", *stringArray);
							inc stringArray;
							jmp printNameLoop;
						}
						printError(")");
					}
				}
				inc d;
				jmp printHelpInstructionParametersLoop;
			}
			nameListInstruction:{
				if(displaySimpleConfigErrors){
					printError(" list");
					jmp printHelpInstructionParametersLoop;
				}
				if((**d).stringArray){
					const char *const *stringArray = (**d).stringArray;
					printError(" ((%s", *stringArray);
					inc stringArray;
					jmp printNameListOnceLoop;
					printNameListOnceLoop:{
						if(*stringArray){
							printError("|%s", *stringArray);
							inc stringArray;
							jmp printNameListOnceLoop;
						}
						stringArray = (**d).stringArray;
						printError(")[\\s]*([\\s]*[|][\\s]*(%s", *stringArray);
						inc stringArray;
						jmp printNameListTwiceLoop;
					}
					printNameListTwiceLoop:{
						if(*stringArray){
							printError("|%s", *stringArray);
							inc stringArray;
							jmp printNameListTwiceLoop;
						}
						printError("))*(?![\\s]*[|]))");
					}
				}
				inc d;
				jmp printHelpInstructionParametersLoop;
			}
			numberInstruction:{
				if(displaySimpleConfigErrors){
					printError(" number");
					jmp printHelpInstructionParametersLoop;
				}
				printError(" (([0][\\s]*[x][\\s]*([a-fA-F0-9][\\s]*)*|([0-9][\\s]*)+|[+*/][\\s]*)+)");
				jmp printHelpInstructionParametersLoop;
			}
			stringInstruction:{
				if(displaySimpleConfigErrors){
					printError(" string");
					jmp printHelpInstructionParametersLoop;
				}
				printError(" ([\"].*[\"]|[\'].*[\'])");
				jmp printHelpInstructionParametersLoop;
			}
			imageInstruction:{
				if(displaySimpleConfigErrors){
					printError(" image");
					jmp printHelpInstructionParametersLoop;
				}
				printError(" ([\"].*[\"]|[\'].*[\'])");
				jmp printHelpInstructionParametersLoop;
			}
		}
		printHelpInstructionParametersLoopExit:{
			inc in;
			inc da;
			if(displaySimpleConfigErrors){
				printError("\n");
			}else{
				printError(" $\n");
			}
			if(inc current < wall){
				jmp printExpandedHelpInstructions;
			}
			printError("\n");
			jmp getStatementStart;
		}
	}
	successfulConfig:{
		if(currentScopeInstruction != globalScopeInstruction){
			*statementCurrent = '\0';
			statementWall = statementCurrent;
			statementLine = fileLine;
			if(fileLine != 1){
				dec statementLine;
			}
			printConfigError("config error", "missing closing scope bracket", '\0', true, false, false, false, configPath, statementLine, statementStart, statementWall, NULL, NULL, NULL, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
		}
		jmp configEmergencyExit;
	}
	configEmergencyExit:{
		if(configFile and fileLine == 1 and !statementLine){
			printConfigError("config warning", "empty config file", '\0', false, false, false, false, configPath, 1, statementStart, statementWall, NULL, NULL, NULL, currentScopeInstructionList, currentScopeInstructionStringTreeSystem);
		}
		free(statementStart);
		popPointer(statementToken);
		if(configFile){
			fclose(configFile);
			popPointer(configFileToken);
		}
		jmp postReadConfig;
	}
	postReadConfig:{
		xcb_flush(connection);
		ret;
	}
	#undef  DEFAULT_CONFIG_PATH
	#undef  STATEMENT_BLOCK_SIZE
}
IFGETC(){
	if(!system){
		ret EOF;
	}
	ret fgetc(system);
}
MATCHNAMELIST(){
	char *current = *statementCurrentReturn;
	uint value = 0;
	jmp matchNameLoop;
	matchNameLoop:{
		if(!findStringTreeString(stringTreeSystem, &current)){
			ret INVALID_NAME_NAME_LIST;
		}
		value |= !!(*stringTreeSystem).returnedCounter * (1 << ((*stringTreeSystem).returnedCounter - 1));
		jmp matchBar;
	}
	matchBar: switch(*(inc current)){
		to '\0': /*-*/ jmp endCheck;
		to '|': /*--*/ jmp advance;
		off: /*-----*/ jmp successful;
	}
	endCheck:{
		if(current >= statementWall){
			jmp successful;
		}
		jmp matchBar;
	}
	advance:{
		if(inc current >= statementWall){
			ret PREMATURE_END_NAME_LIST;
		}
		inc current;
		jmp matchNameLoop;
	}
	successful:{
		*valueReturn = value;
		*statementCurrentReturn = current;
		ret SUCCESS_NAME_LIST;
	}
}
MATCHINTEGER(){
	#define LEVEL0_JMP_POINT /*-*/ (0)
	#define LEVEL1_JMP_POINT /*-*/ (1)
	#define LEVEL2_JMP_POINT /*-*/ (2)
	char *current = *statementCurrent - 1;
	int64 number = 0;
	char op = '\0';
	JmpPoint jmpPoint;
	int64 i0 = 0;
	int64 i1 = 0;
	char o0 = '\0';
	char o1 = '\0';
	jmpPoint = LEVEL0_JMP_POINT;
	jmp matchWhitespace0Loop;
	matchWhitespace0Loop:{
		if(inc current >= statementWall){
			number = 0;
			op = '\0';
			jmp matchOperationReturnPoint;
		}
		switch(*current){
			to '\0': /*-*/ jmp matchOperation;
			to '\t': /*-*/ jmp matchWhitespace0Loop;
			to '\n': /*-*/ jmp matchWhitespace0Loop;
			to '\v': /*-*/ jmp matchWhitespace0Loop;
			to '\f': /*-*/ jmp matchWhitespace0Loop;
			to '\r': /*-*/ jmp matchWhitespace0Loop;
			to ' ': /*--*/ jmp matchWhitespace0Loop;
			off: /*-----*/ jmp matchInteger;
		}
	}
	matchInteger:{
		number = 0;
		dec current;
		jmp initialCheck;
	}
	initialCheck: switch(*(inc current)){
		to '0': /*-*/ /*--------*/ jmp formatCheck;
		to '1': /*-*/ dec current; jmp matchDecimalLoop;
		to '2': /*-*/ dec current; jmp matchDecimalLoop;
		to '3': /*-*/ dec current; jmp matchDecimalLoop;
		to '4': /*-*/ dec current; jmp matchDecimalLoop;
		to '5': /*-*/ dec current; jmp matchDecimalLoop;
		to '6': /*-*/ dec current; jmp matchDecimalLoop;
		to '7': /*-*/ dec current; jmp matchDecimalLoop;
		to '8': /*-*/ dec current; jmp matchDecimalLoop;
		to '9': /*-*/ dec current; jmp matchDecimalLoop;
		to '+': /*-*/ /*--------*/ jmp matchOperation;
		to '-': /*-*/ /*--------*/ jmp matchOperation;
		to '*': /*-*/ /*--------*/ jmp matchOperation;
		to '/': /*-*/ /*--------*/ jmp matchOperation;
		off: /*----*/ /*--------*/ jmp matchMacro;
	}
	formatCheck: switch(*(inc current)){
		to '\0': /*-*/ /*--------*/ jmp matchOperation;
		to '\t': /*-*/ /*--------*/ jmp matchWhitespace1Loop;
		to '\n': /*-*/ /*--------*/ jmp matchWhitespace1Loop;
		to '\v': /*-*/ /*--------*/ jmp matchWhitespace1Loop;
		to '\f': /*-*/ /*--------*/ jmp matchWhitespace1Loop;
		to '\r': /*-*/ /*--------*/ jmp matchWhitespace1Loop;
		to ' ': /*--*/ /*--------*/ jmp matchWhitespace1Loop;
		to '0': /*--*/ dec current; jmp matchOctalLoop;
		to '1': /*--*/ dec current; jmp matchOctalLoop;
		to '2': /*--*/ dec current; jmp matchOctalLoop;
		to '3': /*--*/ dec current; jmp matchOctalLoop;
		to '4': /*--*/ dec current; jmp matchOctalLoop;
		to '5': /*--*/ dec current; jmp matchOctalLoop;
		to '6': /*--*/ dec current; jmp matchOctalLoop;
		to '7': /*--*/ dec current; jmp matchOctalLoop;
		to 'B': /*--*/ /*--------*/ jmp matchBinaryLoop;
		to 'b': /*--*/ /*--------*/ jmp matchBinaryLoop;
		to 'X': /*--*/ /*--------*/ jmp matchHexadecimalLoop;
		to 'x': /*--*/ /*--------*/ jmp matchHexadecimalLoop;
		to '+': /*--*/ /*--------*/ jmp matchOperation;
		to '-': /*--*/ /*--------*/ jmp matchOperation;
		to '*': /*--*/ /*--------*/ jmp matchOperation;
		to '/': /*--*/ /*--------*/ jmp matchOperation;
		off: /*-----*/ /*--------*/ jmp nonNumber;
	}
	matchBinaryLoop: switch(*(inc current)){
		to '\0': /*-*/ jmp matchOperation;
		to '\t': /*-*/ jmp matchWhitespace1Loop;
		to '\n': /*-*/ jmp matchWhitespace1Loop;
		to '\v': /*-*/ jmp matchWhitespace1Loop;
		to '\f': /*-*/ jmp matchWhitespace1Loop;
		to '\r': /*-*/ jmp matchWhitespace1Loop;
		to ' ': /*--*/ jmp matchWhitespace1Loop;
		to '0': /*--*/ jmp calculateBinary;
		to '1': /*--*/ jmp calculateBinary;
		to '+': /*--*/ jmp matchOperation;
		to '-': /*--*/ jmp matchOperation;
		to '*': /*--*/ jmp matchOperation;
		to '/': /*--*/ jmp matchOperation;
		off: /*-----*/ jmp nonNumber;
	}
	matchOctalLoop: switch(*(inc current)){
		to '\0': /*-*/ jmp matchOperation;
		to '\t': /*-*/ jmp matchWhitespace1Loop;
		to '\n': /*-*/ jmp matchWhitespace1Loop;
		to '\v': /*-*/ jmp matchWhitespace1Loop;
		to '\f': /*-*/ jmp matchWhitespace1Loop;
		to '\r': /*-*/ jmp matchWhitespace1Loop;
		to ' ': /*--*/ jmp matchWhitespace1Loop;
		to '0': /*--*/ jmp calculateOctal;
		to '1': /*--*/ jmp calculateOctal;
		to '2': /*--*/ jmp calculateOctal;
		to '3': /*--*/ jmp calculateOctal;
		to '4': /*--*/ jmp calculateOctal;
		to '5': /*--*/ jmp calculateOctal;
		to '6': /*--*/ jmp calculateOctal;
		to '7': /*--*/ jmp calculateOctal;
		to '+': /*--*/ jmp matchOperation;
		to '-': /*--*/ jmp matchOperation;
		to '*': /*--*/ jmp matchOperation;
		to '/': /*--*/ jmp matchOperation;
		off: /*-----*/ jmp nonNumber;
	}
	matchDecimalLoop: switch(*(inc current)){
		to '\0': /*-*/ jmp matchOperation;
		to '\t': /*-*/ jmp matchWhitespace1Loop;
		to '\n': /*-*/ jmp matchWhitespace1Loop;
		to '\v': /*-*/ jmp matchWhitespace1Loop;
		to '\f': /*-*/ jmp matchWhitespace1Loop;
		to '\r': /*-*/ jmp matchWhitespace1Loop;
		to ' ': /*--*/ jmp matchWhitespace1Loop;
		to '0': /*--*/ jmp calculateDecimal;
		to '1': /*--*/ jmp calculateDecimal;
		to '2': /*--*/ jmp calculateDecimal;
		to '3': /*--*/ jmp calculateDecimal;
		to '4': /*--*/ jmp calculateDecimal;
		to '5': /*--*/ jmp calculateDecimal;
		to '6': /*--*/ jmp calculateDecimal;
		to '7': /*--*/ jmp calculateDecimal;
		to '8': /*--*/ jmp calculateDecimal;
		to '9': /*--*/ jmp calculateDecimal;
		to '+': /*--*/ jmp matchOperation;
		to '-': /*--*/ jmp matchOperation;
		to '*': /*--*/ jmp matchOperation;
		to '/': /*--*/ jmp matchOperation;
		off: /*-----*/ jmp nonNumber;
	}
	matchHexadecimalLoop: switch(*(inc current)){
		to '\0': /*-*/ jmp matchOperation;
		to '\t': /*-*/ jmp matchWhitespace1Loop;
		to '\n': /*-*/ jmp matchWhitespace1Loop;
		to '\v': /*-*/ jmp matchWhitespace1Loop;
		to '\f': /*-*/ jmp matchWhitespace1Loop;
		to '\r': /*-*/ jmp matchWhitespace1Loop;
		to ' ': /*--*/ jmp matchWhitespace1Loop;
		to '0': /*--*/ jmp calculateHexadecimal;
		to '1': /*--*/ jmp calculateHexadecimal;
		to '2': /*--*/ jmp calculateHexadecimal;
		to '3': /*--*/ jmp calculateHexadecimal;
		to '4': /*--*/ jmp calculateHexadecimal;
		to '5': /*--*/ jmp calculateHexadecimal;
		to '6': /*--*/ jmp calculateHexadecimal;
		to '7': /*--*/ jmp calculateHexadecimal;
		to '8': /*--*/ jmp calculateHexadecimal;
		to '9': /*--*/ jmp calculateHexadecimal;
		to 'A': /*--*/ jmp calculateHexadecimal;
		to 'B': /*--*/ jmp calculateHexadecimal;
		to 'C': /*--*/ jmp calculateHexadecimal;
		to 'D': /*--*/ jmp calculateHexadecimal;
		to 'E': /*--*/ jmp calculateHexadecimal;
		to 'F': /*--*/ jmp calculateHexadecimal;
		to 'a': /*--*/ jmp calculateHexadecimal;
		to 'b': /*--*/ jmp calculateHexadecimal;
		to 'c': /*--*/ jmp calculateHexadecimal;
		to 'd': /*--*/ jmp calculateHexadecimal;
		to 'e': /*--*/ jmp calculateHexadecimal;
		to 'f': /*--*/ jmp calculateHexadecimal;
		to '+': /*--*/ jmp matchOperation;
		to '-': /*--*/ jmp matchOperation;
		to '*': /*--*/ jmp matchOperation;
		to '/': /*--*/ jmp matchOperation;
		off: /*-----*/ jmp nonNumber;
	}
	matchMacro:{
		if(!findStringTreeString(&macroStringTreeSystem, &current)){
			jmp nonNumber;
		}
		if(macroStringTreeSystem.returnedCounter < 5){
			number = macroStringTreeSystem.returnedCounter;
			inc number;
		}elif(macroStringTreeSystem.returnedCounter < 9){
			number = macroStringTreeSystem.returnedCounter - 5;
		}elif(macroStringTreeSystem.returnedCounter < 11){
			number = macroStringTreeSystem.returnedCounter - 9;
		}elif(macroStringTreeSystem.returnedCounter < 15){
			number = macroStringTreeSystem.returnedCounter - 11;
		}elif(macroStringTreeSystem.returnedCounter < 17){
			number = macroStringTreeSystem.returnedCounter - 15;
		}else{
			number = 0;
		}
		switch(*current){
			to '\0': /*-*/ jmp matchOperation;
			to '\t': /*-*/ jmp matchWhitespace1Loop;
			to '\n': /*-*/ jmp matchWhitespace1Loop;
			to '\v': /*-*/ jmp matchWhitespace1Loop;
			to '\f': /*-*/ jmp matchWhitespace1Loop;
			to '\r': /*-*/ jmp matchWhitespace1Loop;
			to ' ': /*--*/ jmp matchWhitespace1Loop;
			to '+': /*--*/ jmp matchOperation;
			to '-': /*--*/ jmp matchOperation;
			to '*': /*--*/ jmp matchOperation;
			to '/': /*--*/ jmp matchOperation;
			off: /*-----*/ jmp nonNumber;
		}
	}
	calculateBinary:{
		const int copy = number;
		number = number * 2 + *current - 48;
		if(number < copy){
			jmp overflownNumber;
		}
		jmp matchBinaryLoop;
	}
	calculateOctal:{
		const int copy = number;
		number = number * 8 + *current - 48;
		if(number < copy){
			jmp overflownNumber;
		}
		jmp matchOctalLoop;
	}
	calculateDecimal:{
		const int copy = number;
		number = number * 10 + *current - 48;
		if(number < copy){
			jmp overflownNumber;
		}
		jmp matchDecimalLoop;
	}
	calculateHexadecimal:{
		const int copy = number;
		number = number * 16 + *current - (*current >= '0') * 48 - (*current >= 'A') * 7 - (*current >= 'a') * 32;
		if(number < copy){
			jmp overflownNumber;
		}
		jmp matchHexadecimalLoop;
	}
	matchWhitespace1Loop:{
		if(inc current >= statementWall){
			op = '\0';
			jmp matchOperationReturnPoint;
		}
		switch(*current){
			to '\0': /*-*/ jmp matchOperation;
			to '\t': /*-*/ jmp matchWhitespace1Loop;
			to '\n': /*-*/ jmp matchWhitespace1Loop;
			to '\v': /*-*/ jmp matchWhitespace1Loop;
			to '\f': /*-*/ jmp matchWhitespace1Loop;
			to '\r': /*-*/ jmp matchWhitespace1Loop;
			to ' ': /*--*/ jmp matchWhitespace1Loop;
			off: /*-----*/ jmp matchOperation;
		}
	}
	matchOperation: switch(*current){
		to '+': /*-*/ op = *current; /*-*/ jmp matchOperationReturnPoint;
		to '-': /*-*/ op = *current; /*-*/ jmp matchOperationReturnPoint;
		to '*': /*-*/ op = *current; /*-*/ jmp matchOperationReturnPoint;
		to '/': /*-*/ op = *current; /*-*/ jmp matchOperationReturnPoint;
		off: /*----*/ op = '\0'; /*-----*/ jmp matchOperationReturnPoint;
	}
	matchOperationReturnPoint: switch(jmpPoint){
		to LEVEL0_JMP_POINT: /*-*/ jmp switchOperation0;
		to LEVEL1_JMP_POINT: /*-*/ jmp switchOperation1;
		off: /*-----------------*/ jmp switchOperation2;
	}
	switchOperation0: switch(op){
		to '\0': /*-*/ jmp level0;
		to '+': /*--*/ jmp level1;
		to '-': /*--*/ jmp level1;
		to '*': /*--*/ jmp level2;
		to '/': /*--*/ jmp level2;
	}
	switchOperation1: switch(op){
		to '\0': /*-*/ jmp level1End;
		to '+': /*--*/ jmp level1FoundLevel1;
		to '-': /*--*/ jmp level1FoundLevel1;
		to '*': /*--*/ jmp level2;
		to '/': /*--*/ jmp level2;
	}
	switchOperation2: switch(op){
		to '\0': /*-*/ jmp level2End;
		to '+': /*--*/ jmp level2FoundLevel1;
		to '-': /*--*/ jmp level2FoundLevel1;
		to '*': /*--*/ jmp level2FoundLevel2;
		to '/': /*--*/ jmp level2FoundLevel2;
	}
	level0:{
		i0 = number;
		jmp validNumber;
	}
	level1:{
		i0 = number;
		o0 = op;
		jmpPoint = LEVEL1_JMP_POINT;
		jmp matchWhitespace0Loop;
	}
	level2:{
		i1 = number;
		o1 = op;
		jmpPoint = LEVEL2_JMP_POINT;
		jmp matchWhitespace0Loop;
	}
	level1End:{
		if(o0 == '+'){
			i0 += number;
		}else{
			i0 -= number;
		}
		o0 = op;
		jmp validNumber;
	}
	level1FoundLevel1:{
		if(o0 == '+'){
			i0 += number;
		}else{
			i0 -= number;
		}
		o0 = op;
		jmp matchWhitespace0Loop;
	}
	level2End:{
		if(o1 == '*'){
			i1 *= number;
		}else{
			if(!number){
				jmp dividedByZeroNumber;
			}
			i1 /= number;
		}
		switch(o0){
			to '\0': /*-*/ i0  = i1; jmp validNumber;
			to '+': /*--*/ i0 += i1; jmp validNumber;
			to '-': /*--*/ i0 -= i1; jmp validNumber;
		}
	}
	level2FoundLevel1:{
		if(o1 == '*'){
			i1 *= number;
		}else{
			if(!number){
				jmp dividedByZeroNumber;
			}
			i1 /= number;
		}
		switch(o0){
			to '\0': /*-*/ o1 = '\0'; /*-*/ number = i1; jmp level1;
			to '+': /*--*/ i0 += i1; /*--*/ number = i0; jmp level1;
			to '-': /*--*/ i0 -= i1; /*--*/ number = i0; jmp level1;
		}
	}
	level2FoundLevel2:{
		if(o1 == '*'){
			i1 *= number;
		}else{
			if(!number){
				jmp dividedByZeroNumber;
			}
			i1 /= number;
		}
		o1 = op;
		jmp matchWhitespace0Loop;
	}
	validNumber:{
		*statementCurrent = current + 1;
		*returnValue = i0;
		ret VALID_NUMBER_NUMBER;
	}
	nonNumber:{
		*statementCurrent = current + 1;
		ret NON_NUMBER_NUMBER;
	}
	overflownNumber:{
		*statementCurrent = current + 1;
		ret OVERFLOWN_NUMBER_NUMBER;
	}
	dividedByZeroNumber:{
		*statementCurrent = current + 1;
		ret DIVIDED_BY_ZERO_NUMBER;
	}
	#undef  LEVEL2_JMP_POINT
	#undef  LEVEL1_JMP_POINT
	#undef  LEVEL0_JMP_POINT
}
MATCHSTRING(){
	#define STRING_BLOCK_SIZE /*-*/ (1024)
	uint size = STRING_BLOCK_SIZE;
	char *dataStart = malloc(size * sizeof(char));
	uint32 dataToken = pushPointer(dataStart, "matched string pointer", iFree);
	uint allocated = 0;
	char *dataCurrent = dataStart;
	char *current = *statementCurrent;
	jmp validateMalloc;
	validateMalloc:{
		if(!dataStart){
			ret false;
		}
		jmp copyStringLoop;
	}
	copyStringLoop:{
		if(allocated == size){
			const uint offset = dataCurrent - dataStart;
			void *temp;
			size += STRING_BLOCK_SIZE;
			temp = realloc(dataStart, size * sizeof(char));
			updatePointer(dataToken, temp);
			if(!temp){
				free(dataStart);
				popPointer(dataToken);
				ret false;
			}
			dataStart = temp;
			dataCurrent = dataStart + offset;
		}
		*dataCurrent = *current;
		inc allocated;
		if(*current){
			inc current;
			inc dataCurrent;
			jmp copyStringLoop;
		}
		inc current;
		jmp trimMemory;
	}
	trimMemory:{
		void *const temp = realloc(dataStart, allocated * sizeof(char));
		updatePointer(dataToken, temp);
		if(temp){
			dataStart = temp;
		}
		jmp returnValidString;
	}
	returnValidString:{
		*statementCurrent = current;
		*stringReturn = dataStart;
		*stringToken = dataToken;
		ret true;
	}
	#undef  STRING_BLOCK_SIZE
}
MATCHIMAGE(){
	#define FILE_HEADER_SIZE /*---*/ (14)
	#define BITMAPCOREHEADER /*---*/ (12)
	#define OS22XBITMAPHEADER /*--*/ (64)
	#define BITMAPINFOHEADER /*---*/ (40)
	#define BITMAPV2INFOHEADER /*-*/ (52)
	#define BITMAPV3INFOHEADER /*-*/ (56)
	#define BITMAPV4HEADER /*-----*/ (108)
	#define BITMAPV5HEADER /*-----*/ (124)
	#define BI_RGB /*-------------*/ (0)
	#define BI_RLE8 /*------------*/ (1)
	#define BI_RLE4 /*------------*/ (2)
	#define BI_BITFIELDS /*-------*/ (3)
	#define BI_JPEG /*------------*/ (4)
	#define BI_PNG /*-------------*/ (5)
	#define BI_ALPHABITFIELDS /*--*/ (6)
	#define BI_CMYK /*------------*/ (11)
	#define BI_CMYKRLE8 /*--------*/ (12)
	#define BI_CMYKRLE4 /*--------*/ (13)
	FILE *file = NULL;
	uint32 fileToken = 0;
	uint8 b;
	uint8 m;
	uint32 headerSize;
	int32 width;
	int32 height;
	uint16 depth;
	uint32 compression;
	uint32 *data = NULL;
	uint32 dataToken = 0;
	uint8 returnValue;
	*errorMessage = NULL;
	jmp openFile;
	openFile:{
		file = fopen(path, "rb");
		fileToken = pushPointer(file, "image file", fclose);
		if(!file){
			returnValue = CANNOT_OPEN_MATCH_IMAGE;
			jmp failedImage;
		}
		jmp readHeaders;
	}
	readHeaders:{
		uint8 header[FILE_HEADER_SIZE + BITMAPINFOHEADER];
		if(fread(header, sizeof(uint8), FILE_HEADER_SIZE + 34, file) != FILE_HEADER_SIZE + 34){
			returnValue = CANNOT_READ_MATCH_IMAGE;
			jmp failedImage;
		}
		b /*-----------*/ = *(uint8  *)(header + 0);
		m /*-----------*/ = *(uint8  *)(header + 1);
		headerSize /*--*/ = *(uint32 *)(header + 14);
		width /*-------*/ = *( int32 *)(header + 18);
		height /*------*/ = *( int32 *)(header + 22);
		depth /*-------*/ = *(uint16 *)(header + 28);
		compression /*-*/ = *(uint32 *)(header + 30);
		jmp queryFileFormat;
	}
	queryFileFormat:{
		if(b != 'B' or m != 'M'){
			returnValue = UNSUPPORTED_FORMAT_MATCH_IMAGE;
			jmp failedImage;
		}
		jmp queryHeaderSupport;
	}
	queryHeaderSupport: switch(headerSize){
		to BITMAPCOREHEADER: /*---*/ *errorMessage = "BITMAPCOREHEADER header not supported"; /*--*/ jmp printHeaderError;
		to OS22XBITMAPHEADER: /*--*/ *errorMessage = "OS22XBITMAPHEADER header not supported"; /*-*/ jmp printHeaderError;
		to BITMAPINFOHEADER: /*---*/ /*-----------------------------------------------------------*/ jmp queryDepth;
		to BITMAPV2INFOHEADER: /*-*/ /*-----------------------------------------------------------*/ jmp queryDepth;
		to BITMAPV3INFOHEADER: /*-*/ /*-----------------------------------------------------------*/ jmp queryDepth;
		to BITMAPV4HEADER: /*-----*/ /*-----------------------------------------------------------*/ jmp queryDepth;
		to BITMAPV5HEADER: /*-----*/ /*-----------------------------------------------------------*/ jmp queryDepth;
		off: /*-------------------*/ *errorMessage = "unrecognized header"; /*--------------------*/ jmp printHeaderError;
	}
	printHeaderError:{
		returnValue = BAD_HEADER_MATCH_IMAGE;
		jmp failedImage;
	}
	queryDepth: switch(depth){
		to 1: /*--*/ *errorMessage = "1 bit depth not supported"; /*---*/ jmp printDepthError;
		to 4: /*--*/ *errorMessage = "4 bit depth not supported"; /*---*/ jmp printDepthError;
		to 8: /*--*/ *errorMessage = "8 bit depth not supported"; /*---*/ jmp printDepthError;
		to 16: /*-*/ *errorMessage = "16 bit depth not supported"; /*--*/ jmp printDepthError;
		to 24: /*-*/ /*------------------------------------------------*/ jmp queryCompression;
		to 32: /*-*/ /*------------------------------------------------*/ jmp queryCompression;
		off: /*---*/ *errorMessage = "unknown depth not supported"; /*-*/ jmp printDepthError;
	}
	printDepthError:{
		returnValue = BAD_DEPTH_MATCH_IMAGE;
		jmp failedImage;
	}
	queryCompression: switch(compression){
		to BI_RGB: /*------------*/ /*----------------------------------------------------------------*/ jmp queryHeight;
		to BI_RLE8: /*-----------*/ *errorMessage = "BI_RLE8 compression not supported"; /*-----------*/ jmp printCompressionError;
		to BI_RLE4: /*-----------*/ *errorMessage = "BI_RLE4 compression not supported"; /*-----------*/ jmp printCompressionError;
		to BI_BITFIELDS: /*------*/ /*----------------------------------------------------------------*/ jmp queryHeight;
		to BI_JPEG: /*-----------*/ *errorMessage = "BI_JPEG compression not supported"; /*-----------*/ jmp printCompressionError;
		to BI_PNG: /*------------*/ *errorMessage = "BI_PNG compression not supported"; /*------------*/ jmp printCompressionError;
		to BI_ALPHABITFIELDS: /*-*/ *errorMessage = "BI_ALPHABITFIELDS compression not supported"; /*-*/ jmp printCompressionError;
		to BI_CMYK: /*-----------*/ *errorMessage = "BI_CMYK compression not supported"; /*-----------*/ jmp printCompressionError;
		to BI_CMYKRLE8: /*-------*/ *errorMessage = "BI_CMYKRLE8 compression not supported"; /*-------*/ jmp printCompressionError;
		to BI_CMYKRLE4: /*-------*/ *errorMessage = "BI_CMYKRLE4 compression not supported"; /*-------*/ jmp printCompressionError;
		off: /*------------------*/ *errorMessage = "unrecognized compression used"; /*---------------*/ jmp printCompressionError;
	}
	printCompressionError:{
		returnValue = BAD_COMPRESSION_MATCH_IMAGE;
		jmp failedImage;
	}
	queryHeight:{
		if(height < 0){
			returnValue = UNSUPPORTED_HEIGHT_MATCH_IMAGE;
			jmp failedImage;
		}
		jmp setupImage;
	}
	setupImage:{
		if(fseek(file, FILE_HEADER_SIZE + headerSize, SEEK_SET)){
			returnValue = BAD_SIZE_MATCH_IMAGE;
			jmp failedImage;
		}
		(*image).width = width;
		(*image).height = height;
		(*image).dataSize = width * height * sizeof(uint32);
		data = malloc((*image).dataSize * sizeof(uint8));
		dataToken = pushPointer(data, "image data pointer", iFree);
		if(!data){
			returnValue = FAILED_MATCH_IMAGE;
			jmp failedImage;
		}
		jmp readPixels;
	}
	readPixels:{
		const uint32 amount = (depth * width + 31) / 8 / width;
		const uint widthTwice = 2 * width;
		uint32 *const start = data + (height - 1) * width;
		uint32 *current = start;
		uint multipleCounter = 0;
		uint32 *currentWall = current + width;
		jmp readRowLoop;
		readRowLoop:{
			if(fread(current, sizeof(uint8), amount, file) != amount){
				if(current == start){
					returnValue = BAD_PIXELS_MATCH_IMAGE;
					jmp failedImage;
				}
				returnValue = BAD_IMAGE_MATCH_IMAGE;
				jmp failedImage;
			}
			if(depth == 24){
				*current |= 0xFF000000;
			}
			multipleCounter += amount;
			multipleCounter -= (multipleCounter > 4) * 4;
			if(inc current < currentWall){
				jmp readRowLoop;
			}
			if((current -= widthTwice) >= data){
				fseek(file, 4 - multipleCounter, SEEK_CUR);
				multipleCounter = 0;
				currentWall -= width;
				jmp readRowLoop;
			}
			jmp successfulImage;
		}
	}
	successfulImage:{
		fclose(file);
		popPointer(fileToken);
		(*image).dataStart = data;
		(*image).dataToken = dataToken;
		ret SUCCESS_MATCH_IMAGE;
	}
	failedImage:{
		free(data);
		popPointer(dataToken);
		if(file){
			fclose(file);
			popPointer(fileToken);
		}
		ret returnValue;
	}
	#undef  BI_CMYKRLE4
	#undef  BI_CMYKRLE8
	#undef  BI_CMYK
	#undef  BI_ALPHABITFIELDS
	#undef  BI_PNG
	#undef  BI_JPEG
	#undef  BI_BITFIELDS
	#undef  BI_RLE4
	#undef  BI_RLE8
	#undef  BI_RGB
	#undef  BITMAPV5HEADER
	#undef  BITMAPV4HEADER
	#undef  BITMAPV3INFOHEADER
	#undef  BITMAPV2INFOHEADER
	#undef  BITMAPINFOHEADER
	#undef  OS22XBITMAPHEADER
	#undef  BITMAPCOREHEADER
	#undef  FILE_HEADER_SIZE
}
MATCHCOMMAND(){
	uint8 commandReturned = TYPICAL_MATCH_COMMAND_TYPE;
	(void)field0;
	(void)field1;
	(void)field2;
	(void)field3;
	(void)field4;
	switch(origin){
		to PRESS_MATCH_COMMAND_ORIGIN:{
			printCommand("press", command);
			if(!((*eventModifierNode).onState & PRESS_SHORTCUT_STATE)){
				jmp emergencyExit;
			}
			jmp matchCommand;
		}
		to RELEASE_MATCH_COMMAND_ORIGIN:{
			printCommand("release", command);
			if(!((*eventModifierNode).onState & RELEASE_SHORTCUT_STATE)){
				jmp emergencyExit;
			}
			jmp matchCommand;
		}
		to CONFIG_MATCH_COMMAND_ORIGIN:{
			printCommand("config", command);
			jmp matchCommand;
		}
		to STDIN_MATCH_COMMAND_ORIGIN:{
			printCommand("stdin", command);
			jmp matchCommand;
		}
		to TRANSMITTER_MATCH_COMMAND_ORIGIN:{
			printCommand("transmitter", command);
			jmp matchCommand;
		}
		off:{
			jmp emergencyExit;
		}
	}
	matchCommand: switch(command){
		to NONE_COMMAND: /*---------------------------------*/ jmp noneCommand;
		to EXECUTE_COMMAND: /*------------------------------*/ jmp executeCommand;
		to FOCUS_COMMAND: /*--------------------------------*/ jmp focusCommand;
		to MOTION_MOVE_COMMAND: /*--------------------------*/ jmp motionMoveCommand;
		to MOTION_RESIZE_COMMAND: /*------------------------*/ jmp motionResizeCommand;
		to PLACE_TOP_COMMAND: /*----------------------------*/ jmp placeTopCommand;
		to PLACE_BOTTOM_COMMAND: /*-------------------------*/ jmp placeBottomCommand;
		to PLACE_LEFT_COMMAND: /*---------------------------*/ jmp placeLeftCommand;
		to PLACE_RIGHT_COMMAND: /*--------------------------*/ jmp placeRightCommand;
		to PLACE_TOP_LEFT_COMMAND: /*-----------------------*/ jmp placeTopLeftCommand;
		to PLACE_TOP_RIGHT_COMMAND: /*----------------------*/ jmp placeTopRightCommand;
		to PLACE_BOTTOM_LEFT_COMMAND: /*--------------------*/ jmp placeBottomLeftCommand;
		to PLACE_BOTTOM_RIGHT_COMMAND: /*-------------------*/ jmp placeBottomRightCommand;
		to PLACE_CENTER_COMMAND: /*-------------------------*/ jmp placeCenterCommand;
		to PLACE_FULL_COMMAND: /*---------------------------*/ jmp placeFullCommand;
		to MOVE_COMMAND: /*---------------------------------*/ jmp moveCommand;
		to RESIZE_COMMAND: /*-------------------------------*/ jmp resizeCommand;
		to ENTER_MAXIMIZED_COMMAND: /*----------------------*/ jmp enterMaximizedCommand;
		to LEAVE_MAXIMIZED_COMMAND: /*----------------------*/ jmp leaveMaximizedCommand;
		to TOGGLE_MAXIMIZED_COMMAND: /*---------------------*/ jmp toggleMaximizedCommand;
		to ENTER_FULLSCREEN_COMMAND: /*---------------------*/ jmp enterFullscreenCommand;
		to LEAVE_FULLSCREEN_COMMAND: /*---------------------*/ jmp leaveFullscreenCommand;
		to TOGGLE_FULLSCREEN_COMMAND: /*--------------------*/ jmp toggleFullscreenCommand;
		to MINIMIZE_ALL_COMMAND: /*-------------------------*/ jmp minimizeAllCommand;
		to UNMINIMIZE_ALL_COMMAND: /*-----------------------*/ jmp unminimizeAllCommand;
		to SHOW_DESKTOP_COMMAND: /*-------------------------*/ jmp showDesktopCommand;
		to HIDE_DESKTOP_COMMAND: /*-------------------------*/ jmp hideDesktopCommand;
		to TOGGLE_DESKTOP_COMMAND: /*-----------------------*/ jmp toggleDesktopCommand;
		to GO_TO_WORKSPACE_COMMAND: /*----------------------*/ jmp goToWorkspaceCommand;
		to GO_TO_NEXT_WORKSPACE_COMMAND: /*-----------------*/ jmp goToNextWorkspaceCommand;
		to GO_TO_PREVIOUS_WORKSPACE_COMMAND: /*-------------*/ jmp goToPreviousWorkspaceCommand;
		to MOVE_WINDOW_TO_WORKSPACE_COMMAND: /*-------------*/ jmp moveWindowToWorkspaceCommand;
		to MOVE_WINDOW_TO_NEXT_WORKSPACE_COMMAND: /*--------*/ jmp moveWindowToNextWorkspaceCommand;
		to MOVE_WINDOW_TO_PREVIOUS_WORKSPACE_COMMAND: /*----*/ jmp moveWindowToPreviousWorkspaceCommand;
		to GO_TO_WORKSPACE_WITH_WINDOW_COMMAND: /*----------*/ jmp goToWorkspaceWithWindowCommand;
		to GO_TO_NEXT_WORKSPACE_WITH_WINDOW_COMMAND: /*-----*/ jmp goToNextWorkspaceWithWindowCommand;
		to GO_TO_PREVIOUS_WORKSPACE_WITH_WINDOW_COMMAND: /*-*/ jmp goToPreviousWorkspaceWithWindowCommand;
		to CLOSE_COMMAND: /*--------------------------------*/ jmp closeCommand;
		to KILL_COMMAND: /*---------------------------------*/ jmp killCommand;
		to RESTART_COMMAND: /*------------------------------*/ jmp restartCommand;
		to EXIT_COMMAND: /*---------------------------------*/ jmp exitCommand;
		off: /*---------------------------------------------*/ jmp unrecognizedCommand;
	}
	noneCommand:{
		jmp emergencyExit;
	}
	executeCommand:{
		spawnProcess(execute);
		jmp emergencyExit;
	}
	focusCommand:{
		Client *client;
		setPointer(&pointerSystem);
		if((client = findPositionedOrderedVirtualRootClient(&virtualRootSystem, &clientSystem, virtualRootSystem.currentDesktop, pointerSystem.x, pointerSystem.y))){
			setFocusedClient(&clientSystem, client, virtualRootSystem.currentDesktop);
		}
		jmp emergencyExit;
	}
	motionMoveCommand:{
		Client *const client = getFocusedClient(&clientSystem);
		int x = 0;
		int y = 0;
		if(!client or !((*client).allowedAction & MOVE_ALLOWED_ACTION)){
			jmp emergencyExit;
		}
		setPointer(&pointerSystem);
		x = pointerSystem.x;
		y = pointerSystem.y;
		setMotionClient(&clientSystem, client, MOVE_MOTION_ACTION, CENTER_POINT_WINDOW_GRAVITY, x, y);
		jmp emergencyExit;
	}
	motionResizeCommand:{
		Client *const client = getFocusedClient(&clientSystem);
		int x = 0;
		int y = 0;
		uint8 direction;
		uint8 windowGravity;
		if(!client or !((*client).allowedAction & RESIZE_ALLOWED_ACTION)){
			jmp emergencyExit;
		}
		setPointer(&pointerSystem);
		x = pointerSystem.x;
		y = pointerSystem.y;
		{
			const int thresholdX = 50;
			const int thresholdY = 50;
			const int clientX = x - (*client).containerX;
			const int clientY = y - (*client).containerY;
			const int clientWidth = (*client).containerWidth + 2 * (*client).containerBorder;
			const int clientHeight = (*client).containerHeight + 2 * (*client).containerBorder;
			direction = NONE_DIRECTION;
			if(clientX < clientWidth / 2){
				if(!thresholdX or (0 <= clientX and clientX < thresholdX)){
					direction |= LEFT_DIRECTION;
				}
			}else{
				if(!thresholdX or (clientWidth - thresholdX <= clientX and clientX < clientWidth)){
					direction |= RIGHT_DIRECTION;
				}
			}
			if(clientY < clientHeight / 2){
				if(!thresholdY or (0 <= clientY and clientY < thresholdY)){
					direction |= UP_DIRECTION;
				}
			}else{
				if(!thresholdY or (clientHeight - thresholdY <= clientY and clientY < clientHeight)){
					direction |= DOWN_DIRECTION;
				}
			}
			if(!direction){
				jmp emergencyExit;
			}
		}
		{
			uint8 horizontalAxisGravityStart[2];
			uint8 verticalAxisGravityStart[2];
			uint8 *horizontalAxisGravityCurrent;
			uint8 *verticalAxisGravityCurrent;
			horizontalAxisGravityCurrent = horizontalAxisGravityStart;
			verticalAxisGravityCurrent = verticalAxisGravityStart;
			windowGravity = NONE_WINDOW_GRAVITY;
			if(direction & UP_DIRECTION){
				*verticalAxisGravityCurrent = SOUTH_SIDE_WINDOW_GRAVITY;
				inc verticalAxisGravityCurrent;
			}
			if(direction & DOWN_DIRECTION){
				*verticalAxisGravityCurrent = NORTH_SIDE_WINDOW_GRAVITY;
				inc verticalAxisGravityCurrent;
			}
			if(direction & LEFT_DIRECTION){
				*horizontalAxisGravityCurrent = EAST_SIDE_WINDOW_GRAVITY;
				inc horizontalAxisGravityCurrent;
			}
			if(direction & RIGHT_DIRECTION){
				*horizontalAxisGravityCurrent = WEST_SIDE_WINDOW_GRAVITY;
				inc horizontalAxisGravityCurrent;
			}
			if(horizontalAxisGravityCurrent == horizontalAxisGravityStart + 1){
				windowGravity = *horizontalAxisGravityStart;
			}
			if(verticalAxisGravityCurrent == verticalAxisGravityStart + 1){
				const uint8 verticalWindowGravity = *verticalAxisGravityStart;
				if(windowGravity == WEST_SIDE_WINDOW_GRAVITY){
					if(verticalWindowGravity == NORTH_SIDE_WINDOW_GRAVITY){
						windowGravity = NORTH_WEST_POINT_WINDOW_GRAVITY;
					}else{
						windowGravity = SOUTH_WEST_POINT_WINDOW_GRAVITY;
					}
				}elif(windowGravity == EAST_SIDE_WINDOW_GRAVITY){
					if(verticalWindowGravity == NORTH_SIDE_WINDOW_GRAVITY){
						windowGravity = NORTH_EAST_POINT_WINDOW_GRAVITY;
					}else{
						windowGravity = SOUTH_EAST_POINT_WINDOW_GRAVITY;
					}
				}else{
					windowGravity = *verticalAxisGravityStart;
				}
			}
		}
		setMotionClient(&clientSystem, client, RESIZE_MOTION_ACTION, windowGravity, x, y);
		jmp emergencyExit;
	}
	placeTopCommand:{
		moveResizeWorkareaClient(&virtualRootSystem, &monitorSystem, &clientSystem, getFocusedClient(&clientSystem), field0, TOP_WORKAREA_POSITION);
		jmp emergencyExit;
	}
	placeBottomCommand:{
		moveResizeWorkareaClient(&virtualRootSystem, &monitorSystem, &clientSystem, getFocusedClient(&clientSystem), field0, BOTTOM_WORKAREA_POSITION);
		jmp emergencyExit;
	}
	placeLeftCommand:{
		moveResizeWorkareaClient(&virtualRootSystem, &monitorSystem, &clientSystem, getFocusedClient(&clientSystem), field0, LEFT_WORKAREA_POSITION);
		jmp emergencyExit;
	}
	placeRightCommand:{
		moveResizeWorkareaClient(&virtualRootSystem, &monitorSystem, &clientSystem, getFocusedClient(&clientSystem), field0, RIGHT_WORKAREA_POSITION);
		jmp emergencyExit;
	}
	placeTopLeftCommand:{
		moveResizeWorkareaClient(&virtualRootSystem, &monitorSystem, &clientSystem, getFocusedClient(&clientSystem), field0, TOP_LEFT_WORKAREA_POSITION);
		jmp emergencyExit;
	}
	placeTopRightCommand:{
		moveResizeWorkareaClient(&virtualRootSystem, &monitorSystem, &clientSystem, getFocusedClient(&clientSystem), field0, TOP_RIGHT_WORKAREA_POSITION);
		jmp emergencyExit;
	}
	placeBottomLeftCommand:{
		moveResizeWorkareaClient(&virtualRootSystem, &monitorSystem, &clientSystem, getFocusedClient(&clientSystem), field0, BOTTOM_LEFT_WORKAREA_POSITION);
		jmp emergencyExit;
	}
	placeBottomRightCommand:{
		moveResizeWorkareaClient(&virtualRootSystem, &monitorSystem, &clientSystem, getFocusedClient(&clientSystem), field0, BOTTOM_RIGHT_WORKAREA_POSITION);
		jmp emergencyExit;
	}
	placeCenterCommand:{
		moveResizeWorkareaClient(&virtualRootSystem, &monitorSystem, &clientSystem, getFocusedClient(&clientSystem), field0, CENTER_WORKAREA_POSITION);
		jmp emergencyExit;
	}
	placeFullCommand:{
		moveResizeWorkareaClient(&virtualRootSystem, &monitorSystem, &clientSystem, getFocusedClient(&clientSystem), field0, FULL_WORKAREA_POSITION);
		jmp emergencyExit;
	}
	moveCommand:{
		Client *const client = getFocusedClient(&clientSystem);
		int x;
		int y;
		if(!client){
			jmp emergencyExit;
		}
		x = (*client).containerX;
		y = (*client).containerY;
		if(field0 & UP_DIRECTION){
			y -= field1;
		}
		if(field0 & DOWN_DIRECTION){
			y += field1;
		}
		if(field0 & LEFT_DIRECTION){
			x -= field1;
		}
		if(field0 & RIGHT_DIRECTION){
			x += field1;
		}
		moveResizeClient(&clientSystem, client, x, y, (*client).containerWidth, (*client).containerHeight, false, true, false, false, false, NONE_WINDOW_GRAVITY);
		jmp emergencyExit;
	}
	resizeCommand:{
		Client *const client = getFocusedClient(&clientSystem);
		uint8 horizontalAxisGravityStart[2];
		uint8 verticalAxisGravityStart[2];
		uint8 *horizontalAxisGravityCurrent;
		uint8 *verticalAxisGravityCurrent;
		int width;
		int height;
		uint8 windowGravity;
		if(!client){
			jmp emergencyExit;
		}
		horizontalAxisGravityCurrent = horizontalAxisGravityStart;
		verticalAxisGravityCurrent = verticalAxisGravityStart;
		width = (*client).containerWidth;
		height = (*client).containerHeight;
		windowGravity = NONE_WINDOW_GRAVITY;
		if(field0 & UP_DIRECTION){
			height += field1;
			*verticalAxisGravityCurrent = SOUTH_SIDE_WINDOW_GRAVITY;
			inc verticalAxisGravityCurrent;
		}
		if(field0 & DOWN_DIRECTION){
			height += field1;
			*verticalAxisGravityCurrent = NORTH_SIDE_WINDOW_GRAVITY;
			inc verticalAxisGravityCurrent;
		}
		if(field0 & LEFT_DIRECTION){
			width += field1;
			*horizontalAxisGravityCurrent = EAST_SIDE_WINDOW_GRAVITY;
			inc horizontalAxisGravityCurrent;
		}
		if(field0 & RIGHT_DIRECTION){
			width += field1;
			*horizontalAxisGravityCurrent = WEST_SIDE_WINDOW_GRAVITY;
			inc horizontalAxisGravityCurrent;
		}
		if(horizontalAxisGravityCurrent == horizontalAxisGravityStart + 1){
			windowGravity = *horizontalAxisGravityStart;
		}
		if(verticalAxisGravityCurrent == verticalAxisGravityStart + 1){
			const uint8 verticalWindowGravity = *verticalAxisGravityStart;
			if(windowGravity == WEST_SIDE_WINDOW_GRAVITY){
				if(verticalWindowGravity == NORTH_SIDE_WINDOW_GRAVITY){
					windowGravity = NORTH_WEST_POINT_WINDOW_GRAVITY;
				}else{
					windowGravity = SOUTH_WEST_POINT_WINDOW_GRAVITY;
				}
			}elif(windowGravity == EAST_SIDE_WINDOW_GRAVITY){
				if(verticalWindowGravity == NORTH_SIDE_WINDOW_GRAVITY){
					windowGravity = NORTH_EAST_POINT_WINDOW_GRAVITY;
				}else{
					windowGravity = SOUTH_EAST_POINT_WINDOW_GRAVITY;
				}
			}else{
				windowGravity = *verticalAxisGravityStart;
			}
		}
		if(!windowGravity){
			windowGravity = CENTER_POINT_WINDOW_GRAVITY;
		}
		moveResizeClient(&clientSystem, client, (*client).containerX, (*client).containerY, width, height, false, true, true, false, false, windowGravity);
		jmp emergencyExit;
	}
	enterMaximizedCommand:{
		maximizeClient(&virtualRootSystem, &monitorSystem, &clientSystem, getFocusedClient(&clientSystem), field0);
		jmp emergencyExit;
	}
	leaveMaximizedCommand:{
		unmaximizeClient(&virtualRootSystem, &monitorSystem, &clientSystem, getFocusedClient(&clientSystem));
		jmp emergencyExit;
	}
	toggleMaximizedCommand:{
		Client *const client = getFocusedClient(&clientSystem);
		if(!client){
			jmp emergencyExit;
		}
		if(((*client).state & (MAXIMIZED_HORZ_STATE | MAXIMIZED_VERT_STATE)) != (MAXIMIZED_HORZ_STATE | MAXIMIZED_VERT_STATE)){
			jmp enterMaximizedCommand;
		}
		jmp leaveMaximizedCommand;
	}
	enterFullscreenCommand:{
		Client *const client = getFocusedClient(&clientSystem);
		if(fullscreenClient(&virtualRootSystem, &monitorSystem, &clientSystem, client, field0)){
			if(setClientOrderType(&clientSystem, client)){
				if(restackClient(&clientSystem, client, XCB_STACK_MODE_ABOVE, XCB_NONE)){
					configureClient(&clientSystem, client);
					configureVirtualRootClient(&virtualRootSystem, &clientSystem, client);
					if(configureClientListClient(&clientListStackingSystem, &clientSystem, client)){
						changeClientListProperty(&clientListStackingSystem);
					}
				}
			}
		}
		jmp emergencyExit;
	}
	leaveFullscreenCommand:{
		Client *const client = getFocusedClient(&clientSystem);
		if(unfullscreenClient(&virtualRootSystem, &monitorSystem, &clientSystem, client)){
			if(setClientOrderType(&clientSystem, client)){
				if(restackClient(&clientSystem, client, XCB_STACK_MODE_ABOVE, XCB_NONE)){
					configureClient(&clientSystem, client);
					configureVirtualRootClient(&virtualRootSystem, &clientSystem, client);
					if(configureClientListClient(&clientListStackingSystem, &clientSystem, client)){
						changeClientListProperty(&clientListStackingSystem);
					}
				}
			}
		}
		jmp emergencyExit;
	}
	toggleFullscreenCommand:{
		Client *const client = getFocusedClient(&clientSystem);
		if(!client){
			jmp emergencyExit;
		}
		if(!((*client).state & FULLSCREEN_STATE)){
			jmp enterFullscreenCommand;
		}
		jmp leaveFullscreenCommand;
	}
	minimizeAllCommand:{
		Client *current = clientSystem.clientStart;
		Client *const wall = current + clientSystem.clientAllocated;
		jmp minimizeAllCommandLoop;
		minimizeAllCommandLoop:{
			if(current < wall){
				fprintf(stdout, "  minimize: iterating client %p with %u %u %u...\n", (void *)current, (*current).inUse, (*current).stateState, (*current).windowType);
				if((*current).inUse and (*current).stateState == NORMAL_STATE and ((*current).windowType & (TOOLBAR_WINDOW_TYPE | UTILITY_WINDOW_TYPE | DIALOG_WINDOW_TYPE | NORMAL_WINDOW_TYPE))){
					fprintf(stdout, "found client in use and with normal state %p\n", (void *)current);
					if(unmapClient(&clientSystem, current, ICONIC_STATE)){
						fprintf(stdout, "success with state %u\n", (*current).stateState);
					}else{
						fprintf(stdout, "failure with state %u\n", (*current).stateState);
					}
				}
				inc current;
				jmp minimizeAllCommandLoop;
			}
			jmp emergencyExit;
		}
	}
	unminimizeAllCommand:{
		Client *current = clientSystem.clientStart;
		Client *const wall = current + clientSystem.clientAllocated;
		jmp unminimizeAllCommandLoop;
		unminimizeAllCommandLoop:{
			if(current < wall){
				fprintf(stdout, "unminimize: iterating client %p with %u %u %u...\n", (void *)current, (*current).inUse, (*current).stateState, (*current).windowType);
				if((*current).inUse and ((*current).windowType & (TOOLBAR_WINDOW_TYPE | UTILITY_WINDOW_TYPE | DIALOG_WINDOW_TYPE | NORMAL_WINDOW_TYPE))){
					fprintf(stdout, "found minimized in use and with iconic state %p\n", (void *)current);
					if(!((*current).option & OVERRIDE_REDIRECT_CLIENT_OPTION)){
						if((*current).desktop == NONE_DESKTOP){
							if(setClientVirtualRoot(&virtualRootSystem, &clientSystem, current, virtualRootSystem.currentDesktop)){
								changeVirtualRootClientDesktop(&virtualRootSystem, &clientSystem, current);
							}
						}
					}
					if(mapClient(&clientSystem, &monitorSystem, current, POINTER_WHICH_MONITOR)){
						fprintf(stdout, "unminimized %p\n", (void *)current);
					}else{
						fprintf(stdout, "failed to unminimize %p\n", (void *)current);
					}
				}
				inc current;
				jmp unminimizeAllCommandLoop;
			}
			jmp emergencyExit;
		}
	}
	showDesktopCommand:{
		showVirtualRootDesktop(&virtualRootSystem, &clientSystem, virtualRootSystem.currentDesktop, true);
		jmp emergencyExit;
	}
	hideDesktopCommand:{
		showVirtualRootDesktop(&virtualRootSystem, &clientSystem, virtualRootSystem.currentDesktop, false);
		jmp emergencyExit;
	}
	toggleDesktopCommand:{
		showVirtualRootDesktop(&virtualRootSystem, &clientSystem, virtualRootSystem.currentDesktop, !virtualRootSystem.showingDesktop);
		jmp emergencyExit;
	}
	goToWorkspaceCommand:{
		uint32 field;
		uint32 which;
		if(field0 < 0){
			jmp emergencyExit;
		}
		field = field0;
		which = field - 1;
		if(which > field){
			which = field;
		}
		gotoVirtualRoot(&virtualRootSystem, &clientSystem, which, true);
		jmp emergencyExit;
	}
	goToNextWorkspaceCommand:{
		uint32 which = virtualRootSystem.currentDesktop + 1;
		if(which < virtualRootSystem.currentDesktop){
			which = virtualRootSystem.currentDesktop;
		}
		gotoVirtualRoot(&virtualRootSystem, &clientSystem, which, true);
		jmp emergencyExit;
	}
	goToPreviousWorkspaceCommand:{
		uint32 which = virtualRootSystem.currentDesktop - 1;
		if(which > virtualRootSystem.currentDesktop){
			which = virtualRootSystem.currentDesktop;
		}
		gotoVirtualRoot(&virtualRootSystem, &clientSystem, which, true);
		jmp emergencyExit;
	}
	moveWindowToWorkspaceCommand:{
		uint32 field;
		uint32 which;
		if(field0 < 0){
			jmp emergencyExit;
		}
		field = field0;
		which = field - 1;
		if(which > field){
			which = field;
		}
		moveClientToVirtualRoot(&virtualRootSystem, &monitorSystem, &clientSystem, getFocusedClient(&clientSystem), which, true);
		jmp emergencyExit;
	}
	moveWindowToNextWorkspaceCommand:{
		uint32 which = virtualRootSystem.currentDesktop + 1;
		if(which < virtualRootSystem.currentDesktop){
			which = virtualRootSystem.currentDesktop;
		}
		moveClientToVirtualRoot(&virtualRootSystem, &monitorSystem, &clientSystem, getFocusedClient(&clientSystem), which, true);
		jmp emergencyExit;
	}
	moveWindowToPreviousWorkspaceCommand:{
		uint32 which = virtualRootSystem.currentDesktop - 1;
		if(which > virtualRootSystem.currentDesktop){
			which = virtualRootSystem.currentDesktop;
		}
		moveClientToVirtualRoot(&virtualRootSystem, &monitorSystem, &clientSystem, getFocusedClient(&clientSystem), which, true);
		jmp emergencyExit;
	}
	goToWorkspaceWithWindowCommand:{
		Client *client;
		uint32 field;
		uint32 which;
		if(field0 < 0){
			jmp emergencyExit;
		}
		field = field0;
		which = field - 1;
		client = getFocusedClient(&clientSystem);
		if(which > field){
			which = field;
		}
		if(client){
			moveClientToVirtualRoot(&virtualRootSystem, &monitorSystem, &clientSystem, client, which, false);
		}
		gotoVirtualRoot(&virtualRootSystem, &clientSystem, which, false);
		jmp emergencyExit;
	}
	goToNextWorkspaceWithWindowCommand:{
		Client *const client = getFocusedClient(&clientSystem);
		uint32 which = virtualRootSystem.currentDesktop + 1;
		if(which < virtualRootSystem.currentDesktop){
			which = virtualRootSystem.currentDesktop;
		}
		if(client){
			moveClientToVirtualRoot(&virtualRootSystem, &monitorSystem, &clientSystem, client, which, false);
		}
		gotoVirtualRoot(&virtualRootSystem, &clientSystem, which, false);
		jmp emergencyExit;
	}
	goToPreviousWorkspaceWithWindowCommand:{
		Client *const client = getFocusedClient(&clientSystem);
		uint32 which = virtualRootSystem.currentDesktop - 1;
		if(which > virtualRootSystem.currentDesktop){
			which = virtualRootSystem.currentDesktop;
		}
		if(client){
			moveClientToVirtualRoot(&virtualRootSystem, &monitorSystem, &clientSystem, client, which, false);
		}
		gotoVirtualRoot(&virtualRootSystem, &clientSystem, which, false);
		jmp emergencyExit;
	}
	closeCommand:{
		Client *const client = getFocusedClient(&clientSystem);
		if(!closeClient(&clientSystem, client, CLOSE_CLOSE_CLIENT_COMMAND)){
			closeClient(&clientSystem, client, KILL_CLOSE_CLIENT_COMMAND);
		}
		jmp emergencyExit;
	}
	killCommand:{
		closeClient(&clientSystem, getFocusedClient(&clientSystem), KILL_CLOSE_CLIENT_COMMAND);
		jmp emergencyExit;
	}
	restartCommand:{
		commandReturned = RESTART_MATCH_COMMAND_TYPE;
		jmp emergencyExit;
	}
	exitCommand:{
		commandReturned = EXIT_MATCH_COMMAND_TYPE;
		jmp emergencyExit;
	}
	unrecognizedCommand:{
		printTitledValuedError("command error", "executed unrecognized command with type", command);
		jmp emergencyExit;
	}
	emergencyExit:{
		ret commandReturned;
	}
}
UNGRABSHORTCUTS(){
	if(!connection){
		ret false;
	}
	if(keycodeShortcutSystem.modifierAllocated > 1){
		xcb_ungrab_key(connection, XCB_GRAB_ANY, (*screen).root, XCB_MOD_MASK_ANY);
	}
	if(buttonShortcutSystem.modifierAllocated > 1){
		xcb_ungrab_button(connection, XCB_BUTTON_INDEX_ANY, (*screen).root, XCB_MOD_MASK_ANY);
	}
	ret true;
}
FREECONFIGVARIABLES(){
	ret;
}
SETMEMORY(){
	switch(perByteAmount){
		to sizeof(uint8): /*--*/ jmp perByte;
		to sizeof(uint16): /*-*/ jmp perTwoBytes;
		to sizeof(uint32): /*-*/ jmp perFourBytes;
		to sizeof(uint64): /*-*/ jmp perEightBytes;
		off: /*---------------*/ ret;
	}
	perByte:{
		const uint8 value8 = value;
		uint8 *current = destinationStart;
		uint8 *const wall = current + itemAmount;
		jmp perByteLoop;
		perByteLoop:{
			if(current < wall){
				*current = value8;
				inc current;
				jmp perByteLoop;
			}
			ret;
		}
	}
	perTwoBytes:{
		const uint16 value16 = value;
		uint16 *current = destinationStart;
		uint16 *const wall = current + itemAmount;
		jmp perTwoBytesLoop;
		perTwoBytesLoop:{
			if(current < wall){
				*current = value16;
				inc current;
				jmp perTwoBytesLoop;
			}
			ret;
		}
	}
	perFourBytes:{
		const uint32 value32 = value;
		uint32 *current = destinationStart;
		uint32 *const wall = current + itemAmount;
		jmp perFourBytesLoop;
		perFourBytesLoop:{
			if(current < wall){
				*current = value32;
				inc current;
				jmp perFourBytesLoop;
			}
			ret;
		}
	}
	perEightBytes:{
		const uint64 value64 = value;
		uint64 *current = destinationStart;
		uint64 *const wall = current + itemAmount;
		jmp perEightBytesLoop;
		perEightBytesLoop:{
			if(current < wall){
				*current = value64;
				inc current;
				jmp perEightBytesLoop;
			}
			ret;
		}
	}
}
COPYMEMORY(){
	const void *sourceCurrent;
	const void *sourceWall;
	void *destinationCurrent;
	bool flag;
	if(!sourceStart or !destinationStart or !byteAmount){
		ret;
	}
	sourceCurrent = sourceStart;
	destinationCurrent = destinationStart;
	jmp checkMisalignment;
	checkMisalignment:{
		uint misalignmentAmount = (uint64)destinationCurrent & (sizeof(uint64) - 1);
		if(misalignmentAmount and (uint64)sourceCurrent & (sizeof(uint64) - 1)){
			if(misalignmentAmount > byteAmount){
				misalignmentAmount = byteAmount;
			}
			sourceWall = (uint8 *)sourceCurrent + misalignmentAmount;
			byteAmount -= misalignmentAmount;
			flag = true;
			jmp smallLoop;
		}
		jmp preLargeLoop;
	}
	preLargeLoop:{
		sourceWall = (uint64 *)sourceCurrent + byteAmount / sizeof(uint64);
		flag = false;
		jmp largeLoop;
	}
	largeLoop:{
		if((uint64 *)sourceCurrent < (uint64 *)sourceWall){
			*(uint64 *)destinationCurrent = *(uint64 *)sourceCurrent;
			sourceCurrent = (uint64 *)sourceCurrent + 1;
			destinationCurrent = (uint64 *)destinationCurrent + 1;
			jmp largeLoop;
		}
		sourceWall = (uint8 *)sourceCurrent + (byteAmount & (sizeof(uint64) - 1));
		jmp smallLoop;
	}
	smallLoop:{
		if((uint8 *)sourceCurrent < (uint8 *)sourceWall){
			*(uint8 *)destinationCurrent = *(uint8 *)sourceCurrent;
			sourceCurrent = (uint8 *)sourceCurrent + 1;
			destinationCurrent = (uint8 *)destinationCurrent + 1;
			jmp smallLoop;
		}
		if(flag){
			jmp preLargeLoop;
		}
		ret;
	}
}
SHIFTMEMORY(){
	uint amountToAdd;
	void *current;
	void *wall;
	int misalignmentAmount;
	bool flag;
	int nextItemOffset;
	if(!start or byteAmount < 1 or !byteOffset){
		ret;
	}
	nextItemOffset = 1 - (byteOffset > 0) * 2;
	current = (uint8 *)start + (byteOffset > 0) * byteAmount;
	if((misalignmentAmount = (uint64)start & (sizeof(uint64) - 1))){
		if(misalignmentAmount > byteAmount){
			misalignmentAmount = byteAmount;
		}
		amountToAdd = (byteOffset > 0 and byteAmount >= (int)sizeof(uint8)) * sizeof(uint8);
		current = (uint8 *)current - amountToAdd;
		wall = (uint8 *)current + nextItemOffset * misalignmentAmount;
		byteAmount -= misalignmentAmount;
		flag = true;
		jmp shiftSmallLoop;
	}
	jmp preShiftLargeLoop;
	preShiftLargeLoop:{
		amountToAdd = (byteOffset > 0 and byteAmount >= (int)sizeof(uint64)) * sizeof(uint64);
		current = (uint8 *)current - amountToAdd;
		wall = (uint64 *)current + nextItemOffset * (byteAmount / sizeof(uint64));
		flag = false;
		jmp shiftLargeLoop;
	}
	shiftLargeLoop:{
		if((uint64 *)current != (uint64 *)wall){
			*(uint64 *)((uint8 *)current + byteOffset) = *(uint64 *)current;
			current = (uint64 *)current + nextItemOffset;
			jmp shiftLargeLoop;
		}
		current = (uint8 *)current + amountToAdd;
		amountToAdd = (byteOffset > 0 and byteAmount >= (int)sizeof(uint8)) * sizeof(uint8);
		current = (uint8 *)current - amountToAdd;
		wall = (uint8 *)current + nextItemOffset * (byteAmount & (sizeof(uint64) - 1));
		jmp shiftSmallLoop;
	}
	shiftSmallLoop:{
		if((uint8 *)current != (uint8 *)wall){
			*(uint8 *)((uint8 *)current + byteOffset) = *(uint8 *)current;
			current = (uint8 *)current + nextItemOffset;
			jmp shiftSmallLoop;
		}
		current = (uint8 *)current + amountToAdd;
		if(flag){
			jmp preShiftLargeLoop;
		}
		ret;
	}
}
COMPAREMEMORY(){
	const void *memory0Current = memory0;
	const void *memory0Wall = (uint64 *)memory0Current + byteAmount / sizeof(uint64);
	const void *memory1Current = memory1;
	jmp largeLoop;
	largeLoop:{
		if((uint64 *)memory0Current < (uint64 *)memory0Wall){
			if(*(uint64 *)memory0Current != *(uint64 *)memory1Current){
				ret false;
			}
			memory0Current = (uint64 *)memory0Current + 1;
			memory1Current = (uint64 *)memory1Current + 1;
			jmp largeLoop;
		}
		memory0Wall = (uint8 *)memory0Current + (byteAmount & (sizeof(uint64) - 1));
		jmp smallLoop;
	}
	smallLoop:{
		if((uint8 *)memory0Current < (uint8 *)memory0Wall){
			if(*(uint8 *)memory0Current != *(uint8 *)memory1Current){
				ret false;
			}
			memory0Current = (uint8 *)memory0Current + 1;
			memory1Current = (uint8 *)memory1Current + 1;
			jmp smallLoop;
		}
		ret true;
	}
}
FINDSTRINGLENGTH(){
	const uint8 *current = string;
	jmp advanceStringPointerLoop;
	advanceStringPointerLoop:{
		if(*current){
			inc current;
			jmp advanceStringPointerLoop;
		}
		ret current - (uint8 *)string;
	}
}
FINDSUBSTRING(){
	const char *stringCurrent;
	const char *stringWall;
	char substringStartingCharacter;
	if(!string or !stringLength or !substring or !substringLength){
		ret NULL;
	}
	stringCurrent = string;
	stringWall = stringCurrent + stringLength;
	substringStartingCharacter = *substring;
	jmp findSubstringLoop;
	findSubstringLoop:{
		if(stringCurrent < stringWall){
			if(*stringCurrent == substringStartingCharacter){
				if(stringWall - stringCurrent < substringLength){
					ret NULL;
				}
				if(compareMemory(stringCurrent, substring, substringLength)){
					ret (void *)stringCurrent;
				}
			}
			inc stringCurrent;
			jmp findSubstringLoop;
		}
		ret NULL;
	}
}
UTF8TOUCS2(){
	uint8 *utf8Current = utf8Start;
	uint8 *const utf8Wall = utf8Current + utf8Length;
	uint16 *ucs2Current = ucs2Start;
	uint16 *const ucs2Wall = ucs2Current + ucs2Length;
	jmp translateUTF8ToUCS2Loop;
	translateUTF8ToUCS2Loop:{
		if(utf8Current < utf8Wall and ucs2Current < ucs2Wall){
			uint16 newUCS2;
			uint8 byte1 = *utf8Current;
			if(byte1 < b(10000000)){
				newUCS2 = byte1;
				byte1 = '\0';
				inc utf8Current;
			}elif((byte1 & b(11100000)) == b(11000000)){
				const uint8 byte2 = *(utf8Current + 1);
				if((byte2 & b(11000000)) == b(10000000)){
					newUCS2 = ((byte1 & b(00011111)) << 6) | (byte2 & b(00111111));
					byte1 = '\0';
					utf8Current += 2;
				}else{
					inc utf8Current;
				}
			}elif((byte1 & b(11110000)) == b(11100000)){
				const uint8 byte2 = *(utf8Current + 1);
				const uint8 byte3 = *(utf8Current + 2);
				if((byte2 & b(11000000)) == b(10000000) and (byte3 & b(11000000)) == b(10000000)){
					newUCS2 = ((byte1 & b(00001111)) << 12) | ((byte2 & b(00111111)) << 6) | (byte3 & b(00111111));
					byte1 = '\0';
					utf8Current += 3;
				}else{
					inc utf8Current;
				}
			}elif((byte1 & b(11111000)) == b(11110000)){
				const uint8 byte2 = *(utf8Current + 1);
				const uint8 byte3 = *(utf8Current + 2);
				const uint8 byte4 = *(utf8Current + 3);
				if((byte2 & b(11000000)) == b(10000000) and (byte3 & b(11000000)) == b(10000000) and (byte4 & b(11000000)) == b(10000000)){
					utf8Current += 4;
				}else{
					inc utf8Current;
				}
			}else{
				inc utf8Current;
			}
			if(!byte1){
				*ucs2Current = (newUCS2 << 8) | (newUCS2 >> 8);
				inc ucs2Current;
			}
			jmp translateUTF8ToUCS2Loop;
		}
		ret ucs2Current - ucs2Start;
	}
}
INTERSECTS(){
	ret x0 + width0 > x1 and x0 < x1 + width1 and y0 + height0 > y1 and y0 < y1 + height1;
}
GETINTERSECTION(){
	const int leftX = x0 > x1? x0 : x1;
	const int topY = y0 > y1? y0 : y1;
	const int rightX = x0 + width0 < x1 + width1? x0 + width0 : x1 + width1;
	const int bottomY = y0 + height0 < y1 + height1? y0 + height0 : y1 + height1;
	const int intersectionWidth = rightX > leftX? rightX - leftX : 0;
	const int intersectionHeight = bottomY > topY? bottomY - topY : 0;
	if(xReturn) /*------*/ *xReturn = leftX;
	if(yReturn) /*------*/ *yReturn = topY;
	if(widthReturn) /*--*/ *widthReturn = intersectionWidth;
	if(heightReturn) /*-*/ *heightReturn = intersectionHeight;
	ret;
}
LOADFILE(){
	#define DATA_BLOCK_SIZE /*-*/ (1024)
	FILE *file;
	uint32 token;
	uint dataAllocated;
	uint dataSize;
	char *dataStart;
	char *dataCurrent;
	uint32 dataToken;
	if(!path or !loadedFileReturn){
		ret false;
	}
	file = fopen(path, "r");
	token = pushPointer(file, "loadFile() file", fclose);
	if(!file){
		ret false;
	}
	dataAllocated = 0;
	dataSize = 0;
	dataStart = NULL;
	dataCurrent = dataStart;
	dataToken = 0;
	jmp allocateMemory;
	allocateMemory:{
		uint offset = 0;
		void *temp;
		if(dataCurrent){
			offset = dataCurrent - dataStart;
		}
		dataSize += DATA_BLOCK_SIZE;
		temp = realloc(dataStart, dataSize * sizeof(char));
		if(!dataToken){
			dataToken = pushPointer(temp, "loaded system file data", iFree);
		}else{
			updatePointer(dataToken, temp);
		}
		if(!temp){
			free(dataStart);
			popPointer(dataToken);
			fclose(file);
			popPointer(token);
			ret false;
		}
		dataStart = temp;
		dataCurrent = dataStart + offset;
		jmp loadFileSegmentLoop;
	}
	loadFileSegmentLoop:{
		const uint amountRead = fread(dataCurrent, sizeof(char), DATA_BLOCK_SIZE, file);
		dataAllocated += amountRead;
		if(amountRead == DATA_BLOCK_SIZE){
			jmp allocateMemory;
		}
		dataSize = dataAllocated;
		jmp trimMemory;
	}
	trimMemory:{
		if(dataSize){
			void *const temp = realloc(dataStart, dataSize * sizeof(char));
			updatePointer(dataToken, temp);
			if(temp){
				dataStart = temp;
			}
		}
		fclose(file);
		popPointer(token);
		(*loadedFileReturn).dataSize = dataSize;
		(*loadedFileReturn).dataStart = dataStart;
		(*loadedFileReturn).dataToken = dataToken;
		ret true;
	}
	#undef  DATA_BLOCK_SIZE
}
SPAWNPROCESS(){
	#define FORK_FAILURE /*-------*/ (-1)
	#define CHILD_FORK_PROCESS /*-*/ (0)
	#define SETSID_FAILURE /*-----*/ (-1)
	#define SETGID_FAILURE /*-----*/ (-1)
	#define SETUID_FAILURE /*-----*/ (-1)
	#define CHDIR_FAILURE /*------*/ (-1)
	if(!string){
		ret;
	}
	switch(fork()){
		to FORK_FAILURE:{
			printTitledError("fork error", "could not execute shell command");
			ret;
		}
		to CHILD_FORK_PROCESS:{
			char *env;
			if(setsid() == SETSID_FAILURE){
				printTitledError("fork error", "could not set group leader");
				exit(EXIT_SUCCESS);
			}
			dropPermissions(&permissionSystem);
			env = getenv("HOME");
			if(env and chdir(env) == CHDIR_FAILURE){
				printTitledError("fork error", "could not change directory to home");
			}
			execl("/bin/sh", "sh", "-c", string, NULL);
			exit(EXIT_SUCCESS);
		}
		off:{
			ret;
		}
	}
	#undef  CHDIR_FAILURE
	#undef  SETUID_FAILURE
	#undef  SETGID_FAILURE
	#undef  SETSID_FAILURE
	#undef  CHILD_FORK_PROCESS
	#undef  FORK_FAILURE
}
CREATECIRCLE(){
	const uint width = radius * 2 + 1;
	const uint height = width;
	const int r2 = radius * radius;
	uint32 *data = malloc(width * height * sizeof(uint32));
	uint32 token = pushPointer(data, "createCorner() data pointer", iFree);
	int y = -radius;
	uint32 *currentData = data;
	if(!data){
		ret false;
	}
	jmp yLoop;
	yLoop:{
		if(y <= radius){
			const int y2 = y * y;
			int x = -radius;
			jmp xLoop;
			xLoop:{
				if(x <= radius){
					const int x2y2 = x * x + y2;
					if(x2y2 <= r2){
						*currentData = foreground;
					}else{
						*currentData = background;
					}
					inc currentData;
					inc x;
					jmp xLoop;
				}
				inc y;
				jmp yLoop;
			}
		}
		(*image).x = 0;
		(*image).y = 0;
		(*image).width = width;
		(*image).height = height;
		(*image).dataStart = data;
		(*image).dataToken = token;
		(*image).dataSize = width * height * sizeof(uint32);
		ret true;
	}
}
COMPOSITEIMAGES(){
	int intersectionWidth;
	int intersectionHeight;
	uint32 *sourceCurrent;
	uint32 *sourceWidthWall;
	uint32 *sourceWall;
	uint32 *destinationCurrent;
	if(sourceX < 0 or sourceY < 0 or sourceX >= (*source).width or sourceY >= (*source).height){
		ret;
	}
	{
		const int b1lx = 0;
		const int b1ty = 0;
		const int b1rx = (*destination).width;
		const int b1by = (*destination).height;
		const int b2lx = destinationX;
		const int b2ty = destinationY;
		const int b2rx = b2lx + (*source).width - sourceX;
		const int b2by = b2ty + (*source).height - sourceY;
		intersectionWidth = (b1rx < b2rx? b1rx : b2rx) - (b1lx > b2lx? b1lx : b2lx);
		intersectionHeight = (b1by < b2by? b1by : b2by) - (b1ty > b2ty? b1ty : b2ty);
		if(intersectionWidth < 1 or intersectionWidth < 1){
			ret;
		}
	}
	sourceCurrent = (uint32 *)(*source).dataStart + sourceY * (*source).width + sourceX;
	if(destinationX < 0){
		sourceCurrent -= destinationX;
		destinationX = 0;
	}
	if(destinationY < 0){
		sourceCurrent -= destinationY * (*source).width;
		destinationY = 0;
	}
	sourceWidthWall = sourceCurrent + intersectionWidth;
	sourceWall = sourceCurrent + intersectionHeight * (*source).width;
	destinationCurrent = (uint32 *)(*destination).dataStart + destinationY * (*destination).width + destinationX;
	jmp yLoop;
	yLoop:{
		if(sourceCurrent < sourceWall){
			jmp xLoop;
			xLoop:{
				if(sourceCurrent < sourceWidthWall){
					operation(sourceCurrent, destinationCurrent);
					inc sourceCurrent;
					inc destinationCurrent;
					jmp xLoop;
				}
				sourceCurrent += (*source).width - intersectionWidth;
				sourceWidthWall += (*source).width;
				destinationCurrent += (*destination).width - intersectionWidth;
				jmp yLoop;
			}
		}
		ret;
	}
}
COMPOSITEIMAGESOVER(){
	const uint32 s = *source;
	const uint32 d = *destination;
	const uint64 a_a = s >> 24;
	if(a_a == 0xFF){
		*destination = s;
		ret;
	}
	if(a_a){
		const uint32 r_a = (s & 0x00FF0000) >> 16;
		const uint32 g_a = (s & 0x0000FF00) >> 8;
		const uint32 b_a = (s & 0x000000FF) >> 0;
		const uint32 a_b = d >> 24;
		const uint32 r_b = (d & 0x00FF0000) >> 16;
		const uint32 g_b = (d & 0x0000FF00) >> 8;
		const uint32 b_b = (d & 0x000000FF) >> 0;
		const uint32 a_0 = a_a + a_b * (0xFF - a_a) / 0xFF;
		const uint32 r = (r_a * a_a + r_b * a_b * (0xFF - a_a) / 0xFF) / a_0;
		const uint32 g = (g_a * a_a + g_b * a_b * (0xFF - a_a) / 0xFF) / a_0;
		const uint32 b = (b_a * a_a + b_b * a_b * (0xFF - a_a) / 0xFF) / a_0;
		*destination = (a_0 << 24) + ((r & 0x000000FF) << 16) + ((g & 0x000000FF) << 8) + ((b & 0x000000FF) << 0);
		ret;
	}
	ret;
}
COMPOSITEIMAGESAND(){
	if(!(*source >> 24)){
		*destination = 0x00000000;
		ret;
	}
	ret;
}
TWOPASSBOXBLUR(){
	uint32 *intermediateData;
	uint32 *kernelColumnRStart;
	uint32 *kernelColumnGStart;
	uint32 *kernelColumnBStart;
	uint32 *pixelRStart;
	uint32 *pixelGStart;
	uint32 *pixelBStart;
	if(boxSize == 1){
		ret;
	}
	intermediateData = malloc(width * height * sizeof(uint32));
	kernelColumnRStart = malloc(boxSize + 2 * width * sizeof(uint32));
	kernelColumnGStart = malloc(boxSize + 2 * width * sizeof(uint32));
	kernelColumnBStart = malloc(boxSize + 2 * width * sizeof(uint32));
	pixelRStart = malloc(boxSize + 2 * width * height * sizeof(uint32));
	pixelGStart = malloc(boxSize + 2 * width * height * sizeof(uint32));
	pixelBStart = malloc(boxSize + 2 * width * height * sizeof(uint32));
	{
		const int divisor = boxSize * boxSize;
		const int boxDistanceFromZero = boxSize >> 1;
		const int nBoxDistanceFromZero = -boxDistanceFromZero;
		const int widthMinusOne = width - 1;
		const int heightMinusOne = height - 1;
		const int heightMinusBoxSize = height - boxSize;
		uint32 *tx = destinationData;
		uint32 *txCopy = tx;
		uint32 *rx = intermediateData;
		uint32 r;
		uint32 g;
		uint32 b;
		jmp loop;
		loop:{
			uint32 *kernelColumnRCurrent = kernelColumnRStart;
			uint32 *kernelColumnGCurrent = kernelColumnGStart;
			uint32 *kernelColumnBCurrent = kernelColumnBStart;
			uint32 *kernelColumnRCurrentCopy = kernelColumnRStart;
			uint32 *kernelColumnGCurrentCopy = kernelColumnGStart;
			uint32 *kernelColumnBCurrentCopy = kernelColumnBStart;
			uint32 *pixelRCurrent = pixelRStart;
			uint32 *pixelGCurrent = pixelGStart;
			uint32 *pixelBCurrent = pixelBStart;
			uint32 *pixelRCurrentCopy = pixelRStart;
			uint32 *pixelGCurrentCopy = pixelGStart;
			uint32 *pixelBCurrentCopy = pixelBStart;
			int x = 0;
			int y = 0;
			{
				int kx = nBoxDistanceFromZero;
				r = 0;
				g = 0;
				b = 0;
				while(kx <= boxDistanceFromZero){
					int ky = nBoxDistanceFromZero;
					int usedX = x + kx;
					if(usedX < 0){
						usedX = 0;
					}
					*kernelColumnRCurrent = 0;
					*kernelColumnGCurrent = 0;
					*kernelColumnBCurrent = 0;
					tx += usedX;
					while(ky <= boxDistanceFromZero){
						int usedY = y + ky;
						uint32 color;
						if(usedY < 0){
							usedY = 0;
						}
						color = *(tx + usedY * width);
						*pixelRCurrent = (color & 0xFF0000) >> 16;
						*pixelGCurrent = (color & 0x00FF00) >>  8;
						*pixelBCurrent =  color & 0x0000FF;
						*kernelColumnRCurrent += *pixelRCurrent;
						*kernelColumnGCurrent += *pixelGCurrent;
						*kernelColumnBCurrent += *pixelBCurrent;
						inc pixelRCurrent;
						inc pixelGCurrent;
						inc pixelBCurrent;
						inc ky;
					}
					tx -= usedX;
					r += *kernelColumnRCurrent;
					g += *kernelColumnGCurrent;
					b += *kernelColumnBCurrent;
					pixelRCurrent += heightMinusBoxSize;
					pixelGCurrent += heightMinusBoxSize;
					pixelBCurrent += heightMinusBoxSize;
					inc kernelColumnRCurrent;
					inc kernelColumnGCurrent;
					inc kernelColumnBCurrent;
					inc kx;
				}
				*rx = 0xFF000000 + ((r / divisor) << 16) + ((g / divisor) << 8) + b / divisor;
				inc rx;
			}
			inc x;
			xFirstLoop:{
				int kx = boxDistanceFromZero;
				int ky = nBoxDistanceFromZero;
				int usedX = x + kx;
				if(usedX < 0){
					usedX = 0;
				}elif(usedX >= width){
					usedX = widthMinusOne;
				}
				r -= *kernelColumnRCurrentCopy;
				g -= *kernelColumnGCurrentCopy;
				b -= *kernelColumnBCurrentCopy;
				kernelColumnRCurrent = kernelColumnRCurrentCopy + boxSize;
				kernelColumnGCurrent = kernelColumnGCurrentCopy + boxSize;
				kernelColumnBCurrent = kernelColumnBCurrentCopy + boxSize;
				inc kernelColumnRCurrentCopy;
				inc kernelColumnGCurrentCopy;
				inc kernelColumnBCurrentCopy;
				{
					uint32 lr = 0;
					uint32 lg = 0;
					uint32 lb = 0;
					tx += usedX;
					while(ky <= boxDistanceFromZero){
						int usedY = y + ky;
						uint32 color;
						if(usedY < 0){
							usedY = 0;
						}elif(usedY >= height){
							usedY = heightMinusOne;
						}
						color = *(tx + usedY * width);
						*pixelRCurrent = (color & 0xFF0000) >> 16;
						*pixelGCurrent = (color & 0x00FF00) >>  8;
						*pixelBCurrent =  color & 0x0000FF;
						lr += *pixelRCurrent;
						lg += *pixelGCurrent;
						lb += *pixelBCurrent;
						inc pixelRCurrent;
						inc pixelGCurrent;
						inc pixelBCurrent;
						inc ky;
					}
					tx -= usedX;
					r += lr;
					g += lg;
					b += lb;
					*kernelColumnRCurrent = lr;
					*kernelColumnGCurrent = lg;
					*kernelColumnBCurrent = lb;
					pixelRCurrent += heightMinusBoxSize;
					pixelGCurrent += heightMinusBoxSize;
					pixelBCurrent += heightMinusBoxSize;
				}
				*rx = 0xFF000000 + ((r / divisor) << 16) + ((g / divisor) << 8) + b / divisor;
				inc rx;
				if(inc x < width){
					jmp xFirstLoop;
				}
			}
			inc y;
			yLoop:{
				uint32 *pr;
				uint32 *pg;
				uint32 *pb;
				int ky = boxDistanceFromZero;
				int usedY = y + ky;
				if(usedY < 0){
					usedY = 0;
				}elif(usedY >= height){
					usedY = heightMinusOne;
				}
				x = 0;
				{
					int kx = nBoxDistanceFromZero;
					kernelColumnRCurrent = kernelColumnRStart;
					kernelColumnGCurrent = kernelColumnGStart;
					kernelColumnBCurrent = kernelColumnBStart;
					kernelColumnRCurrentCopy = kernelColumnRStart;
					kernelColumnGCurrentCopy = kernelColumnGStart;
					kernelColumnBCurrentCopy = kernelColumnBStart;
					pixelRCurrent = pixelRCurrentCopy;
					pixelGCurrent = pixelGCurrentCopy;
					pixelBCurrent = pixelBCurrentCopy;
					pr = pixelRCurrent + boxSize;
					pg = pixelGCurrent + boxSize;
					pb = pixelBCurrent + boxSize;
					r = 0;
					g = 0;
					b = 0;
					tx += usedY * width;
					while(kx <= boxDistanceFromZero){
						int usedX = x + kx;
						uint32 color;
						if(usedX < 0){
							usedX = 0;
						}elif(usedX >= width){
							usedX = widthMinusOne;
						}
						color = *(tx + usedX);
						*pr = (color & 0xFF0000) >> 16;
						*pg = (color & 0x00FF00) >>  8;
						*pb =  color & 0x0000FF;
						*kernelColumnRCurrent += *pr - *pixelRCurrent;
						*kernelColumnGCurrent += *pg - *pixelGCurrent;
						*kernelColumnBCurrent += *pb - *pixelBCurrent;
						r += *kernelColumnRCurrent;
						g += *kernelColumnGCurrent;
						b += *kernelColumnBCurrent;
						pixelRCurrent += height;
						pixelGCurrent += height;
						pixelBCurrent += height;
						pr += height;
						pg += height;
						pb += height;
						inc kernelColumnRCurrent;
						inc kernelColumnGCurrent;
						inc kernelColumnBCurrent;
						inc kx;
					}
					tx -= usedY * width;
					*rx = 0xFF000000 + ((r / divisor) << 16) + ((g / divisor) << 8) + b / divisor;
					inc rx;
					inc x;
				}
				{
					int usedX = x + boxDistanceFromZero;
					usedY *= width;
					tx += usedY;
					xLoop:{
						uint32 color;
						if(usedX >= width){
							usedX = widthMinusOne;
						}
						kernelColumnRCurrent = kernelColumnRCurrentCopy + boxSize;
						kernelColumnGCurrent = kernelColumnGCurrentCopy + boxSize;
						kernelColumnBCurrent = kernelColumnBCurrentCopy + boxSize;
						r -= *kernelColumnRCurrentCopy;
						g -= *kernelColumnGCurrentCopy;
						b -= *kernelColumnBCurrentCopy;
						color = *(tx + usedX);
						*pr = (color & 0xFF0000) >> 16;
						*pg = (color & 0x00FF00) >>  8;
						*pb =  color & 0x0000FF;
						*kernelColumnRCurrent += *pr - *pixelRCurrent;
						*kernelColumnGCurrent += *pg - *pixelGCurrent;
						*kernelColumnBCurrent += *pb - *pixelBCurrent;
						r += *kernelColumnRCurrent;
						g += *kernelColumnGCurrent;
						b += *kernelColumnBCurrent;
						inc kernelColumnRCurrentCopy;
						inc kernelColumnGCurrentCopy;
						inc kernelColumnBCurrentCopy;
						pixelRCurrent += height;
						pixelGCurrent += height;
						pixelBCurrent += height;
						pr += height;
						pg += height;
						pb += height;
						*rx = 0xFF000000 + ((r / divisor) << 16) + ((g / divisor) << 8) + b / divisor;
						inc rx;
						if(inc x < width){
							inc usedX;
							jmp xLoop;
						}
					}
					tx -= usedY;
				}
				if(inc y < height){
					inc pixelRCurrentCopy;
					inc pixelGCurrentCopy;
					inc pixelBCurrentCopy;
					jmp yLoop;
				}
			}
			if(txCopy == destinationData){
				tx = intermediateData;
				txCopy = tx;
				rx = destinationData;
				jmp loop;
			}
		}
	}
	free(intermediateData);
	free(kernelColumnRStart);
	free(kernelColumnGStart);
	free(kernelColumnBStart);
	free(pixelRStart);
	free(pixelGStart);
	free(pixelBStart);
	ret;
}
ROTATEIMAGE(){
	const int oldWidth = (*image).width;
	const int oldHeight = (*image).height;
	const int oldSize = (*image).dataSize;
	uint32 *newData;
	uint32 newDataToken;
	uint32 *current = (*image).dataStart;
	uint32 *const yWall = (void *)((uint8 *)current + oldSize);
	uint32 *xWall = current + oldWidth;
	int newWidth;
	int newHeight;
	uint32 *newDataCurrent;
	int newDataNextX;
	int newDataNextY;
	if(!rotation){
		ret true;
	}
	newData = malloc(oldSize * sizeof(uint8));
	newDataToken = pushPointer(newData, "rotateImage() new data pointer", iFree);
	if(!newData){
		printTitledError("memory allocation error", "could not allocate rotated image color data");
		ret false;
	}
	switch(rotation){
		to DEGREES_90_ROTATION: /*--*/ jmp rotate90Degrees;
		to DEGREES_180_ROTATION: /*-*/ jmp rotate180Degrees;
		to DEGREES_270_ROTATION: /*-*/ jmp rotate270Degrees;
		off: /*---------------------*/ ret false;
	}
	rotate90Degrees:{
		newWidth = oldHeight;
		newHeight = oldWidth;
		newDataCurrent = newData + newWidth - 1;
		newDataNextX = newWidth;
		newDataNextY = -newHeight * newWidth - 1;
		jmp copyYAxisLoop;
	}
	rotate180Degrees:{
		newWidth = oldWidth;
		newHeight = oldHeight;
		newDataCurrent = newData + newHeight * newWidth - 1;
		newDataNextX = -1;
		newDataNextY = 0;
		jmp copyYAxisLoop;
	}
	rotate270Degrees:{
		newWidth = oldHeight;
		newHeight = oldWidth;
		newDataCurrent = newData + newHeight * newWidth - newWidth;
		newDataNextX = -newWidth;
		newDataNextY = newHeight * newWidth + 1;
		jmp copyYAxisLoop;
	}
	copyYAxisLoop:{
		if(current < yWall){
			jmp copyXAxisLoop;
			copyXAxisLoop:{
				if(current < xWall){
					*newDataCurrent = *current;
					newDataCurrent += newDataNextX;
					inc current;
					jmp copyXAxisLoop;
				}
				newDataCurrent += newDataNextY;
				xWall += oldWidth;
				jmp copyYAxisLoop;
			}
		}
		jmp success;
	}
	success:{
		if(deletePreviousData){
			free((*image).dataStart);
			popPointer((*image).dataToken);
		}
		(*image).width = newWidth;
		(*image).height = newHeight;
		(*image).dataStart = newData;
		(*image).dataToken = newDataToken;
		ret true;
	}
}
XCB_SYNC(){
	xcb_get_input_focus_reply_t *const reply = xcb_wait_for_reply(connection, xcb_get_input_focus(connection), NULL);
	uint32 token = pushPointer(reply, "sync reply", iFree);
	free(reply);
	popPointer(token);
	ret !!reply;
}
GETTIMESTAMP(){
	uint offset;
	if(!event){
		jmp invalidTimestamp;
	}
	offset = 0;
	jmp checkEventValidity;
	checkEventValidity: switch((*event).response_type){
		to XCB_KEY_PRESS: /*---------*/ /*-------*/ jmp validTimestamp;
		to XCB_KEY_RELEASE: /*-------*/ /*-------*/ jmp validTimestamp;
		to XCB_BUTTON_PRESS: /*------*/ /*-------*/ jmp validTimestamp;
		to XCB_BUTTON_RELEASE: /*----*/ /*-------*/ jmp validTimestamp;
		to XCB_MOTION_NOTIFY: /*-----*/ /*-------*/ jmp validTimestamp;
		to XCB_ENTER_NOTIFY: /*------*/ /*-------*/ jmp validTimestamp;
		to XCB_LEAVE_NOTIFY: /*------*/ /*-------*/ jmp validTimestamp;
		to XCB_PROPERTY_NOTIFY: /*---*/ offset = 2; jmp validTimestamp;
		to XCB_SELECTION_CLEAR: /*---*/ /*-------*/ jmp validTimestamp;
		to XCB_SELECTION_REQUEST: /*-*/ /*-------*/ jmp validTimestamp;
		to XCB_SELECTION_NOTIFY: /*--*/ /*-------*/ jmp validTimestamp;
		off: /*----------------------*/ /*-------*/ jmp invalidTimestamp;
	}
	invalidTimestamp:{
		ret XCB_CURRENT_TIME;
	}
	validTimestamp:{
		ret *(xcb_timestamp_t *)((*event).pad + offset);
	}
}
GETWINDOWCLASS(){
	jmp getWindowClass;
	getWindowClass:{
		xcb_get_window_attributes_reply_t *const reply = xcb_wait_for_reply(connection, xcb_get_window_attributes_unchecked(connection, window), NULL);
		uint32 token = pushPointer(reply, "getWindowClass() get window attributes reply", iFree);
		if(reply){
			const uint8 class = (*reply)._class;
			free(reply);
			popPointer(token);
			switch(class){
				to XCB_WINDOW_CLASS_COPY_FROM_PARENT: /*-*/ jmp getWindowParent;
				to XCB_WINDOW_CLASS_INPUT_OUTPUT: /*-----*/ ret XCB_WINDOW_CLASS_INPUT_OUTPUT;
				to XCB_WINDOW_CLASS_INPUT_ONLY: /*-------*/ ret XCB_WINDOW_CLASS_INPUT_ONLY;
				off: /*----------------------------------*/ ret XCB_WINDOW_CLASS_COPY_FROM_PARENT;
			}
		}
		jmp returnInconclusiveClass;
	}
	getWindowParent:{
		xcb_query_tree_reply_t *const reply = xcb_wait_for_reply(connection, xcb_query_tree_unchecked(connection, window), NULL);
		uint32 token = pushPointer(reply, "getWindowClass() query tree reply", iFree);
		if(reply){
			const xcb_window_t parent = (*reply).parent;
			free(reply);
			popPointer(token);
			if(parent != window){
				window = parent;
				jmp getWindowClass;
			}
		}
		jmp returnInconclusiveClass;
	}
	returnInconclusiveClass:{
		ret XCB_WINDOW_CLASS_COPY_FROM_PARENT;
	}
}
GETFOCUSEDWINDOW(){
	xcb_get_property_cookie_t propertyCookie;
	xcb_get_input_focus_cookie_t inputFocusCookie;
	xcb_window_t window = XCB_NONE;
	jmp getCookies;
	getCookies:{
		propertyCookie = xcb_get_property_unchecked(connection, false, (*screen).root, atom._NET_ACTIVE_WINDOW, XCB_ATOM_WINDOW, 0, 1);
		inputFocusCookie = xcb_get_input_focus_unchecked(connection);
		jmp getActiveWindow;
	}
	getActiveWindow:{
		xcb_get_property_reply_t *const reply = xcb_wait_for_reply(connection, propertyCookie, NULL);
		uint32 token = pushPointer(reply, "getFocusedWindow() get property reply", iFree);
		bool found = false;
		if(reply){
			if(xcb_get_property_value_length(reply) == sizeof(xcb_window_t)){
				window = *(xcb_window_t *)xcb_get_property_value(reply);
				found = true;
			}
			free(reply);
			popPointer(token);
			if(found){
				xcb_discard_reply(connection, inputFocusCookie);
				ret window;
			}
		}
		jmp getFocusedWindow;
	}
	getFocusedWindow:{
		xcb_get_input_focus_reply_t *const reply = xcb_wait_for_reply(connection, inputFocusCookie, NULL);
		uint32 token = pushPointer(reply, "getFocusedWindow() get input focus reply", iFree);
		if(reply){
			window = (*reply).focus;
			free(reply);
			popPointer(token);
		}
		ret window;
	}
}
GRABDEVICE(){
	uint currentAttempt = 0;
	struct timespec ts;
	ts.tv_sec = 0;
	ts.tv_nsec = 10 * 1000000;
	if(!attemptAmount){
		ret false;
	}
	jmp grabDeviceLoop;
	grabDeviceLoop:{
		void *reply;
		uint32 token;
		switch(device){
			to KEYBOARD_GRAB_DEVICE:{
				reply = xcb_wait_for_reply(connection, xcb_grab_keyboard_unchecked(connection, true, (*screen).root, getTimestamp(), XCB_GRAB_MODE_ASYNC, XCB_GRAB_MODE_ASYNC), NULL);
				token = pushPointer(reply, "grab keyboard reply", iFree);
				brk;
			}
			to POINTER_GRAB_DEVICE:{
				reply = xcb_wait_for_reply(connection, xcb_grab_pointer_unchecked(connection, true, (*screen).root, XCB_EVENT_MASK_BUTTON_PRESS, XCB_GRAB_MODE_ASYNC, XCB_GRAB_MODE_ASYNC, XCB_NONE, XCB_NONE, getTimestamp()), NULL);
				token = pushPointer(reply, "grab pointer reply", iFree);
				brk;
			}
			off:{
				ret true;
			}
		}
		if(reply){
			const bool flag = (*(xcb_grab_keyboard_reply_t *)reply).status == XCB_GRAB_STATUS_SUCCESS;
			free(reply);
			popPointer(token);
			if(flag){
				ret true;
			}
		}
		if(inc currentAttempt < attemptAmount){
			nanosleep(&ts, NULL);
			jmp grabDeviceLoop;
		}
		ret false;
	}
}
UNGRABDEVICE(){
	switch(device){
		to KEYBOARD_GRAB_DEVICE: /*-*/ xcb_ungrab_keyboard(connection, getTimestamp()); /*-*/ ret true;
		to POINTER_GRAB_DEVICE: /*--*/ xcb_ungrab_pointer(connection, getTimestamp()); /*--*/ ret true;
		off: /*---------------------*/ /*--------------------------------------------------*/ ret false;
	}
}
FILLDRAWABLE(){
	xcb_rectangle_t rectangle;
	rectangle.x = x;
	rectangle.y = y;
	rectangle.width = width;
	rectangle.height = height;
	xcb_change_gc(connection, gc, XCB_GC_FOREGROUND, &color);
	xcb_poly_fill_rectangle(connection, drawable, gc, 1, &rectangle);
	ret;
}
SETCLIPPINGRECTANGLE(){
	xcb_rectangle_t rectangle;
	if(!gc){
		ret false;
	}
	rectangle.x = x;
	rectangle.y = y;
	rectangle.width = width;
	rectangle.height = height;
	xcb_set_clip_rectangles(connection, XCB_CLIP_ORDERING_UNSORTED, gc, 0, 0, 1, &rectangle);
	ret true;
}
TIGHTENCLIPPINGRECTANGLE(){
	int intersectionX;
	int intersectionY;
	int intersectionWidth;
	int intersectionHeight;
	if(!gc or !clipXReturn or !clipYReturn or !clipWidthReturn or !clipHeightReturn){
		ret false;
	}
	getIntersection(x, y, width, height, *clipXReturn, *clipYReturn, *clipWidthReturn, *clipHeightReturn, &intersectionX, &intersectionY, &intersectionWidth, &intersectionHeight);
	setClippingRectangle(gc, intersectionX, intersectionY, intersectionWidth, intersectionHeight);
	*clipXReturn = intersectionX;
	*clipYReturn = intersectionY;
	*clipWidthReturn = intersectionWidth;
	*clipHeightReturn = intersectionHeight;
	ret true;
}
UNSETCLIPPINGRECTANGLE(){
	struct{
		xcb_pixmap_t /*-*/ clipMask;
	} valueList;
	if(!gc){
		ret false;
	}
	valueList.clipMask = XCB_NONE;
	xcb_change_gc(connection, gc, XCB_GC_CLIP_MASK, &valueList);
	ret true;
}
RESTART(){
	if(!isInsideConfig){
		disconnectSharedMemory(&sharedMemorySystem);
		disconnectSTDIN(&stdinSystem);
	}
	freeConfigVariables();
	ungrabShortcuts();
	finiShortcutSystem(&buttonShortcutSystem);
	finiShortcutSystem(&keycodeShortcutSystem);
	setConfigVariables();
	ret;
}
CLEANUP(){
	free(event);
	popPointer(eventToken);
	event = NULL;
	eventToken = 0;
	finiSharedMemorySystem(&sharedMemorySystem);
	finiSTDINSystem(&stdinSystem);
	finiSleepThreadSystem(&sleepThreadSystem);
	cancelThreads();
	ungrabShortcuts();
	freeConfigVariables();
	finiWindowSystem(&windowSystem);
	finiWindowManagerSystem();
	finiClientListSystem(&clientListStackingSystem);
	finiClientListSystem(&clientListSystem);
	finiVirtualRootSystem(&virtualRootSystem);
	finiClientSystem(&clientSystem);
	finiWallpaperSystem(&wallpaperSystem);
	finiCursorSystem(&cursorSystem);
	finiPointerSystem(&pointerSystem);
	finiMonitorSystem(&monitorSystem);
	if(connection){
		xcb_flush(connection);
		xcb_disconnect(connection);
		popPointer(connectionToken);
		connection = NULL;
		connectionToken = 0;
	}
	finiShortcutSystem(&buttonShortcutSystem);
	finiShortcutSystem(&keycodeShortcutSystem);
	finiStringTreeSystem(&macroStringTreeSystem);
	finiStringTreeSystem(&directionStringTreeSystem);
	finiStringTreeSystem(&whichMonitorStringTreeSystem);
	finiStringTreeSystem(&cornerStringTreeSystem);
	finiStringTreeSystem(&verticalAlignmentStringTreeSystem);
	finiStringTreeSystem(&horizontalAlignmentStringTreeSystem);
	finiStringTreeSystem(&numberTypeStringTreeSystem);
	finiStringTreeSystem(&shortcutStateStringTreeSystem);
	finiStringTreeSystem(&modifierStringTreeSystem);
	finiStringTreeSystem(&commandStringTreeSystem);
	finiStringTreeSystem(&variableStringTreeSystem);
	finiStringTreeSystem(&booleanStringTreeSystem);
	finiStringTreeSystem(&scope1ScopeInstructionStringTreeSystem);
	finiStringTreeSystem(&globalInstructionStringTreeSystem);
	finiStringTreeSystem(&globalScopesInstructionStringTreeSystem);
	finiPermissionSystem(&permissionSystem);
	if(memoryManagerSystem.allocated > 1){
		printError("%s%s: %s%s:%s %s", colorStart, programName, colorError, "warning", colorEnd, "program exited with unaccounted for data pointers, namely:\n");
		printUnaccountedForPointers(memoryManagerSystem.data + 1, memoryManagerSystem.data + memoryManagerSystem.allocated);
	}
	finiMemorySystem();
	closeErrorStream();
	exit(EXIT_SUCCESS);
}
CANCELTHREADS(){
	if(globalsLockCreated){
		if(pthread_rwlock_destroy(&globalsLock) != PTHREAD_RWLOCK_DESTROY_SUCCESS){
			printTitledError("pthread error", "could not destroy globals lock");
		}
		globalsLockCreated = false;
	}
	ret;
}
PRINTUNACCOUNTEDFORPOINTERS(){
	if(current < wall){
		jmp printPointedVariablesLoop;
		printPointedVariablesLoop:{
			if((*current).data){
				labelExamined = (*current).label;
				printError("\t%s: line %u: %s\n", (*current).file, (*current).line, labelExamined);
			}
			if(inc current < wall){
				jmp printPointedVariablesLoop;
			}
		}
	}
	ret;
}
PRINTERROR(){
	if(openErrorStream()){
		va_list arguments;
		va_start(arguments, message);
		flockfile(errorStream);
		vfprintf(errorStream, message, arguments);
		funlockfile(errorStream);
		va_end(arguments);
		closeErrorStream();
	}
	ret;
}
PRINTTITLEDERROR(){
	printError("%s%s: %s%s:%s %s\n", colorStart, programName, colorError, title, colorEnd, message);
	ret;
}
PRINTTITLEDQUOTEDERROR(){
	printError("%s%s: %s%s:%s \"%s\" %s\n", colorStart, programName, colorError, title, colorEnd, argument, message);
	ret;
}
PRINTCONNECTIONERROR(){
	const char *string;
	jmp findConnectionError;
	findConnectionError: switch(xcb_connection_has_error(connection)){
		to XCB_CONN_ERROR: /*-------------------*/ string = "socket/pipe/stream error"; /*------*/ jmp printConnectionError;
		to XCB_CONN_CLOSED_EXT_NOTSUPPORTED: /*-*/ string = "extension not supported"; /*-------*/ jmp printConnectionError;
		to XCB_CONN_CLOSED_MEM_INSUFFICIENT: /*-*/ string = "insufficient memory"; /*-----------*/ jmp printConnectionError;
		to XCB_CONN_CLOSED_REQ_LEN_EXCEED: /*---*/ string = "exceeded request length"; /*-------*/ jmp printConnectionError;
		to XCB_CONN_CLOSED_PARSE_ERR: /*--------*/ string = "error parsing display string"; /*--*/ jmp printConnectionError;
		to XCB_CONN_CLOSED_INVALID_SCREEN: /*---*/ string = "screen-display mismatch"; /*-------*/ jmp printConnectionError;
		off: /*---------------------------------*/ string = "unrecognized connection error"; /*-*/ jmp printConnectionError;
	}
	printConnectionError:{
		printTitledError("fatal X server error", string);
		ret;
	}
}
PRINTTITLEDNAMEDERROR(){
	printError("%s%s: %s%s:%s %s %s\n", colorStart, programName, colorError, title, colorEnd, message, name);
	ret;
}
PRINTXERROR(){
	#define useExtensionName(n0, n1) /*------*/ n0 == n1##ErrorName? "X " #n1 " error"
	#define useErrorName(n0, n1) /*----------*/ n0 == n1##ErrorName and (*error).error_code >= n1##BaseError? *(n1##ErrorName + ((*error).error_code - n1##BaseError))
	#define useErrorOperationName(n0, n1) /*-*/ n0 == n1##ErrorName? *(n1##OperationName + ((*error).minor_code >= countof(n1##OperationName)? countof(n1##OperationName) - 1 : (*error).minor_code))
	#define baseBaseError (0)
	const xcb_generic_error_t *const error = (void *)event;
	printError("%s%s: %s%s:%s %s error in %s operation using the 0x%x resource\n", colorStart, programName, colorError
		, name == baseErrorName? "X error"
		: useExtensionName(name, randr)
		: useExtensionName(name, shape)
		: useExtensionName(name, xfixes)
		: "X unrecognized extension event"
		, colorEnd
		, useErrorName(name, base)
		: useErrorName(name, randr)
		: useErrorName(name, shape)
		: useErrorName(name, xfixes)
		: "unrecognized"
		, useErrorOperationName(name, base)
		: useErrorOperationName(name, randr)
		: useErrorOperationName(name, shape)
		: useErrorOperationName(name, xfixes)
		: "unrecognized"
	, (*error).resource_id);
	ret;
	#undef  useErrorOperationName
	#undef  useErrorName
}
PRINTTITLEDVALUEDERROR(){
	printError("%s%s: %s%s:%s %s %u\n", colorStart, programName, colorError, title, colorEnd, message, value);
	ret;
}
PRINTCONFIGERROR(){
	const char *statementCurrent = statementStart;
	const uint itemAmountWall = instructionCurrent - instructionStart;
	uint itemAmount = 0;
	uint spaceAmount = 0;
	StringTreeSystem *const *data;
	if(!openErrorStream()){
		ret;
	}
	flockfile(errorStream);
	fprintf(errorStream, "%s%s: %s: ", colorStart, programName, configPath);
	if(printLine){
		fprintf(errorStream, "line %u: ", statementLine);
	}
	fprintf(errorStream, "%s%s:%s %s", colorError, type, colorEnd, message);
	if(printConfig){
		fprintf(errorStream, ":\n\t config |");
	}else{
		fprintf(errorStream, "\n");
		jmp emergencyExit;
	}
	jmp printStatementItemLoop;
	printStatementItemLoop:{
		if(statementCurrent < statementWall){
			fprintf(errorStream, " %s", statementCurrent);
			jmp pushOutTermLoop;
			pushOutTermLoop:{
				if(*(inc statementCurrent)){
					jmp pushOutTermLoop;
				}
				inc statementCurrent;
			}
			if(itemAmount == itemAmountWall and instructionStart){
				spaceAmount = statementCurrent - statementStart;
			}
			inc itemAmount;
			jmp printStatementItemLoop;
		}
		if(spaceAmount == 0 and finalStatementCharacter != ';'){
			fprintf(errorStream, " ");
		}
		fprintf(errorStream, "%c\n", finalStatementCharacter);
		jmp printPattern;
	}
	printPattern:{
		if(printPointer){
			if(spaceAmount == statementCurrent - statementStart){
				dec spaceAmount;
			}
			fprintf(errorStream, "\t        |%*c^\n", inc spaceAmount, ' ');
		}
		if(!printPattern or !instructionStart){
			fprintf(errorStream, "\n");
			jmp emergencyExit;
		}
		fprintf(errorStream, "\n\tpattern | %s", *(currentScopeInstructionList + (*currentScopeInstructionStringTreeSystem).returnedCounter));
		dec instructionStart;
		data = instructionDataStart;
		jmp printInstructionParameterLoop;
	}
	printInstructionParameterLoop: switch(*(inc instructionStart)){
		to NONE_INSTRUCTION_TYPE: /*------*/ jmp noneInstruction;
		to NAME_INSTRUCTION_TYPE: /*------*/ jmp nameInstruction;
		to NAME_LIST_INSTRUCTION_TYPE: /*-*/ jmp nameListInstruction;
		to NUMBER_INSTRUCTION_TYPE: /*----*/ jmp numberInstruction;
		to STRING_INSTRUCTION_TYPE: /*----*/ jmp stringInstruction;
		to IMAGE_INSTRUCTION_TYPE: /*-----*/ jmp imageInstruction;
		off: /*---------------------------*/ jmp printInstructionParameterLoopExit;
	}
	noneInstruction:{
		fprintf(errorStream, " <unimplemented>");
		jmp printInstructionParameterLoopExit;
	}
	nameInstruction:{
		if(instructionStart < instructionCurrent){
			inc data;
			jmp printTilde;
		}
		if(displaySimpleConfigErrors){
			fprintf(errorStream, " name");
			jmp printInstructionParameterLoop;
		}
		if((**data).stringArray){
			const char *const *stringArray = (**data).stringArray;
			fprintf(errorStream, " (%s", *stringArray);
			inc stringArray;
			jmp printNameLoop;
			printNameLoop:{
				if(*stringArray){
					fprintf(errorStream, "|%s", *stringArray);
					inc stringArray;
					jmp printNameLoop;
				}
				fprintf(errorStream, ")");
			}
		}
		inc data;
		jmp printInstructionParameterLoop;
	}
	nameListInstruction:{
		if(instructionStart < instructionCurrent){
			inc data;
			jmp printTilde;
		}
		if(displaySimpleConfigErrors){
			fprintf(errorStream, " list");
			jmp printInstructionParameterLoop;
		}
		if((**data).stringArray){
			const char *const *stringArray = (**data).stringArray;
			fprintf(errorStream, " ((%s", *stringArray);
			inc stringArray;
			jmp printNameListOnceLoop;
			printNameListOnceLoop:{
				if(*stringArray){
					fprintf(errorStream, "|%s", *stringArray);
					inc stringArray;
					jmp printNameListOnceLoop;
				}
				stringArray = (**data).stringArray;
				fprintf(errorStream, ")[\\s]*([\\s]*[|][\\s]*(%s", *stringArray);
				inc stringArray;
				jmp printNameListTwiceLoop;
			}
			printNameListTwiceLoop:{
				if(*stringArray){
					fprintf(errorStream, "|%s", *stringArray);
					inc stringArray;
					jmp printNameListTwiceLoop;
				}
				fprintf(errorStream, "))*(?![\\s]*[|]))");
			}
		}
		inc data;
		jmp printInstructionParameterLoop;
	}
	numberInstruction:{
		if(instructionStart < instructionCurrent){
			jmp printTilde;
		}
		if(displaySimpleConfigErrors){
			fprintf(errorStream, " number");
			jmp printInstructionParameterLoop;
		}
		fprintf(errorStream, " (([0][\\s]*[x][\\s]*([a-fA-F0-9][\\s]*)*|([0-9][\\s]*)+|[+*/][\\s]*)+)");
		jmp printInstructionParameterLoop;
	}
	stringInstruction:{
		if(instructionStart < instructionCurrent){
			jmp printTilde;
		}
		if(displaySimpleConfigErrors){
			fprintf(errorStream, " string");
			jmp printInstructionParameterLoop;
		}
		fprintf(errorStream, " ([\"].*[\"]|[\'].*[\'])");
		jmp printInstructionParameterLoop;
	}
	imageInstruction:{
		if(instructionStart < instructionCurrent){
			jmp printTilde;
		}
		if(displaySimpleConfigErrors){
			fprintf(errorStream, " image");
			jmp printInstructionParameterLoop;
		}
		fprintf(errorStream, " ([\"].*[\"]|[\'].*[\'])");
		jmp printInstructionParameterLoop;
	}
	printTilde:{
		fprintf(errorStream, " ~");
		jmp printInstructionParameterLoop;
	}
	printInstructionParameterLoopExit:{
		if(displaySimpleConfigErrors){
			fprintf(errorStream, "\n\n");
			jmp emergencyExit;
		}
		fprintf(errorStream, " $\n\n");
		jmp emergencyExit;
	}
	emergencyExit:{
		funlockfile(errorStream);
		closeErrorStream();
		ret;
	}
}
OPENERRORSTREAM(){
	if(!mustOpenErrorStream){
		ret true;
	}
	errorStream = fopen(errorPath, "a");
	errorStreamToken = pushPointer(errorStream, "error stream", fclose);
	if(errorStream){
		ret true;
	}
	mustOpenErrorStream = false;
	errorStream = DEFAULT_ERROR_STREAM;
	colorStart = MESSAGE_START;
	colorFatal = MESSAGE_FATAL;
	colorError = MESSAGE_ERROR;
	colorEvent = MESSAGE_EVENT;
	colorEnd = MESSAGE_END;
	printTitledError("stream error", "could not open error file, reverting to the default error stream");
	ret true;
}
CLOSEERRORSTREAM(){
	if(!mustOpenErrorStream or !errorStream){
		ret false;
	}
	fclose(errorStream);
	popPointer(errorStreamToken);
	errorStreamToken = 0;
	ret true;
}

